<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>Learn You a Haskell for Great Good! - Types and Typeclasses</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <base href="http://learnyouahaskell.com/"> <style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style><link rel="shortcut icon" href="favicon.png" type="image/png">
    <link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
    <link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
  </head>
  <body class="introcontent">
    <div class="bgwrapper">
      <div id="content">
        <div class="footdiv" style="margin-bottom: 25px;">
          <ul>
            <li style="text-align: left;"> <a href="starting-out" class="prevlink">시
                작</a> </li>
            <li style="text-align: center;"> <a href="chapters">목 차</a>
            </li>
            <li style="text-align: right;"> <a href="syntax-in-functions"
                class="nxtlink">Syntax in Functions</a> </li>
          </ul>
        </div>
        <h1>타입과 타입클래스</h1>
        <h1></h1>
        <a name="believe-the-type"></a>
        <h2>타입을 믿으세요</h2>
        <h2></h2>
        <img src="http://s3.amazonaws.com/lyah/cow.png" alt="moo" class="left"
          height="127" width="180">
        <p>전에 제가 하스켈은 정적 타입 시스템을 지녔다고 언급하였습니다. 모든 표현식의 타입은 컴파일 타임에 판명나며,
          이는 보다 안전한 코드로 이끌어 줍니다.&nbsp;부울대수를 숫자로 나누려는 프로그램을 작성한다면, 컴파일이
          되지 않을 것입니다. 이게 좋은게, 나중에 프로그램이 멈추어 버리는 것보다 컴파일 타임에 이러한 종류의 에러를
          잡는 것이 낫기 때문입니다. 하스켈에서 모든것은 타입을 지니므로, 컴파일 하기전 컴파일러는 프로그램에 대해
          상당수를 판별할 수 있습니다.</p>
        <p>자바 및 파스칼과는 달리, 하스켈은 <strong>타입추론(type inference)</strong>을
          지녔습니다. 예를들어, 숫자를 썼다면 하스켈에게 숫자라고 알려줄 필요가 없습니다. 스스로 추론할 수 있어,
          명시적으로 함수와 표현식의 타입을 작성할 필요는 없습니다. 지금까지 우리는 하스켈의 타입에 관해 몇몇 기본적이며
          매우 피상적인것을 다루었습니다.&nbsp; 하지만, 타입 시스템의 이해는 하스켈을 배우는 단계에서 가장
          중요합니다.</p>
        <p>타입은 모든 표현식이 갖고있는 이름표입니다. 이는 표현식에 맞는 범주가 어느것인지 알려줍니다. 표현식 <span
            class="fixed">True</span>는 부울대수이며, <span class="fixed">"hello"</span>는
          문자열, 등등이 있습니다.</p>
        <p>이제 저희는 GHCI를 이용하여 표현식의 타입을 밝혀낼 것입니다. 이를 :t 명령어와 타입을 알려주는 유효한
          표현식을 이용하여 할 수 있습니다. 한번 돌려 봅시다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t 'a'
'a' :: Char
ghci&gt; :t True
True :: Bool
ghci&gt; :t "HELLO!"
"HELLO!" :: [Char]
ghci&gt; :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci&gt; :t 4 == 5
4 == 5 :: Bool
</pre>
        <p> <img src="http://s3.amazonaws.com/lyah/bomb.png" alt="bomb"
            class="right" height="144" width="171"> 여기서 저희는 ':t
          표현식'이&nbsp; '표현식 <span class="fixed">::</span> 타입'을 출력한다는 것을
          알 수 있습니다. <span class="fixed">::</span>를 "타입을 지녔다"라고 읽습니다.
          명시적 타입은 항상 첫번째 문자를 대문자로 표시합니다. <span class="fixed">'a'</span>는
          &nbsp;<span class="fixed">Char</span>타입을 지녔습니다. 문자를 대표한다는 것을
          쉽게 알 수 있습니다. <span class="fixed">True</span>는 <span class="fixed">Bool</span>타
          입입니다. 뭐 맞는 말입니다. 하지만 이건 무엇일까요? <span class="fixed">"HELLO!"</span>의
          타입이&nbsp;<span class="fixed">[Char]</span>라는 것을 살펴보시기 바랍니다. 사각
          괄호는 리스트를 나타냅니다. 따라서 저희는 이것을 문자 리스트라 읽을 수 있습니다. 리스트와 달리, 튜플의 길이
          각각은 자신만의 고유한 타입을 지닙니다. 따라서 표현식<span class="fixed">(True, 'a')</span>은
          타입 <span class="fixed">(Bool, Char)</span>을 지니며, 표현식 <span class="fixed">('a','b','c')</span>은
          타입<span class="fixed">(Char, Char, Char)</span>을 지닐 것입니다. <span
            class="fixed">4 == 5</span>는 항상 <span class="fixed">False</span>를
          반환하기에, 이것의 타입은 <span class="fixed">Bool</span>입 니다. </p>
        <p>함수 또한 타입을 갖습니다. 함수를 작성할 때, 명시적 타입 선언을 할 수 있습니다. 매우 짧은 함수를 작성할
          때를 제외하면 이는 보통 바람직한 행동입니다. 여기선, 저희는 모든 함수에 타입 선언을 할것입니다. 1장에서
          작성한 문자열에서 소문자를 걸러내는 리스트 해석(list comprehension)이 기억나십니까? 여기 어떻게
          타입을 선언해야 하는지가 나와있습니다: </p>
        <pre name="code" class="haskell: hs">removeNonUppercase :: [Char] -&gt; [Char]
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] 
</pre>
        <p> <span class="fixed">removeNonUppercase</span>는 문자열과 문자열을
          연결한 타입 <span class="fixed">[Char] -&gt; [Char]</span>을 지녔습니다.
          문자열을 인자로 받아 결과로 또다른 문자열을 반환하기 때문입니다. <span class="fixed">[Char]</span>타
          입은 <span class="fixed">String</span>(문자열)과 동의어이므로, <span class="fixed">removeNonUppercase
















            :: String -&gt; String</span>라 작성해도 됩니다. 저희가 타입 선언하든 않하든,
          컴파일러 스스로 함수가 문자열이 문자열이 된다는 것을 알기에, 딱히 타입 선언을 할 필요는 없습니다. 하지만
          여러 인자를 취하는 함수의 타입을 작성하려면 어떻게 해야할까요? 여기 3개의 정수를 받아 더하는, 간단한 함수가
          있습니다: </p>
        <pre name="code" class="haskell: hs">addThree :: Int -&gt; Int -&gt; Int -&gt; Int
addThree x y z = x + y + z
</pre>
        <p>인자는&nbsp; <span class="fixed">-&gt;</span>로 구분되어 있으며, 반환
          타입간에 딱히 다른 점은 없습니다. 반환 타입은 선언의 마지막 항목이며, 인자는 처음 3개의 항목입니다. 후에
          <span class="fixed">Int, Int, Int -&gt; Int</span> 처럼 명확하게
          구분하는 대신, 왜 모두 <span class="fixed">-&gt;</span>로 분리해 놨는지를 살펴볼
          것입니다. </p>
        <p>함수에 타입 선언을 하고자 하지만, 함수가 무엇을 하는지 확신할 수 없다면, 타입선언이 없는 함수를 작성한
          다음 <span class="fixed">:t</span>로 확인할 수 있습니다. 함수 역시 표현식이므로, <span
            class="fixed">:t</span> 도 문제없이 동작합니다.</p>
        <p>여기 몇몇 커먼(common) 타입의 개요가 있습니다.</p>
        <p> <span class="label type">Int</span>는 정수를 대변합니다. 이는 모든 숫자에
          사용됩니다. <span class="fixed">7</span>은<span class="fixed">Int</span>가
          될 수 있지만 <span class="fixed">7.2</span>은 되지 못합니다. <span class="fixed">Int</span>는
          제한되었으며, 이는 최소값과 최대값을 지닌다는 것을 의미합니다. 보통 32비트 머신에서 가능한 <span class="fixed">Int</span>의
          최대값은 2147483647이며 최소값은 -2147483648입니다. </p>
        <p><span class="label type">Integer</span> 또한 정수를 대변합니다. 주된 차이점은
          제한되지 않아, 어마어마하게 큰 숫자를 표현하는데 이용할 수 있습니다. 하지만 효율은 <span class="fixed">Int</span>가
          더 좋습니다. </p>
        <pre name="code" class="haskell: hs">factorial :: Integer -&gt; Integer
factorial n = product [1..n]
</pre>
        <pre name="code" class="haskell: ghci">ghci&gt; factorial 50
30414093201713378043612608166064768844377641568960512000000000000
</pre>
        <p><span class="label type">Float</span>는 단일 정밀도를 지닌 부동 소숫점
          실수입니다.</p>
        <pre name="code" class="haskell: hs">circumference :: Float -&gt; Float
circumference r = 2 * pi * r
</pre>
        <pre name="code" class="haskell: ghci">ghci&gt; circumference 4.0
25.132742
</pre>
        <p><span class="label type">Double</span>는 2배 정밀도를 지닌 부동 소숫점
          실수입니다!</p>
        <pre name="code" class="haskell: hs">circumference' :: Double -&gt; Double
circumference' r = 2 * pi * r
</pre>
        <pre name="code" class="haskell: ghci">ghci&gt; circumference' 4.0
25.132741228718345
</pre>
        <p> <span class="label type">Bool</span>은 부울대수 타입입니다. 오직 2개의
          값만을 가집니다: <span class="fixed">True</span>와 <span class="fixed">False</span>.
        </p>
        <p> <span class="label type">Char</span>는 문자를 나타냅니다. 이는 따옴표로
          나타냅니다. 문자 리스트는 문자열입니다.</p>
        <p>튜플은 타입이지만, 길이뿐만 아니라 구성물의 타입에도 영향을 받습니다. 따라서, 이론적으로 튜플의 타입은 이
          튜토리얼에서 다루기엔 너무 많은 무수히 많은 갯수를 가집니다, 비어있는 튜플 <span class="label type">()</span>은
          오직 하나 만을 값으로 갖는 타입입니다:&nbsp; <span class="fixed">()</span><span
            class="fixed"></span></p>
        <a name="type-variables"></a>
        <h2>타입 변수<br>
        </h2>
        <p>&nbsp;<span class="fixed">head</span>함수의 타입은 무엇일까요? <span class="fixed">head</span>는
          리스트를 취해 첫번째 원소를 반환하는데, 어떤 타입이 될까요? 확인해 봅시다! </p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t head
head :: [a] -&gt; a
</pre>
        <p> <img src="http://s3.amazonaws.com/lyah/box.png" alt="box" class="left"
            height="93" width="130"> 흠! 이 <span class="fixed">a</span>가
          뭘까요? 타입인가요? 이전에 타입이 대문자로 시작한다는 것을 기억한다면, 이것은 분명 타입이 아닙니다. 대문자로
          시작하지 않기에 이것은 <em>타입 변수(Type Variables)</em>입니다. 이는 <span class="fixed">a</span>가
          어떠한 타입이라도 될 수 있다는 것을 의미합니다. 이는 다른 언어에서의 제네릭(generic)과 매우
          유사하지만, 하스켈에선 타입의 행동을 명시하지 않더라도, 쉽게 일반화된(general) 함수를 작성할 수 있기에
          더욱 강력합니다. 타입 변수를 지닌 함수를 <em>다형(polymorphic)함수</em>라 부릅니다. <span
            class="fixed">head</span>의 타입 선언은 어떤 타입의 리스트를 받아 그 타입의 원소
          하나를 반환한다고 명시되었습니다. </p>
        <p>타입 변수의 이름을 하나 이상의 문자로 구성할 수 있지만, 보통 a, b, c, d ...로 합니다.</p>
        <p>pair에서 첫번째 항목을 반환하는 <span class="fixed">fst</span>를
          기억하십니까?&nbsp; 이것의 타입을 알아 봅시다:</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t fst
fst :: (a, b) -&gt; a
</pre>
        <p>&nbsp; <span class="fixed">fst</span>가 2개의 타입을 지닌 튜플을 받아 첫번째
          항목과 동일한 타입의 원소를 반환하는 것을 확인할 수 있습니다. 이것이 2개의 타입을 지닌 쌍에 <span class="fixed">fst</span>를
          사용할 수 있는지에 대한 이유입니다.&nbsp; a와 b의 타입 변수가 다르기에, 타입이 뒤바뀌지 않는다는 것에
          주목하시기 바랍니다. 이는 바로 첫번째 항목의 타입과 반환되 값의 타입이 동일할 것이라는 것을 의미합니다. </p>
        <a name="typeclasses-101"></a>
        <h2>타입클래스 101</h2>
        <img src="http://s3.amazonaws.com/lyah/classes.png" alt="class"
          class="right" height="158" width="210">
        <p>타입클래스는 몇몇 행동을 정의하는 인터페이스입니다. 타입이 타입 클래스의 인스턴스라는 것은, 타입은 그 타입
          클래스가 기술하는 행동을 지원하며 구현한다는 것을 의미합니다. OOP에서 넘어온 많은 사람들이 객체 지향
          언어에서의 클래스를 생각하기에 타입클래스를 혼란스러워합니다. 저런, 그건 아닙니다. Java의 인터페이스라
          생각하는게 낫을 것입니다. </p>
        <p>&nbsp;<span class="fixed">==</span>함수의 타입서명은 무엇일까요?</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t (==)
(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool
</pre>
        <div class="hintbox"><em>Note</em>: 등위 연산자 <span class="fixed">==</span>
          은 함수입니다.&nbsp; <span class="fixed">+</span>, <span class="fixed">*</span>,
          <span class="fixed">-</span>, <span class="fixed">/</span>와
          다른 수 많은 연산자들도 그러합니다. 함수가 특별한 문자로만 구성되어 있으면, 기본적으로 중위함수라 여겨집니다.
          타입이 뭔지 확인하려면, 다른 함수에 넣어 보거나, 괄호로 둘러싸 전위함수로 호출해야 합니다.</div>
        <p>흥미롭군요. 저희는 여기서 새로운&nbsp;<span class="fixed">=&gt;</span>심볼을
          발견하였습니다. <span class="fixed">=&gt;</span>심볼 이전의 것을 <em>클래스
            제약(class constraint)</em>이라 합니다. 타입 선언을 다음과 같이 읽을 수 있습니다:
          "등위함수는 동일한 타입의 두 값을 취해 <span class="fixed">Bool</span>을 반환한다.
          그 타입은 클래스 제약에 의해 <span class="fixed">Eq</span>클래스의 멤버여야 한다".</p>
        <p><span class="fixed">Eq</span>타입클래스는 동일성을 판별하기 위한 인터페이스를
          제공합니다.&nbsp; 특정 타입에 두 항목의 같음을 비교할 수 있으면, 그 타입은 <span class="fixed">Eq</span>클
          래스의 멤버가 될 수 있습니다. 입력과 출력을 담당하는 타입을 제외하면, 표준 하스켈의 모든 타입들은 <span
            class="fixed">Eq</span>타입클래스의 한 부분입니다.</p>
        <p><span class="fixed">elem</span>함수는 리스트 내부에 있는 값을 찾기위해 <span
            class="fixed">==</span>를 이용하므로 <span class="fixed">(Eq a)
            =&gt; a -&gt; [a] -&gt; Bool</span>타입을 지닙니다.</p>
        <p>몇몇 기본 타입클래스들:</p>
        <p><span class="label class">Eq</span>는 동등성 검사를 지원하는 타입에 이용됩니다.
          이의 맴버 구현 함수는 <span class="fixed">==</span>와 <span class="fixed">/=</span>입
          니다. 함수에 타입 변수에 대한 <span class="fixed">Eq</span>클래스 제약이
          있다면,&nbsp; 이 내부 정의 어딘가에는 <span class="fixed">==</span>나 <span
            class="fixed">/=</span>을 사용할 것입니다. 함수를 제외한 이전에 저희가 언급한 모든
          타입들은 <span class="fixed">Eq</span>의 한 부분이므로, 이것들로부터 동등성을 검사할
          수 있습니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; 5 == 5
True
ghci&gt; 5 /= 5
False
ghci&gt; 'a' == 'a'
True
ghci&gt; "Ho Ho" == "Ho Ho"
True
ghci&gt; 3.432 == 3.432
True
</pre>
        <p> <span class="label class">Ord</span>는 순서를 가진 타입입니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t (&gt;)
(&gt;) :: (Ord a) =&gt; a -&gt; a -&gt; Bool
</pre>
        <p> 함수를 제외한, 저희가 다루는 모든 타입들은 <span class="fixed">Ord</span>의 한
          부분입니다. <span class="fixed">Ord</span>는 <span class="fixed">&gt;</span>,
          <span class="fixed">&lt;</span>, <span class="fixed">&gt;=</span>,
          <span class="fixed">&lt;=</span>와 같은 표준 비교 함수들을 모두 다룹니다. <span
            class="fixed">compare</span>함수는 동일한 타입의 두 <span class="fixed">Ord</span>멤
          버를 받아 순서(ordering)를 반환합니다. <span class="label type">Ordering</span>은
          각각 보다 큰(greater than), 보다 작은(lesser than), 같음(equal)을 나타내는 <span
            class="fixed">GT</span>, <span class="fixed">LT</span>, <span
            class="fixed">EQ</span>가 될 수 있는 타입입니다. </p>
        <p>&nbsp;<span class="fixed">Ord</span>맴버가 되기 위해선, 우선 명문 <span
            class="fixed">Eq</span>클럽의 회원이 되어야만 합니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; "Abrakadabra" &lt; "Zebra"
True
ghci&gt; "Abrakadabra" `compare` "Zebra"
LT
ghci&gt; 5 &gt;= 2
True
ghci&gt; 5 `compare` 3
GT
</pre>
        <p>&nbsp;<span class="label class">Show</span>의 맴버는 문자열로 나타낼 수
          있습니다. 함수를 제외한, 지금까지 다룬 모든 타입들은 <span class="fixed">Show</span>의
          한 부분입니다. <span class="fixed">Show</span>타입클래스를 다루는 함수중 가장 많이
          사용되는 것은 <span class="fixed">show</span>입니다. 이는 <span class="fixed">Show</span>타
          입의 맴버인 값을 취해 문자열로 표시합니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; show 3
"3"
ghci&gt; show 5.334
"5.334"
ghci&gt; show True
"True"
</pre>
        <p><span class="label class">Read</span>는 <span class="fixed">Show</span>
          타입클래스와는 반대입니다. <span class="fixed">read</span>함수는 문자열을 취해 <span
            class="fixed">Read</span>맴버인 타입을 반환합니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; read "True" || False
True
ghci&gt; read "8.2" + 3.8
12.0
ghci&gt; read "5" - 2
3
ghci&gt; read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
</pre>
        <p>머 괜찮게 나왔습니다. 지금까지 다룬 모든 타입들 또한&nbsp; 이 타입클래스안에 있습니다. 그러면 <span
            class="fixed">read "4"</span>라 입력하면 어떻게 될까요?</p>
        <pre name="code" class="haskell: ghci">ghci&gt; read "4"
&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraint:
      `Read a' arising from a use of `read' at &lt;interactive&gt;:1:0-7
    Probable fix: add a type signature that fixes these type variable(s)
</pre>
        <p>여기서 GHCI가 저희에게 말하는 것은 뭘 반환해야 하는지 모르겠다는 것입니다.&nbsp; 이전 read의
          사용에서 결과에 무언가를 한 것에 주목하시기 바랍니다. 이러한 방법으로, GHCI는 <span class="fixed">read</span>에
          서 얻고자 하는 것을 추론할 수 있었습니다. 예를들어, 저희가 부울대수로 이용하였다면, <span class="fixed">Bool</span>을
          반환할 것입니다. 그러나 지금, <span class="fixed">Read</span>클래스의 어떠한 타입을
          원하지만, 그 어떠한 것이 무엇인지를 모릅니다. <span class="fixed">read</span>의
          타입 서명을 살펴봅시다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t read
read :: (Read a) =&gt; String -&gt; a
</pre>
        <p> 보이십니까? <span class="fixed">Read</span>타입을 반환하였지만, 만약 저희가 다른
          방법을 이용한다면, 어떤 타입인지 알 수 없을 것입니다. 이것이 바로 <em>타입 어노테이션(type
            annotations)</em>을 사용해야 하는 이유입니다. 타입 어노테이션은 표현식의 타입이 무엇인지
          명시적으로 알려주는 하나의 방법입니다. 표현식 끝에&nbsp; <span class="fixed">::</span>을
          추가하고 타입을 명시함으로써 이를 행할 수 있습니다. 살펴봅시다: </p>
        <pre name="code" class="haskell: ghci">ghci&gt; read "5" :: Int
5
ghci&gt; read "5" :: Float
5.0
ghci&gt; (read "5" :: Float) * 4
20.0
ghci&gt; read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci&gt; read "(3, 'a')" :: (Int, Char)
(3, 'a')
</pre>
        <p>이와 같이 컴파일러는 표현식의 타입 대부분을 스스로 추론할 수 있습니다. 그러나, 때때로 컴파일러는 <span
            class="fixed">read "5"</span>와 같은 표현식의 반환값의 타입이 <span class="fixed">Int</span>인
          지 <span class="fixed">Float</span>인지를 알지 못합니다. 타입이 무엇인지 확인하기
          위해선, 하스켈은 실제로 <span class="fixed">read "5"</span>를 평가해야만 합니다.
          그러나 하스켈은 정적 타입 언어이기에, 코드가 컴파일 되기 전에 (혹은 GHCi인 경우, 평가하여)모든 타입을
          알아야만 합니다. 따라서 저희는 "이 표현식은 이러한 타입을 갖는다고!"라고 하스켈에게 알려줘야 합니다.</p>
        <p><span class="label class">Enum</span>맴버는 연속적인 순서를 지닌 타입입니다 —
          열거할 수 있습니다.&nbsp; <span class="fixed">Enum</span> 타입 클래스의 주요한
          이점은 리스트 범위에 이 값들을 사용할 수 있다는 것입니다. 또한 이는 <span class="fixed">succ</span>와
          <span class="fixed">pred</span>함수로 얻을 수 있는 계승자(successor)와
          선구자(predecessor)를 지닙니다. 이 클래스에 속한 타입들: <span class="fixed">()</span>,
          <span class="fixed">Bool</span>, <span class="fixed">Char</span>,
          <span class="fixed">Ordering</span>, <span class="fixed">Int</span>,
          <span class="fixed">Integer</span>, <span class="fixed">Float</span>,
          <span class="fixed">Double</span>.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; ['a'..'e']
"abcde"
ghci&gt; [LT .. GT]
[LT,EQ,GT]
ghci&gt; [3 .. 5]
[3,4,5]
ghci&gt; succ 'B'
'C'
</pre>
        <p><span class="label class">Bounded</span>맴버는 상한와 하한을 지닙니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; minBound :: Int
-2147483648
ghci&gt; maxBound :: Char
'\1114111'
ghci&gt; maxBound :: Bool
True
ghci&gt; minBound :: Bool
False
</pre>
        <p>&nbsp;<span class="fixed">(Bounded a) =&gt; a</span>란 타입을 갖는
          <span class="fixed">minBound</span>와 <span class="fixed">maxBound</span>함
          수는 흥미롭습니다. 이러한 경우, 이는 <strong>다형 상수(polymorphic constants)</strong>입
          니다.</p>
        <p>구성물들이 모두 <span class="fixed">Bounded</span>된 튜플 또한 <span class="fixed">Bounded</span>의
          한 부분입니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
</pre>
        <p><span class="label class">Num</span>은 숫자형 타입클래스입니다. 이의 맴버는
          숫자처럼 행동 할 수 있는 속성을 갖습니다. 숫자형 타입을 실험해 봅시다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t 20
20 :: (Num t) =&gt; t
</pre>
        <p>이것은 모든 숫자 또한 다형 상수라는 것을 보여주고 있습니다. 숫자는 <span class="fixed">Num</span>타
          입클래스 맴버의 어떠한 타입처럼 행동 할 수 있습니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; 20 :: Int
20
ghci&gt; 20 :: Integer
20
ghci&gt; 20 :: Float
20.0
ghci&gt; 20 :: Double
20.0
</pre>
        <p>이 타입들은 <span class="fixed">Num</span>타입클래스에 포함됩니다.&nbsp; <span
            class="fixed">*</span>의 타입을 알아본다면, 이것이 모든 숫자를 받아들인다는 것을 발견할
          것입니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t (*)
(*) :: (Num a) =&gt; a -&gt; a -&gt; a
</pre>
        <p> 이는 동일한 타입의 두 숫자를 받아 그 타입의 숫자를 반환합니다.&nbsp;<span class="fixed">(5













            :: Int) * (6 :: Integer)</span>는 타입 에러를 내는 반면,&nbsp; <span
            class="fixed">5 * (6 :: Integer)</span>는 제대로 동작하여&nbsp; <span
            class="fixed">Integer</span>를 생성하는건,&nbsp; <span class="fixed">5</span>가
          <span class="fixed">Integer</span>나 <span class="fixed">Int</span>처
          럼 행동할 수 있기 때문입니다. </p>
        <p><span class="fixed">Num</span>에 끼기 위해선, 타입은 먼저 <span class="fixed">Show</span>와
          <span class="fixed">Eq</span>랑 친해져야 합니다.</p>
        <p><span class="class label">Integral</span> 또한 숫자형 타입클래스입니다. <span
            class="fixed">Num</span>이 실수를 포함하여 모든 숫자를 포괄하는 반면, <span class="fixed">Integral</span>은
          오직 (모든)정수만을 포함합니다. 이 타입클래스에는 <span class="fixed">Int</span>와
          <span class="fixed">Integer</span>가 있습니다.</p>
        <p><span class="class label">Floating</span>은 오직 부동 소숫점 숫자만
          포함하며, <span class="fixed">Float</span>과 <span class="fixed">Double</span>이
          있습니다.</p>
        <p>숫자를 다루는데 있어 매우 유용한 함수는 <span class="label function">fromIntegral</span>입
          니다. 이는 <span class="fixed">fromIntegral :: (Num b, Integral
            a) =&gt; a -&gt; b</span> 타입 선언을 지녔습니다. 이의 타입서명으로부터 저희는 정수형
          숫자를 받아 더욱 일반적인(general) 숫자로 바꾼다는 것을 확인할 수 있습니다. 이는 정수와 부동 소수의
          타입을 동시에 만족하는 작업을 수행할때 매우 유용합니다. 예를들어, <span class="fixed">length</span>함
          수는 더욱 일반적인 타입 <span class="fixed">(Num b) =&gt; length :: [a]
            -&gt; b</span>을 갖는 대신,&nbsp; <span class="fixed">length ::
            [a] -&gt; Int</span>라는 타입 선언을 지녔습니다. 여기에는 역사적인 이유나 뭔가가 있겠지만,
          제 생각엔 이건 매우 어리석게 보입니다. 어찌됬든Anyway, 리스트의 길이를 얻어 그것에 <span class="fixed">3.2</span>를
          더하려 한다면, <span class="fixed">Int</span>와 부동소숫점 숫자를 더하려 했기에
          에러를 얻게 될 것입니다. 따라서 이걸 피하려면, <span class="fixed">fromIntegral
            (length [1,2,3,4]) + 3.2</span>라고해야 제대로 동작 할 것입니다.</p>
        <p>&nbsp;<span class="fixed">fromIntegral</span>은 이의 타입선언에 여러개의
          클래스 제약을 지니고 있다는 것을 주목하시기 바랍니다. 여러분이 보시는 것처럼, 이는 여전히 유효하며, 괄호
          안의 다수의 클래스 제약들은 쉼표로 분리합니다.</p>
        <div class="footdiv">
          <ul>
            <li style="text-align: left;"> <a href="starting-out" class="prevlink">시
                작</a> </li>
            <li style="text-align: center;"> <a href="chapters">목 차</a>
            </li>
            <li style="text-align: right;"> <a href="syntax-in-functions"
                class="nxtlink">Syntax in Functions</a> </li>
          </ul>
        </div>
      </div>
      <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
      <script type="text/javascript" src="shBrushHaskell.js"></script>
      <script type="text/javascript" src="shBrushPlain.js"></script>
      <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script> </div>
    <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script> </body>
</html>

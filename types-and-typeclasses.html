<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>Learn You a Haskell for Great Good! - Types and Typeclasses</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <base href="http://learnyouahaskell.com/"> <style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style><link rel="shortcut icon" href="favicon.png" type="image/png">
    <link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
    <link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
  </head>
  <body class="introcontent">
    <div class="bgwrapper">
      <div id="content">
        <div class="footdiv" style="margin-bottom:25px;">
          <ul>
            <li style="text-align:left"> <a href="starting-out" class="prevlink">Starting


                Out</a> </li>
            <li style="text-align:center"> <a href="chapters">Table of
                contents</a> </li>
            <li style="text-align:right"> <a href="syntax-in-functions"
                class="nxtlink">Syntax in Functions</a> </li>
          </ul>
        </div>
        <h1>타입과 타입클래스</h1>
        <h1></h1>
        <a name="believe-the-type"></a>
        <h2>타입을 믿으세요</h2>
        <h2></h2>
        <img src="http://s3.amazonaws.com/lyah/cow.png" alt="moo" class="left"
          height="127" width="180">
        <p>전에 제가 하스켈은 정적 타입 시스템을 지녔다고 언급하였습니다. 모든 표현식의 타입은 컴파일 타임에 판명나며,
          이는 보다 안전한 코드로 이끌어 줍니다.&nbsp;부울대수를 숫자로 나누려는 프로그램을 작성한다면, 컴파일이
          되지 않을 것입니다. 이게 좋은게, 나중에 프로그램이 멈추어 버리는 것보다 컴파일 타임에 이러한 종류의 에러를
          잡는 것이 낫기 때문입니다. 하스켈에서 모든것은 타입을 지니므로, 컴파일 하기전 컴파일러는 프로그램에 대해
          상당수를 판별할 수 있습니다.</p>
        <p>Java및 Pascal과는 달리, 하스켈은 <strong>타입추론(type inference)</strong>을
          지녔습니다. 예를들어, 숫자를 썼다면 하스켈에게 숫자라고 말해줄 필요가 없습니다. 스스로 추론할 수 있어,
          명시적으로 함수와 표현식의 타입을 작성할 필요는 없습니다. 저희는 지금까지 하스켈의 타입에 관해 몇몇 기본적이며
          매우 피상적인것을 다루었습니다.&nbsp; 하지만, 타입 시스템의 이해는 하스켈을 배우는 단계에서 가장
          중요합니다.</p>
        <p>타입은 모든 표현식이 갖고있는 이름표입니다. 이는 표현식에 맞는 범주가 어느것인지 알려줍니다. 표현식 <span
            class="fixed">True</span> 는 부울대수이며, <span class="fixed">"hello"</span>는
          문자열, 등등이 있습니다.</p>
        <p>이제 저희는 GHCI를 이용하여 표현식의 타입을 밝혀낼 것입니다. 이를 :t 명령어와 타입을 알려주는 유효한
          표현식을 이용하여 할 수 있습니다. 한번 돌려 봅시다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t 'a'
'a' :: Char
ghci&gt; :t True
True :: Bool
ghci&gt; :t "HELLO!"
"HELLO!" :: [Char]
ghci&gt; :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci&gt; :t 4 == 5
4 == 5 :: Bool
</pre>
        <p> <img src="http://s3.amazonaws.com/lyah/bomb.png" alt="bomb"
            class="right" height="144" width="171"> 여기서 저희는 표현식에 대해
          :t가&nbsp; '표현 식 <span class="fixed">::</span> 타입'을 출력한다는 것을 알
          수 있습니다. <span class="fixed">::</span>를 "타입을 지녔다"라고 읽습니다. 명시적
          타입은 항상 첫번째 문자를 대문자로 표시합니다. <span class="fixed">'a'</span>는
          &nbsp;<span class="fixed">Char</span>타입을 지녔습니다. 문자를 대표한다는 것을
          쉽게 알 수 있습니다. <span class="fixed">True</span>는 <span class="fixed">Bool</span>타
          입 입니다. 뭐 맞는 말입니다. 하지만 이건 무엇일까요? <span class="fixed">"HELLO!"</span>의
          타입이&nbsp;<span class="fixed">[Char]</span>라 는 것을 살펴보시기 바랍니다.
          사각 괄호는 리스트를 나타냅니다. 따라서 저희는 이것을 문자 리스트라 읽을 수 있습니다. 리스트와 달리, 튜플의
          길이 각각은 자신만의 고유한 타입을 지닙니다. 따라서 표현식<span class="fixed">(True,
            'a')</span> 는 타입 <span class="fixed">(Bool, Char)</span> 을
          지니며, 표현식 <span class="fixed">('a','b','c')</span>은 타입<span class="fixed">(Char,

            Char, Char)</span>을 지닐 것입니다. <span class="fixed">4 == 5</span>는
          항상 <span class="fixed">False</span>를 반환하기에, 이것의 타입은 <span class="fixed">Bool</span>입
          니다. </p>
        <p>함수 또한 타입을 갖습니다. 함수를 작성할 때, 명시적 타입 선언을 할 수 있습니다. 매우 짧은 함수를 작성할
          때를 제외하면 이는 보통 괜찮은 행동입니다. 여기선, 저희는 모든 함수에 타입 선언을 할것입니다. 1장에서
          작성한 문자열에서 소문자로된 것을 걸러내는 list comprehension가 기억나십니까? 여기 타입 선언
          하는 법이 나와있습니다: </p>
        <pre name="code" class="haskell: hs">removeNonUppercase :: [Char] -&gt; [Char]
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] 
</pre>
        <p> <span class="fixed">removeNonUppercase</span>는 문자열과 문자열을
          연결한 타입 <span class="fixed">[Char] -&gt; [Char]</span>을 지녔습니다.
          문자열을 인자로 받아 결과로 또다른 문자열을 반환하기 때문입니다. <span class="fixed">[Char]</span>타
          입은 <span class="fixed">String</span>(문자열)과 동의어이므로, <span class="fixed">removeNonUppercase


            :: String -&gt; String</span>라 작성해도 됩니다. 저희가 타입 선언하든 않하든,
          컴파일러 스스로 이 함수가 문자열에서 문자열로 가는걸 알기에, 딱히 타입 선언을 할 필요는 없습니다. 그치만
          여러 인자를 취하는 함수의 타입을 작성하려면 어떻게 해야할까요? 여기 3개의 정수를 받아 더하는, 간단한 함수가
          있습니다: </p>
        <pre name="code" class="haskell: hs">addThree :: Int -&gt; Int -&gt; Int -&gt; Int
addThree x y z = x + y + z
</pre>
        <p>인자는&nbsp; <span class="fixed">-&gt;</span>로 구분되었으며, 인자와 반환
          타입간에 딱히 다른 점은 없습니다. 반환 타입은 선언의 마지막 항목이며, 인자는 처음 3개의 항목입니다. 후에
          <span class="fixed">Int, Int, Int -&gt; Int</span> 처럼 명확하게
          구분하는 대신, 왜 다 <span class="fixed">-&gt;</span>로 분리해 놨는지를 살펴볼
          것입니다. </p>
        <p>함수에 타입 선언을 하고자 하지만, 함수가 무엇을 하는지 확신할 수 없다면, 타입선언이 없는 함수를 작성한
          다음 <span class="fixed">:t</span>로 확인할 수 있습니다. 함수 역시 표현식이므로, <span
            class="fixed">:t</span> 도 문제없이 동작합니다.</p>
        <p>여기 몇몇 common 타입의 개요가 있습니다.</p>
        <p> <span class="label type">Int</span>는 정수를 대변합니다. It's used
          for whole numbers. <span class="fixed">7</span>은<span class="fixed">Int</span>가
          될 수 있지만 <span class="fixed">7.2</span>은 되지 못합니다. <span class="fixed">Int</span>는
          제한되었으며, 이는 최소값과 최대값을 지닌다는 것을 의미합니다. 보통 32비트 머신에서 가능한 <span class="fixed">Int</span>의
          최대값은 2147483647이며 최소값은 -2147483648입니다. </p>
        <p><span class="label type">Integer</span> 또한 정수를 대변합니다. 주된 차이점은
          제한되지 않아, 매우 매우 큰 숫자를 표현하는데 이용할 수 있습니다. 하지만 효율은 <span class="fixed">Int</span>가
          더 좋습니다. </p>
        <pre name="code" class="haskell: hs">factorial :: Integer -&gt; Integer
factorial n = product [1..n]
</pre>
        <pre name="code" class="haskell: ghci">ghci&gt; factorial 50
30414093201713378043612608166064768844377641568960512000000000000
</pre>
        <p><span class="label type">Float</span>는 단일 정밀도를 지닌 부동 소숫점 실수
          입니다.</p>
        <pre name="code" class="haskell: hs">circumference :: Float -&gt; Float
circumference r = 2 * pi * r
</pre>
        <pre name="code" class="haskell: ghci">ghci&gt; circumference 4.0
25.132742
</pre>
        <p><span class="label type">Double</span>는 2배 정밀도를 지닌 부동 소숫점 실수
          입니다!</p>
        <pre name="code" class="haskell: hs">circumference' :: Double -&gt; Double
circumference' r = 2 * pi * r
</pre>
        <pre name="code" class="haskell: ghci">ghci&gt; circumference' 4.0
25.132741228718345
</pre>
        <p> <span class="label type">Bool</span>은 부울대수 타입입니다. 오직 2개의
          값만을 가집니다: <span class="fixed">True</span>와 <span class="fixed">False</span>.
        </p>
        <p> <span class="label type">Char</span>는 문자를 나타냅니다. 이는 따옴표로
          나타냅니다. 문자 리스트는 문자열입니다.</p>
        <p>튜플은 타입이지만, 길이뿐만 아니라 구성물의 타입에도 영향을 받습니다. 따라서, 이론적으로 튜플의 타입은 이
          튜토리얼에서 다루기엔 너무 많은 무수히 많은 갯수를 가집니다, 비어있는 튜플 <span class="label type">()</span>은
          오직 하나 만을 값으로 갖는 타입입니다:&nbsp; <span class="fixed">()</span><span
            class="fixed"></span></p>
        <a name="type-variables"></a>
        <h2>타입 변수<br>
        </h2>
        <p>&nbsp;<span class="fixed">head</span>함수의 타입은 무엇일까요? <span class="fixed">head</span>는
          리스트를 취해 첫번째 원소를 반환하는데, 어떤 타입이 될까요? 확인해 봅시다! </p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t head
head :: [a] -&gt; a
</pre>
        <p> <img src="http://s3.amazonaws.com/lyah/box.png" alt="box" class="left"
            height="93" width="130"> 흠! 이 <span class="fixed">a</span>가
          뭘까요? 타입인가요? 이전에 타입이 대문자로 시작한다는 것을 기억한다면, 이것은 분명 타입이 아닙니다. 대문자로
          시작하지 않기에 이것은 <em>타입 변수</em>입니다. 이는 <span class="fixed">a</span>가
          어떠한 타입이라도 될 수 있다는 것을 의미합니다. 이는 다른 언어에서의 generic과 매우 유사하지만,
          하스켈에선 타입의 행동을 명시하지 않더라도, 쉽게 general한 함수를 작성할 수 있기에 더욱 강력합니다.
          타입 변수를 지닌 함수를 <em>ㄷ다형(polymorphic)함수</em>라 부릅니다. <span class="fixed">head</span>의
          타입 선언은 어떤 타입의 리스트를 받아 그 타입의 원소 하나를 반환한다고 명시되었습니다. </p>
        <p>타입 변수의 이름을 하나 이상의 문자로 구성할 수 있지만, 보통 a, b, c, d ...로 합니다.</p>
        <p>pair에서 첫번째 항목을 반환하는 <span class="fixed">fst</span>를
          기억하십니까?&nbsp; 이것의 타입을 알아 봅시다:</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t fst
fst :: (a, b) -&gt; a
</pre>
        <p>&nbsp; <span class="fixed">fst</span>가 2개의 타입을 지닌 튜플을 받아 첫번째
          항목과 동일한 타입의 원소를 반환하는 것을 확인 할 수 있습니다. 이것이 2개의 타입을 지닌 쌍에 <span
            class="fixed">fst</span>를 사용할 수 있는지에 대한 이유입니다.&nbsp; a와 b의
          타입 변수가 다르기에, 타입이 뒤바뀌지 않는다는 것에 주목하시기 바랍니다. 이는 바로 첫번째 항목의 타입과
          반환되 값의 타입이 동일할 것이라는 것을 의미합니다. </p>
        <a name="typeclasses-101"></a>
        <h2>타입클래스 101</h2>
        <img src="http://s3.amazonaws.com/lyah/classes.png" alt="class"
          class="right" height="158" width="210">
        <p>타입클래스는 몇몇 행동을 정의하는 인터페이스입니다. 타입이 타입 클래스의 인스턴스라는 것은, 타입은 그 타입
          클래스가 기술하는 행동을 지원하며 구현한다는 것을 의미합니다. OOP에서 넘어온 많은 사람들이 객체 지향
          언어에서의 클래스를 생각하기에 타입클래스를 혼란스러워 합니다. 저런, 그건 아닙니다. Java의 인터페이스라
          생각하는게 낫을 것입니다. </p>
        <p>&nbsp;<span class="fixed">==</span>함수의 타입서명은 무엇일까요?</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t (==)
(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool
</pre>
        <div class="hintbox"><em>Note</em>: 등위 연산자 <span class="fixed">==</span>
          은 함수입니다.&nbsp; <span class="fixed">+</span>, <span class="fixed">*</span>,
          <span class="fixed">-</span>, <span class="fixed">/</span>와
          다른 수 많은 연산자들도 그러합니다. 함수가 특별한 문자로만 구성되어 있으면, 기본적으로 중위함수라 여겨집니다.
          타입이 먼지 확인하려면, 다른 함수에 넣어 보거나, 괄호로 둘러싸 전위함수로 호출 해야 합니다.</div>
        <p>흥미롭군요. 저희는 여기서 새로운&nbsp;<span class="fixed">=&gt;</span>심볼을
          발견하였습니다. <span class="fixed">=&gt;</span> 심볼 이전의 것을 <em>클래스
            제약(class constraint)</em>이라 합니다. 타입 선언을 다음과 같이 읽을 수 있습니다:
          "등위함수는 동일한 타입의 두 값을 취해 <span class="fixed">Bool</span>을 반환한다.
          그 타입은 클래스 제약에 의해 <span class="fixed">Eq</span>클래스의 멤버여야 한다".</p>
        <p><span class="fixed">Eq</span> 타입클래스는 동일성을 판별하기 위한 인터페이스를
          제공합니다.&nbsp; 특정 타입에 두 항목의 같음을 비교할 수 있으면, 그 타입은 <span class="fixed">Eq</span>
          클래스의 멤버가 될 수 있습니다. 입력과 출력을 담당하는 타입을 제외하면, 표준 하스켈의 모든 타입들은 <span
            class="fixed">Eq</span> 타입클래스의 한 부분입니다.</p>
        <p><span class="fixed">elem</span> 함수는 리스트 내부에 있는 값을 찾기위해 <span
            class="fixed">==</span> 를 이용하므로 <span class="fixed">(Eq a)
            =&gt; a -&gt; [a] -&gt; Bool</span> 타입을 지닙니다.</p>
        <p>몇몇 기본 타입클래스들:</p>
        <p><span class="label class">Eq</span>는 동등성을 검사를 지원하는 타입에 이용됩니다.
          이의 맴버 구현 함수는 <span class="fixed">==</span>와 <span class="fixed">/=</span>입
          니다. 함수에 타입 변수에 대한 <span class="fixed">Eq</span> 클래스 제약이
          있다면,&nbsp; 이 내부 정의 어딘가에는 <span class="fixed">==</span>나 <span
            class="fixed">/=</span>을 사용할 것입니다. 함수를 제외한 이전에 저희가 언급한 모든
          타입들은 <span class="fixed">Eq</span>의 한 부분이므로, 이것들로부터 동등성을 검사할
          수 있습니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; 5 == 5
True
ghci&gt; 5 /= 5
False
ghci&gt; 'a' == 'a'
True
ghci&gt; "Ho Ho" == "Ho Ho"
True
ghci&gt; 3.432 == 3.432
True
</pre>
        <p> <span class="label class">Ord</span>는 순서를 가진 타입입니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t (&gt;)
(&gt;) :: (Ord a) =&gt; a -&gt; a -&gt; Bool
</pre>
        <p> 함수를 제외한, 저희가 다루는 모든 타입들은 <span class="fixed">Ord</span>의 한
          부분입니다. <span class="fixed">Ord</span>는 <span class="fixed">&gt;</span>,
          <span class="fixed">&lt;</span>, <span class="fixed">&gt;=</span>,
          <span class="fixed">&lt;=</span>와 같은 표준 비교 함수들을 모두 다룹니다. <span
            class="fixed">compare</span> 함수는 동일한 타입의 두 <span class="fixed">Ord</span>멤
          버를 받아 순서(ordering)를 반환합니다. <span class="label type">Ordering</span>은
          각각 보다 큰(greater than), 보다 작은(lesser than), 같음(equal)을 나타내는 <span
            class="fixed">GT</span>, <span class="fixed">LT</span>, <span
            class="fixed">EQ</span>가 될 수 있는 타입입니다. </p>
        <p>&nbsp;<span class="fixed">Ord</span>맴버가 되기 위해선, 우선 명문 <span
            class="fixed">Eq</span>클럽의 회원이 되어야만 합니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; "Abrakadabra" &lt; "Zebra"
True
ghci&gt; "Abrakadabra" `compare` "Zebra"
LT
ghci&gt; 5 &gt;= 2
True
ghci&gt; 5 `compare` 3
GT
</pre>
        <p>&nbsp;<span class="label class">Show</span>의 맴버는 문자열로 나타낼 수
          있습니다. 함수를 제외한, 지금까지 다룬 모든 타입들은 <span class="fixed">Show</span>의
          한 부분입니다. The most used function that deals with the <span class="fixed">Show</span>타
          입클래스를 다루는데 가장 많이 사용하는 함수는 <span class="fixed">show</span>입니다.
          이는 <span class="fixed">Show</span>타입의 맴버인 값을 취해 문자열로 표시합니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; show 3
"3"
ghci&gt; show 5.334
"5.334"
ghci&gt; show True
"True"
</pre>
        <p><span class="label class">Read</span>는 <span class="fixed">Show</span>타
          입클래스와는 반대입니다. <span class="fixed">read</span>함수는 문자열을 취해 <span
            class="fixed">Read</span>맴버인 타입을 반환합니다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; read "True" || False
True
ghci&gt; read "8.2" + 3.8
12.0
ghci&gt; read "5" - 2
3
ghci&gt; read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
</pre>
        <p>머 괜찮게 나왔습니다. 지금까지 다룬 모든 타입들 또한&nbsp; 이 타입클래스안에 있습니다. 그러면 <span
            class="fixed">read "4"</span>라 입력하면 어떻게 될까요?</p>
        <pre name="code" class="haskell: ghci">ghci&gt; read "4"
&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraint:
      `Read a' arising from a use of `read' at &lt;interactive&gt;:1:0-7
    Probable fix: add a type signature that fixes these type variable(s)
</pre>
        <p>여기서 GHCI가 저희에게 말하는 것은 뭘 반환해야 하는지 모르겠다는 것입니다.&nbsp; 이전 read의
          사용에서 결과에 무언가를 한 것에 주목하시기 바랍니다. 이러한 방법으로, GHCI는 <span class="fixed">read</span>에
          서 얻고자 하는 것을 추론할 수 있었습니다. 예를들어, 저희가 부울대수로 이용하였다면, <span class="fixed">Bool</span>을
          반환할 것입니다. 그러나 지금, <span class="fixed">Read</span>클래스의 어떠한 타입을
          원하지만, 그 어떠한 것이 무엇인지를 모릅니다. <span class="fixed">read</span>의
          타입 서명을 살펴봅시다.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t read
read :: (Read a) =&gt; String -&gt; a
</pre>
        <p> 보이십니까? <span class="fixed">Read</span> 타입을 반환하였지만, 만약 저희가
          다른 방법을 이용한다면, 어떤 타입인지 알 수 없을 것입니다. 이것이 바로 <em>타입 어노테이션(type
            annotations)</em>을 사용해야 하는 이유입니다. 타입 어노테이션은 표현식의 타입이 무엇인지
          명시적으로 알려주는 하나의 방법입니다. 표현식 끝에&nbsp; <span class="fixed">::</span>을
          추가하고 타입을 명시함으로써 이를 행할 수 있습니다. 살펴봅시다: </p>
        <pre name="code" class="haskell: ghci">ghci&gt; read "5" :: Int
5
ghci&gt; read "5" :: Float
5.0
ghci&gt; (read "5" :: Float) * 4
20.0
ghci&gt; read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci&gt; read "(3, 'a')" :: (Int, Char)
(3, 'a')
</pre>
        <p>Most expressions are such that the compiler can infer what
          their type is by itself. But sometimes, the compiler doesn't
          know whether to return a value of type <span class="fixed">Int</span>
          or <span class="fixed">Float</span> for an expression like <span
            class="fixed">read "5"</span>. To see what the type is,
          Haskell would have to actually evaluate <span class="fixed">read


            "5"</span>. But since Haskell is a statically typed
          language, it has to know all the types before the code is
          compiled (or in the case of GHCI, evaluated). So we have to
          tell Haskell: "Hey, this expression should have this type, in
          case you don't know!".</p>
        <p><span class="label class">Enum</span> members are
          sequentially ordered types — they can be enumerated. The main
          advantage of the <span class="fixed">Enum</span> typeclass is
          that we can use its types in list ranges. They also have
          defined successors and predecesors, which you can get with the
          <span class="fixed">succ</span> and <span class="fixed">pred</span>
          functions. Types in this class: <span class="fixed">()</span>,
          <span class="fixed">Bool</span>, <span class="fixed">Char</span>,
          <span class="fixed">Ordering</span>, <span class="fixed">Int</span>,
          <span class="fixed">Integer</span>, <span class="fixed">Float</span>
          and <span class="fixed">Double</span>.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; ['a'..'e']
"abcde"
ghci&gt; [LT .. GT]
[LT,EQ,GT]
ghci&gt; [3 .. 5]
[3,4,5]
ghci&gt; succ 'B'
'C'
</pre>
        <p><span class="label class">Bounded</span> members have an
          upper and a lower bound.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; minBound :: Int
-2147483648
ghci&gt; maxBound :: Char
'\1114111'
ghci&gt; maxBound :: Bool
True
ghci&gt; minBound :: Bool
False
</pre>
        <p><span class="fixed">minBound</span> and <span class="fixed">maxBound</span>
          are interesting because they have a type of <span class="fixed">(Bounded


            a) =&gt; a</span>. In a sense they are polymorphic
          constants.</p>
        <p>All tuples are also part of <span class="fixed">Bounded</span>
          if the components are also in it.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
</pre>
        <p><span class="label class">Num</span> is a numeric typeclass.
          Its members have the property of being able to act like
          numbers. Let's examine the type of a number.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t 20
20 :: (Num t) =&gt; t
</pre>
        <p>It appears that whole numbers are also polymorphic constants.
          They can act like any type that's a member of the <span class="fixed">Num</span>
          typeclass.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; 20 :: Int
20
ghci&gt; 20 :: Integer
20
ghci&gt; 20 :: Float
20.0
ghci&gt; 20 :: Double
20.0
</pre>
        <p>Those are types that are in the <span class="fixed">Num</span>
          typeclass. If we examine the type of <span class="fixed">*</span>,
          we'll see that it accepts all numbers.</p>
        <pre name="code" class="haskell: ghci">ghci&gt; :t (*)
(*) :: (Num a) =&gt; a -&gt; a -&gt; a
</pre>
        <p> It takes two numbers of the same type and returns a number
          of that type. That's why <span class="fixed">(5 :: Int) * (6
            :: Integer)</span> will result in a type error whereas <span
            class="fixed">5 * (6 :: Integer)</span> will work just fine
          and produce an <span class="fixed">Integer</span> because <span
            class="fixed">5</span> can act like an <span class="fixed">Integer</span>
          or an <span class="fixed">Int</span>. </p>
        <p>To join <span class="fixed">Num</span>, a type must already
          be friends with <span class="fixed">Show</span> and <span class="fixed">Eq</span>.</p>
        <p><span class="class label">Integral</span> is also a numeric
          typeclass. <span class="fixed">Num</span> includes all
          numbers, including real numbers and integral numbers, <span class="fixed">Integral</span>
          includes only integral (whole) numbers. In this typeclass are
          <span class="fixed">Int</span> and <span class="fixed">Integer</span>.</p>
        <p><span class="class label">Floating</span> includes only
          floating point numbers, so <span class="fixed">Float</span>
          and <span class="fixed">Double</span>.</p>
        <p>A very useful function for dealing with numbers is <span class="label function">fromIntegral</span>.
          It has a type declaration of <span class="fixed">fromIntegral
            :: (Num b, Integral a) =&gt; a -&gt; b</span>. From its type
          signature we see that it takes an integral number and turns it
          into a more general number. That's useful when you want
          integral and floating point types to work together nicely. For
          instance, the <span class="fixed">length</span> function has
          a type declaration of <span class="fixed">length :: [a] -&gt;
            Int</span> instead of having a more general type of <span class="fixed">(Num


            b) =&gt; length :: [a] -&gt; b</span>. I think that's there
          for historical reasons or something, although in my opinion,
          it's pretty stupid. Anyway, if we try to get a length of a
          list and then add it to <span class="fixed">3.2</span>, we'll
          get an error because we tried to add together an <span class="fixed">Int</span>
          and a floating point number. So to get around this, we do <span
            class="fixed">fromIntegral (length [1,2,3,4]) + 3.2</span>
          and it all works out.</p>
        <p>Notice that <span class="fixed">fromIntegral</span> has
          several class constraints in its type signature. That's
          completely valid and as you can see, the class constraints are
          separated by commas inside the parentheses.</p>
        <div class="footdiv">
          <ul>
            <li style="text-align:left"> <a href="starting-out" class="prevlink">Starting


                Out</a> </li>
            <li style="text-align:center"> <a href="chapters">Table of
                contents</a> </li>
            <li style="text-align:right"> <a href="syntax-in-functions"
                class="nxtlink">Syntax in Functions</a> </li>
          </ul>
        </div>
      </div>
      <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
      <script type="text/javascript" src="shBrushHaskell.js"></script>
      <script type="text/javascript" src="shBrushPlain.js"></script>
      <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script> </div>
    <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script> </body>
</html>

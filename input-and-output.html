<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>Learn You a Haskell for Great Good! - Input and Output</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <base href="http://learnyouahaskell.com/">
    <style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style><link rel="shortcut icon" href="favicon.png" type="image/png">
    <link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
    <link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
  </head>
  <body class="introcontent">
    <div class="bgwrapper">
      <div id="content">
        <div class="footdiv" style="margin-bottom:25px;">
          <ul>
            <li style="text-align:left"> <a href="making-our-own-types-and-typeclasses"
                class="prevlink">Making Our Own Types and Typeclasses</a> </li>
            <li style="text-align:center"> <a href="chapters">목차</a> </li>
            <li style="text-align:right"> <a href="functionally-solving-problems"
                class="nxtlink">Functionally Solving Problems</a> </li>
          </ul>
        </div>
        <h1>입력과 출력<br>
        </h1>
        <img src="http://s3.amazonaws.com/lyah/dognap.png" alt="poor dog" class="right"
          height="382" width="261">
        <p>전에 제가 하스켈은 순수한 함수형 언어라고 했습니다. imperative 언어에선 컴퓨터에게 실행 단계를 나열하여 일을
          처리하지만, 함수형 프로그래밍에서는 어떠한 것을 정의하는 것에 더욱 중점을 줍니다. 하스켈에서 함수는 변수의 내용을 바꾸는
          것과 같이 어떠한 상태를 변화시키지 않습니다 (상태를 변화시키는 함수를 가리켜, 부수효과(<i>side-effects)</i>를
          지녔다고 합니다). 하스켈에서 함수가 하는 일은 인자에 기반하여 어떠한 결과를 돌려주는 것입니다. 동일한 인자로 함수가 여러번
          호출된다면, 동일한 결과를 반환해야만 합니다. imperative세계에서 온 여러분은 이를 조금 밖에 맛보진 못했지만, 이것이
          실제로 매우 멋지다는 것을 보았습니다. imperative 언어에서는, 어떠한 숫자를 처리하는 간단한 함수가 집을 태우거나,
          소중한 개를 납치하거나, 감자에 차가 흠집을 내지 않다라는것을 보장할 수 없습니다. 예를들어, 이진 탐색 트리를 만들려면, 그
          장소에서 바로 트리를 수정하여 원소를 삽입해서는 안됩니다. 이전것을 바꿔서는 안되기에, 이진 탐색 트리에 삽입하는 함수는
          새로운 트리를 반환합니다.</p>
        <p> 상태를 변화시키지 않는 함수가 프로그램을 분석하는데 있어 도움이 되지만, 문제가 하나 있습니다. 이 세계에서 함수가 어떠한
          것도 변화시키지 않는다면, 계산된 것을 어떻게 알려줄까요? 계산된 것을 알려주기 위해선, 출력 장치의 상태를 변화시켜(보통
          화면의 상태), 저희 머리속을 돌아 다니게될 광자를 배출해, 우리 사람의 생각을 변화시켜야 합니다.</p>
        <p>저희가 배운게 부질없는일이 아니니, 실망하지 마시기 바랍니다. 하스켈은 프로그램을 순수한 부분과 키보드나 화면을 다루는
          지저분한 부분으로 깔끔하게 나눔으로써, 부수효과를 지닌 함수를 다루는데 있어 아주 영리한 시스템을 지녔습니다. 이렇게 두
          부분으로 나눔으로써, 순수한 프로그램에 대해 사고할 수 있고, 외부 세계와 효율적으로 소통하면서 laziness,
          robustness, modularity와 같은 순수함이 제공해주는 이점들을 취할 수 있습니다.</p>
        <a name="hello-world"></a>
        <h2>Hello, world!</h2>
        <img src="http://s3.amazonaws.com/lyah/helloworld.png" alt="HELLO!" class="left"
          height="179" width="223">
        <p>지금까지, 저희는 항상 GHCI에서 함수를 로드하여 테스트하였습니다. 또한 이러한 방식으로 표준 라이브러리 함수를
          살펴보았습니다. 하지만 지금, 8장 혹은 나머지 장부터는 <i>진짜</i> 하스켈 프로그램을 작성해 나갈 것입니다. 예! 두
          말할것도 없이, 오래된 친구 <span class="fixed">"hello, world"</span>부터 시작할 것입니다.</p>
        <div class="hintbox"><em>잠시만요!</em> 이번 장에선, 하스켈을 배우기 위해 유닉스 환경을 사용한다고
          가정할 것입니다. 윈도우 환경이라면, 리눅스와 유사한 환경을 제공해주는 <a href="http://www.cygwin.com/">Cygwin</a>을
          다운받는 것을 추천합니다.</div>
        <p>그럼 시작에 앞서, 다음 문장을 여러분이 선호하는 문서 편집기에 입력하시기 바랍니다:</p>
        <pre name="code" class="haskell:hs">main = putStrLn "hello, world"
</pre>
        <p><span class="fixed">main</span>이란 이름을 정의하였고, 내부에선 <span class="fixed">"hello,
            world"</span>를 인자로 갖는 <span class="fixed">putStrLn</span>를 호출하였습니다.
          지극히 평범해 보이지만, 잠시후 보게될 것처럼 사실 간단하지 않습니다. 이를 <span class="fixed">helloworld.hs</span>파
          일로 저장합시다.</p>
        <p>지금부터, 이제까지 해보지 못한 무언가를 해보겠습니다. 프로그램을 실제로 컴파일 해볼 것입니다! 터미널을 여시고, <span
            class="fixed">helloworld.hs</span>가 있는 폴더에 가서 다음을 실행합니다:</p>
        <pre name="code" class="plain">$ ghc --make helloworld
[1 of 1] Compiling Main             ( helloworld.hs, helloworld.o )
Linking helloworld ...
</pre>
        <p>좋습니다! 이와 같은 결과를 얻었다면, 한번 <span class="fixed">./helloworld</span>로
          프로그램을 돌려 봅시다.</p>
        <pre name="code" class="haskell:hs">$ ./helloworld
hello, world
</pre>
        <p>성공적으로, 터미널에 무언가를 출력하는 프로그램을 컴파일 하였습니다. 뭐 별로 특별한 것이 없습니다.</p>
        <p>작성한 것을 한번 분석해 봅시다. 우선, <span class="fixed">putStrLn</span>함수의 타입을
          살펴봅시다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; :t putStrLn
putStrLn :: String -&gt; IO ()
ghci&gt; :t putStrLn "hello, world"
putStrLn "hello, world" :: IO ()
</pre>
        <p><span class="fixed">putStrLn</span>타입을 다음과 같이 읽을 수 있습니다: <span class="fixed">putStrLn</span>은
          문자열을 받아 <span class="fixed">()</span>의 결과 타입(즉, unit으로 알려진 비어있는 튜플)을
          갖는 <em>I/O action</em>을 반환한다. I/O action은 매 수행마다, 부수효과를 가져다주며(이는 보통
          입력으로부터 무언가를 읽거나, 화면상에 무언가를 출력하는 것입니다.) 반환값을 내부에 저장합니다. 문자열을 터미널에 출력하는데
          있어 값을 반환하는 것은 별로 중요치 않기에, 더미 값인 <span class="fixed">()</span>을 이용합니다.</p>
        <div class="hintbox">비어있는 튜플의 값은 <span class="fixed">()</span>이며, 타입 또한
          <span class="fixed">()</span>입니다.</div>
        <p>그러면, I/O action은 언제 수행될까요? 음, 이는 <span class="fixed">main</span>에 왔을
          때입니다. I/O action은 <span class="fixed">main</span>이란 이름을 주고 프로그램을 돌렸을때
          수행됩니다.</p>
        <p>하나의 I/O action만을 갖는 프로그램은 제한되어 보입니다. 따라서 여러 I/O action들을 하나로 묶기 위해선 <i>do</i>
          문법을 이용해야 합니다. 다음 예제를 살펴봅시다:</p>
        <pre name="code" class="haskell:hs">main = do
    putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
</pre>
        <p>아, 흥미롭군요. 새로운 문법입니다! 그리고 이는 마치 imperative프로그램처럼 읽힙니다. 이를 컴파일 하고 돌려보면,
          아마 예상했던대로 수행할 것입니다. <i>do</i>라고 한 다음, imperative 프로그램처럼 여러 단계를 나열한 것에
          주목하시기 바랍니다. 이 각각의 단계가 I/O action입니다. 이를 do문법에 넣음으로써, 하나의 I/O action으로
          묶었습니다. 내부 마지막 타입이 I/O action타입이기에, 저희가 얻게되는 action은 <span class="fixed">IO
            ()</span>타입을 가졌습니다.</p>
        <p>이러한 이유로, <span class="fixed"><i>something</i></span>을 어떠한 구체적인 타입이라고
          한다면, <span class="fixed">main</span>은 항상 <span class="fixed">main ::
            IO <i>something</i></span>타입서명을 지녔습니다. 관례에 따라, 저희는 <span class="fixed">main</span>의
          타입 선언을 명시하지 않을 것입니다.</p>
        <p> 저희가 이제까지 만나보지 못한 흥미로운 것은 세번째 줄 <span class="fixed">name &lt;-
            getLine</span>입니다. 이는 입력장치에서 한 줄을 읽어, <span class="fixed">name</span>이
          란 변수에 저장하는 것처럼 보입니다. 실제로 그러할까요? 흠, <span class="fixed">getLine</span>의
          타입을 살펴봅시다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; :t getLine
getLine :: IO String
</pre> <img src="http://s3.amazonaws.com/lyah/luggage.png" alt="luggage" class="left"
          height="200" width="204">
        <p>아하, 알겠습니다. <span class="fixed">getLine</span>은 <span class="fixed">String</span>을
          결과 타입으로 갖는 I/O action입니다. 터미널에서 사용자로부터 무언가를 입력받기위해 기다려야 하며, 후에 그 무언가를
          문자열로 출력하기 때문입니다. 그럼, <span class="fixed">name &lt;- getLine</span>가
          하는 일은 도대체 무엇일까요? 다음과 같이 생각할 수 있겠습니다: <em>I/O action <span class="fixed">getLine</span>을
            수행하고, 결과 값을 </em><em><span class="fixed">name</span></em><em>에 넣어라</em>.
          <span class="fixed">getLine</span>은&nbsp; <span class="fixed">IO
            String</span>타입을 지녔으므로, <span class="fixed">name</span>은 <span class="fixed">String</span>타
          입을 지닐 것입니다. I/O action을, 실제 세계로 나가 (벽에 낙서를 한다던가와 같은)무언가를 한뒤에, 데이터를 가지고
          오는 작은 발들이 달린 상자라 할 수 있겠습니다. 만약 이것이 데이터를 가져왔다면, 상자를 열어 내부에 있는 데이터를 가져올
          수 있는 유일한 방법은 <span class="fixed">&lt;-</span>구조를 이용하는 것입니다. I/O
          action에서 데이터를 꺼내려면, 또 다른 I/O action 안에서 데이터를 가져와야 합니다. 이것이 바로 하스켈이 코드를
          순수한 부분과 지저분한 부분으로 나눠 관리하는 방식입니다. <span class="fixed">getLine</span>은
          매 수행마다 동일한 결과 값을 보장하지 않기에, 어떤 의미에선 지저분합니다. 이것이 바로 I/O 코드에서, 데이터를 얻어오기
          위해 <i>지저분한</i> <span class="fixed">IO</span>타입 구조자(constructor)가
          존재하는 이유입니다. I/O코드 역시 더럽고, 더러운 I/O데이터에 의존하는 계산은 더러운 결과를 가져오게될 것이기
          때문입니다.</p>
        <p>제가 <i>더럽다</i>라고 말한 것은, I/O action이 수반한 결과를 순수한 코드에서 결코 다시 사용하지 않는다는
          것을 의미하는 것은 아닙니다. 네, I/O action을 name에 bind하면 내부에 있는 데이터를 잠시나마 <i>더럽히지
            않을 것입니다</i>. <span class="fixed">name &lt;- getLine</span>라 하면, <span
            class="fixed">name</span>은 상자 내부에 있는 것을 나타내기에 평범한 문자열이 될 것입니다.
          이름(평범한 문자열)을 인자로 받아, 이름으로 미래를 말해주는 매우 복잡한 함수를 만들 수도 있습니다. 이렇게 할 수
          있습니다:</p>
        <pre name="code" class="haskell:hs">main = do
    putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn $ "Read this carefully, because this is your future: " ++ tellFortune name
</pre>
        <p><span class="fixed">tellFortune</span>은 (혹은 <span class="fixed">name</span>을
          넘겨받는 어떠한 함수라도) I/O에 관한 어떠한 것도 알지못하는, 단순히 평범한 <span class="fixed">String
            -&gt; String</span> 함수입니다!</p>
        <p>코드를 살펴봅시다. 이게 과연 유효한 것일까요?</p>
        <pre name="code" class="haskell:hs">nameTag = "Hello, my name is " ++ getLine
</pre>
        <p>그렇지 않다고 답한 당신, 과자를 드세요. 그렇다고 답한 당신, 철철 흐르는 용암 한사발을 들이키세요. 농담이고, 절대 하지
          않습니다! 동작하지 않는 이유는 <span class="fixed">++</span>는 동일한 타입의 리스트를 인자로
          요구하기 때문입니다. 좌측 인자의 타입은 <span class="fixed">String</span> (혹은 <span class="fixed">[Char]</span>)
          인 반면, <span class="fixed">getLine</span>은 <span class="fixed">IO
            String</span>타입을 갖습니다. 문자열과 I/O action을 연결(concatenate)할 순 없습니다. <span
            class="fixed">String</span>타입의 값을 얻기위해 I/O action의 결과를 얻어와야만 하며, 이를
          행할 유일한 방법은 또 다른 I/O action내부에서 <span class="fixed">name &lt;- getLine</span>와
          같은 무언가를 행하는 것입니다.. 지저분한 데이터를 다루어야 한다면, 지저분한 환경에서 이를 처리해야 합니다. 이러한 불순하고
          더러움이 마치 죽음의 질병처럼 퍼져있으며, 저희의 주된 관심사는 코드의 I/O 부분을 가능한 작게 유지하는 것입니다.<br>
        </p>
        <p>수행된 모든 I/O aciton은 내부에 결과를 담고 있습니다. 그러므로 이전 예제 프로그램이 다음과 같이 쓰여질 수
          있습니다:</p>
        <pre name="code" class="haskell:hs">main = do
    foo &lt;- putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
</pre>
        <p><span class="fixed">foo</span>는 <span class="fixed">()</span>를 값으로
          가질 것이므로 고려대상이 아닙니다. 마지막 <span class="fixed">putStrLn</span>이 다른것과 엮이지
          않은 것을 주목하시기 바랍니다. 이는 <i>do</i>블록 내부에선, 처음 2개와 달리<span style="font-weight: bold;">
          </span><em>마지막 action은 name과 엮여서는 안되기</em> 때문입니다. 정확히 왜 이러한 지에 대해서는,
          조금 뒤인 모나드 세계를 경험할때 살펴보도록 하겠습니다. 지금은, <i>do</i>블록은 '자동적으로 마지막 action에서
          값을 추출하여, 결과로 내보낸다' 라고 생각하시면 됩니다.</p>
        <p>마지막 줄을 제외하고, <i>do</i> 블록내에 있는 bind되지 않은 모든 줄은 bind를 써서 작성할 수 도
          있습니다. 따라서 <span class="fixed">putStrLn "BLAH"</span>을 <span class="fixed">_
            &lt;- putStrLn "BLAH"</span>로 바꿔쓸 수 있습니다. 하지만 이는 별로 쓸모없으므로, <span class="fixed">putStrLn
            <i>something</i></span>와 같이 별로 중요하지 않는 결과를 지닌 I/O action에 대해서는 <span
            class="fixed">&lt;-</span>을 뺄 것입니다.</p>
        <p>초보자들은 종종 이렇게 생각하기도 합니다.</p>
        <pre name="code" class="haskell:hs">name = getLine
</pre>
        <p>입력에서 읽어서, <span class="fixed">name</span>에 값을 bind해라. 흠, 그렇지 않습니다.
          이것이 행하는 일은 <span class="fixed">getLine</span> I/O action에게 <span class="fixed">name</span>라
          불리는 다른 이름을 붙여준 것입니다. I/O action에서 값을 얻어오려면, <span class="fixed">&lt;-</span>로
          이름(name)과 엮어 또 다른 I/O action 내부에서 수행해야 한다는 것을 기억하시기 바랍니다.</p>
        <p>I/O action은 <span class="fixed">main</span>이란 이름이 주어지거나, <i>do</i>블
          록으로 구성된 커다란 I/O action내부에 있을때만 수행됩니다. 또한 <i>do</i>블록을 이용하여 여러 I/O
          action들을 서로 묶을 <i></i>수 있으며, 이러한 I/O action을 또 다른 I/O action에서 이용할 수
          있습니다. 어찌됐던 간에, 최종적으로 <span class="fixed">main</span>에 도달해서야 수행됩니다.</p>
        <p>아, 맞습니다. I/O action이 수행되는 몇가지 경우의 수가 있습니다. GHCI에서 I/O action을 입력하고
          엔터를 누르면 수행됩니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; putStrLn "HEEY"
HEEY
</pre>
        <p>GHCI에서 함수를 호출하거나 숫자를 때려넣어 엔터를 누르면, 필요한 만큼 평가를 한다음 <span class="fixed">show</span>를
          호출하여, <span class="fixed">putStrLn</span>구현을 이용하여 터미널에 문자열을 출력할 것입니다.</p>
        <p><i>let</i> bindings이 기억나십니까? 그렇지 않다면, <a href="syntax-in-functions#let-it-be">이
            장</a>을 읽어 기억을 상기시켜 보시기 바랍니다. let binding은 <span class="fixed">let <i>bindings</i>
            in <i>expression</i></span>형태를 띄는데, <span class="fixed"><i>bindings</i></span>은
          표현식에 사용되는 이름들이며, <span class="fixed"><i>expression</i></span>은 평가되는
          표현식입니다. 또한 이를 <i>in</i>부분이 필요치 않는 list comprehensions로 나타낼 수 있었습니다.
          그리고, list comprehensions에서 이용했던 것 처럼 <i>do</i> 블록 내에서 이용할 수 도 있습니다.
          확인해봅시다:</p>
        <pre name="code" class="haskell:hs">import Data.Char

main = do
    putStrLn "What's your first name?"
    firstName &lt;- getLine
    putStrLn "What's your last name?"
    lastName &lt;- getLine
    let bigFirstName = map toUpper firstName
        bigLastName = map toUpper lastName
    putStrLn $ "hey " ++ bigFirstName ++ " " ++ bigLastName ++ ", how are you?"
</pre>
        <p><i>do</i>블록에 줄줄이 있는 I/O action들이 보이십니까? 또 I/O action들과 <i>let</i>이,
          그리고 <i>let</i>의 이름끼리 서로 줄맞춤을 한 것을 눈치채셨습니까? 이는 하스켈의 줄맞춤의 중요성을 보여주는 훌륭한
          예제입니다. 여기서, <span class="fixed">"John"</span>를 더욱 멋진 <span class="fixed">"JOHN"</span>와
          같이 더욱 멋진 문자열로 바꾸는 <span class="fixed">map toUpper firstName</span>를
          수행하였습니다. 대문자로된 문자열을 name으로 bind하여, 나중에 이를 터미널에 출력할때 사용하였습니다.</p>
        <p>여러분들이 아마 언제 <span class="fixed">&lt;-</span>를 사용하고 언제 <i>let</i>
          bindings을 사용하는지를 혼란스러워 하실지도 모르겠습니다. 그렇다면, 당장은 <span class="fixed">&lt;-</span>은
          I/O actions을 수행하고 그 결과를 name에 bind하기 위한 것이라고 기억하시기 바랍니다. 하지만, <span class="fixed">map
            toUpper firstName</span>은 I/O action이 아닙니다. 이는 하스켈에서 순수한 표현식입니다.
          따라서&nbsp; I/O action의 결과를 name에 bind하고자 할때 <span class="fixed">&lt;-</span>를
          사용하시고, 순수한 표현식을 name에 bind하고자 할때는 <i>let</i> bindings을 사용하시기 바랍니다. <span
            class="fixed">let firstName = getLine</span>이라 한다면, <span class="fixed">getLine</span>
          I/O action을 다른 이름으로 부를 수 있으며, 또한 여전히 <span class="fixed">&lt;-</span>를
          통해서도 이를 행할 수 있습니다.</p>
        <p>이제 계속하여 줄을 읽고, 동일한 줄에 단어를 뒤집어서 출력하는 프로그램을 만들어 봅시다. 비어있는 줄을 입력할때 프로그램의
          실행은 멈추게 됩니다. 여기 프로그램이 있습니다:</p>
        <pre name="code" class="haskell:hs">main = do 
    line &lt;- getLine
    if null line
        then return ()
        else do
            putStrLn $ reverseWords line
            main

reverseWords :: String -&gt; String
reverseWords = unwords . map reverse . words
</pre>
        <p>코드를 살펴보기 전에,&nbsp; 이를 먼저 돌려봐서 어떠한 일을 행하는지 느껴보도록 합시다.</p>
        <div class="hintbox"><em>전문가의 조언</em>: <span class="fixed">ghc --make
            helloworld</span>로 컴파일을 하여 <span class="fixed">./helloworld</span>로
          실행파일을 실행하거나, <span class="fixed">runhaskell helloworld.hs</span>와 같이
          <span class="fixed">runhaskell</span>명령어를 이용하여 프로그램을 돌려볼 수 있습니다.</div>
        <p>우선, <span class="fixed">reverseWords</span>함수를 살펴봅시다. 이는 평범한 함수인데,
          우선 <span class="fixed">"hey there man"</span>와 같은 문자열을 받아 <span class="fixed">words</span>를
          호출하여 <span class="fixed">["hey","there","man"]</span>와 같은 단어 리스트를
          만듭니다. 다음으로 <span class="fixed">reverse</span>를 그 리스트에 map하여 <span class="fixed">["yeh","ereht","nam"]</span>을
          얻은다음, <span class="fixed">unwords</span>을 이용하여 하나의 문자열을 돌려줌으로, 최종 결과는
          <span class="fixed">"yeh ereht nam"</span>가 됩니다. 함수 composition을 어떻게
          사용핬는지 잘 살펴보시기 바랍니다. 함수 composition이 없다면, <span class="fixed">reverseWords
            st = unwords (map reverse (words st))</span>라고 작성해야만 합니다.</p>
        <p><span class="fixed">main</span>은 어떨까요? 우선, <span class="fixed">getLine</span>을
          호출하여 터미널에서 <span class="fixed">line</span>을 받습니다. 그리고 하스켈에선, 모든 표현식은
          값을 지녀야 하므로, <i>if</i>와 <i>else</i>이 대응된다는 것을 명심하시기 바랍니다. <i>if</i>는
          조건이 참일때 I/O action을 수행하고, 그렇지 않을때에는<span style="font-style: italic;">
          </span><i>else</i>아래에 있는 I/O action이 수행됩니다. 이것이 바로 왜 I/O <i>do</i>블
          록안에 <i>if</i>가&nbsp; <span class="fixed">if <i>condition</i> then <i>I/O
              action</i> else <i>I/O action</i></span>라는 형태를 띄어야 하는지에 대한 이유입니다.</p>
        <p>우선 <i>else</i>절 아레서 무슨 일이 일어나는지 살펴보도록 하겠습니다. <i>else </i>다음에는 정확히
          하나의 I/O action만을 지녀야하기에, <i>do</i>블록을 이용하여 두 I/O action을 하나로 만들었습니다.
          이 부분을 다음과 같이 작성할 수 도 있습니다:</p>
        <pre name="code" class="haskell:hs">        else (do
            putStrLn $ reverseWords line
            main)
</pre>
        <p><i>do</i>블록을 하나의 I/O action로 보이게 만들었지만, 생긴건 못생겼습니다. 어쨋건, <i>do</i>블록
          내부에서 <span class="fixed">getLine</span>으로 얻은 라인에 대해 <span class="fixed">reverseWords</span>을
          호출하여 이를 터미널에 출력하였습니다. 이를 마친 후에는 <span class="fixed">main</span>을
          수행하였습니다. <span class="fixed">main</span> 그 자체가 하나의 I/O action이기에,
          재귀적으로 호출하는것 역시 괜찮습니다. 따라서, 어떤 의미에선 프로그램의 시작 부분으로 거슬러 올라갑니다.</p>
        <p>그러면 <span class="fixed">null line</span>이 참을 만족하면 어떻게 될까요? 이러한 경우 <i>then</i>이
          수행됩니다. 자세히 살펴본다면, <span class="fixed">then return ()</span>를 발견할 수 있을
          것입니다. 여러분들이 C, Java, Python과 같은 imperative언어를 경험하였다면, 아마 <span class="fixed">return</span>이
          하는 일이 무엇인지 알고있다고 생각하여 실제론 기나긴 패러다임을 이미 넘어섰다고 생각할지도 모르겠습니다. 흠, 과연 그럴까요?
          <em>하스켈에서의 <span class="fixed">return</span>은 실제로, 다른 대부분의 언어에서의 <span
              class="fixed">return</span>과 같지 않습니다!</em> 동일한 이름을 가져 많은 사람들을
          혼란스럽게 하지만, 사실 매우 다릅니다. imperative언어에서의 <span class="fixed">return</span>은
          보통 메소드나 서브루틴의 실행을 끝내거나, 호출한 누군가에게 값을 제공합니다. 하스켈에선 (특히 I/O actions에선),
          I/O action에서 순수한 값을 얻어오는 것입니다. 전에 상자에 비유한 것을 들쳐보자면, 이는 취한 값을 상자안에
          가둬버립니다. I/O action의 결과는 사실 아무것도 하지 않으며, 이의 결과로 봉인된 값을 갖고 있기만 합니다. 따라서
          I/O context에서의 <span class="fixed">return "haha"</span>은 <span class="fixed">IO
            String</span>타입을 지닐 것입니다. I/O action속에서 아무것도 하지않는 순수한 값을 옮기기만 하는 이유가
          무엇일까요? 왜 저희 프로그램이 <span class="fixed">IO</span>로 더럽혀질까요? 비어있는 라인을
          처리하려면 어떠한 I/O action이 필요합니다. 이것이 바로 <span class="fixed">return ()</span>라
          작성하여 아무것도 행하는 모조 I/O action을 만들어야 되는 이유입니다. </p>
        <p><span class="fixed">return</span>은 I/O <i>do</i> 블록의 실행을 끝내거나 그와 비슷한
          일을 하지 않습니다. 예를들어, 다음 프로그램은 마지막 줄까지 순조롭게 진행될 것입니다:</p>
        <pre name="code" class="haskell:hs">main = do
    return ()
    return "HAHAHA"
    line &lt;- getLine
    return "BLAH BLAH BLAH"
    return 4
    putStrLn line
</pre>
        <p>여기나온 <span class="fixed">return</span>들이 하는 일은, 봉인된 값을 갖는 것을 제외하고는
          어떠한 일도 하지 않는 I/O action들을 만드는 것이며, name에 bind되지 않았기에 그 결과는 버려지게 됩니다.
          무언가를 name에 bind하기 위해 <span class="fixed">return</span>을 <span class="fixed">&lt;-</span>와
          결합하여 사용할 수 있습니다.</p>
        <pre name="code" class="haskell:hs">main = do
    a &lt;- return "hell"
    b &lt;- return "yeah!"
    putStrLn $ a ++ " " ++ b
</pre>
        <p>보시다시피, <span class="fixed">return</span>은 <span class="fixed">&lt;-</span>와
          반대되는 개념입니다. <span class="fixed">return</span>은 값을 취해 상자에 가둬넣지만, <span
            class="fixed">&lt;-</span>은 상자를 받아 속에 있는 값을 꺼내 name에 bind합니다. 하지만,
          다음처럼 <i>do</i>블록 내에서 <i>let</i> binding을 이용하여 name에 bind할 수 있기에 이처럼
          할 필요가 없습니다: </p>
        <pre name="code" class="haskell:hs">main = do
    let a = "hell"
        b = "yeah"
    putStrLn $ a ++ " " ++ b
</pre>
        <p>:TODO I/O <i>do</i>블록을 다룰 때에는, we mostly use <span class="fixed">return</span>
          either because we need to create an I/O action that doesn't do
          anything 아무것도 하지 않는 만들거나 I/O action을 만들거나, because we don't want the
          I/O action that's made up from a <i>do</i>블록으로부터 block to have the
          result value of its last action 마지막 action의 결과 갖도록, but we want it to
          have a different result value, so we use <span class="fixed">return</span>
          to make an I/O action that always 항상 저희가 원하는 결과를 포함하는 I/O action을 만들기
          위해 return을 사용할 것이며, 이를 마지막에 넣을 것입니다 has our desired result
          contained&nbsp; and we put it at the end.</p>
        <div class="hintbox">또한 <i>do</i>블록은 단지 하나의 I/O action을 가질 수 있습니다. 이러한
          경우, it's the same as just writing the I/O action을 쓴 것과 같습니다. 이러한 경우 <i>else</i>
          또한 <i>do</i>를 가지므로 몇몇 사람들은 <span class="fixed">then do return ()</span>라
          작성하는 것을 선호하기도 합니다.</div>
        <p>파일로 넘어가기전에, I/O를 다루는데 있어 유용한 함수들을 살펴봅시다.</p>
        <p><span class="label function">putStr</span>은 문자열을 인자로 받아 터미널에 문자열로
          출력되는 I/O action을 반환하는 점에서는 <span class="fixed">putStrLn</span>와
          닮았지만,&nbsp; <span class="fixed">putStrLn</span>은 문자열을 출력하고 새로운 줄로
          넘어가는 반면 <span class="fixed">putStr</span>는 그렇지 않습니다.</p>
        <pre name="code" class="haskell:hs">main = do   putStr "Hey, "
            putStr "I'm "
            putStrLn "Andy!" 
</pre>
        <pre name="code" class="plain">$ runhaskell putstr_test.hs
Hey, I'm Andy!
</pre>
        <p>타입서명은 <span class="fixed">putStr :: String -&gt; IO ()</span>이므로,
          I/O action의 결과로 동봉된 결과값은 unit입니다. 가짜 값이므로, bind하지 않는게 이치에 맞습니다.</p>
        <p><span class="label function">putChar</span>는 문자를 취해, 터미널에 그 문자를 출력하는
          I/O action을 반환합니다..</p>
        <pre name="code" class="haskell:hs">main = do   putChar 't'
            putChar 'e'
            putChar 'h'
</pre>
        <pre name="code" class="plain">$ runhaskell putchar_test.hs
teh
</pre>
        <p><span class="fixed">putStr</span>는 사실 <span class="fixed">putChar</span>의
          도움으로 재귀적으로 정의되었습니다. <span class="fixed">putStr</span>의 주변조건은 비어있는
          문자열이므로, 비어있는 문자열을 출력하고자 한다면, <span class="fixed">return ()</span>을
          이용하여 아무런 일도 하지 않는 I/O action을 반환합니다. 비어있지 않다면, <span class="fixed">putChar</span>를
          이용하여 문자열의 첫번째 문자를 출력하고, <span class="fixed">putStr</span>를 이용하여 나머지를
          출력합니다.</p>
        <pre name="code" class="haskell:hs">putStr :: String -&gt; IO ()
putStr [] = return ()
putStr (x:xs) = do
    putChar x
    putStr xs
</pre>
        <p>순수한 코드에서 이용했던것처럼, I/O에서 재귀를 사용할 수 있는것에 주목하시기 바랍니다. 순수한 코드에서 처럼, 주변
          조건을 정의하였고 실제 결과가 무엇인지 생각하였습니다. 우선 첫번째 문자를 출력하고, 나머지 문자열을 출력합니다.</p>
        <p><span class="label function">print</span>는 값을 문자열로 만드는 <span class="fixed">show</span>라
          불리는 <span class="fixed">Show</span> 인스턴스 타입의 값을 취해 터미널에 출력합니다. 근본적으로
          이는 단지 <span class="fixed">putStrLn . show</span>입니다. 우선 <span class="fixed">show</span>를
          돌려, o값을 출력시키는 <span class="fixed">putStrLn</span>에게 넘깁니다.</p>
        <pre name="code" class="haskell:hs">main = do   print True
            print 2
            print "haha"
            print 3.2
            print [3,4,3]
</pre>
        <pre name="code" class="haskell:hs">$ runhaskell print_test.hs
True
2
"haha"
3.2
[3,4,3]
</pre>
        <p>보시다시피, 이는 매우 편리한 함수입니다. <span class="fixed">main</span>에 닿거나,&nbsp;
          GHCI 프롬프트에서 평가할때 어떻게 I/O action이 수행되는지에 대해 예기한 기억이 나십니까? 사실 (<span class="fixed">3</span>이
          나 <span class="fixed">[1,2,3]</span>와 같은) 값을 입력하고 엔터를 누르면, GHCI는 터미널에
          그 값을 보여주기 위해 <span class="fixed">print</span>를 이용합니다! </p>
        <pre name="code" class="haskell:hs">ghci&gt; 3
3
ghci&gt; print 3
3
ghci&gt; map (++"!") ["hey","ho","woo"]
["hey!","ho!","woo!"]
ghci&gt; print (map (++"!") ["hey","ho","woo"])
["hey!","ho!","woo!"]
</pre>
        <p>문자열을 출력하고자 할때에는 quote를 피하고자 보통 <span class="fixed">putStrLn</span>을
          사용하며, 터미널에 다른 타입의 값들을 출력하는데 있어선 <span class="fixed">print</span>가 가장
          많이 쓰입니다.</p>
        <p><span class="function label">getChar</span>는 입력에서 문자를 읽어오는 I/O
          action입니다. 따라서, I/O action이 담고있는 결과가 <span class="fixed">Char</span>이
          기에 타입서명은 <span class="fixed">getChar :: IO Char</span>입니다. 버퍼링으로 인해,
          엔터키를 누르기 전까지 문자를 읽어오지 않는 다는 것을 주의하시기 바랍니다.</p>
        <pre name="code" class="haskell:hs">main = do   
    c &lt;- getChar
    if c /= ' '
        then do
            putChar c
            main
        else return ()
</pre>
        <p>이 프로그램은 문자를 읽어 띄어쓰기를 검사하는 것처럼 보입니다. 띄어쓰기가 있다면 실행을 멈추고, 그렇지 않다면 터미널에
          출력후 동일한 일을 다시 반복합니다. Well, it kind of does, only not in the way you
          might expect. 확인해 봅시다:</p>
        <pre name="code" class="plain">$ runhaskell getchar_test.hs
hello sir
hello
</pre>
        <p>두번째 줄이 입력입니다. 저는 <span class="fixed">hello sir</span>라고 입력한 후 엔터를
          눌렀습니다. 버퍼링으로 인해, 문자를 입력할 때마다가 아닌 엔터키를 누른 다음에 프로그램이 실행됩니다. 엔터가 눌리면,
          이제까지 입력한 것에 기반하여 행동하게 됩니다. 이 프로그램을 돌려봐서 어떠한 일을 하는지 느껴봅시다!</p>
        <p><span class="label function">when</span>함수는 <span class="fixed">Control.Monad</span>에
          서 찾을 수 있습니다 (접근하려면,&nbsp; <span class="fixed">import Control.Monad</span>를
          해야합니다). 흥미로운점은 <i>do</i>블록 내에서의 조건문과 흡사해 보이지만, 사실 평범한 함수라는 것입니다. 이는
          부울값과 I/O action을 취해, 부울값이 <span class="fixed">True</span>인 경우 제공한 것과
          동일한 I/O action을 반환합니다. 그렇지않고 <span class="fixed">False</span>라면
          action <span class="fixed">return ()</span>을 반환하며, 이러한 I/O action 은
          아무런 일도 하지 않습니다. 이전 코드를 <span class="fixed">when</span>을 이용하여 <span class="fixed">getChar</span>의
          예를 보여주도록 작성해 보았습니다:</p>
        <pre name="code" class="haskell:hs">import Control.Monad 

main = do
    c &lt;- getChar
    when (c /= ' ') $ do
        putChar c
        main
</pre>
        <p>보시다시피, when은 <span class="fixed">if <i>something</i> then do <i>some
              I/O action</i> else return ()</span> 패턴을 녹여내는데 있어 유용합니다.</p>
        <p><span class="label function">sequence</span>는 I/O action 리스트를 받아
          순차적으로 실행되는 I/O action을 반환합니다. 이러한 I/O action이 포함하는 결과는 모든 I/O action이
          수행된 결과를 담은 리스트가 될 것입니다. sequence의 타입 서명은 <span class="fixed">sequence
            :: [IO a] -&gt; IO [a]</span>입니다. 다음과 같은 일을 할 수 있습니다:</p>
        <pre name="code" class="haskell:hs">main = do
    a &lt;- getLine
    b &lt;- getLine
    c &lt;- getLine
    print [a,b,c]
</pre>
        <p>이것이 하는일은 다음과 같습니다:</p>
        <pre name="code" class="haskell:hs">main = do
    rs &lt;- sequence [getLine, getLine, getLine]
    print rs
</pre>
        <p>따라서 <span class="fixed">sequence [getLine, getLine, getLine]</span>는
          <span class="fixed">getLine</span>을 3번 수행하는 I/O action을 만들어 냅니다. 이러한
          action을 name과 bind한다면 결과는 결과 리스트가 될 것이며, 위 경우에서는 사용자가 프롬프트에 입력한 3개를 담은
          리스트가 될 것입니다.</p>
        <p><span class="fixed">sequence</span>에 대한 일반적인 패턴은 리스트에 대해 <span class="fixed">print</span>나
          <span class="fixed">putStrLn</span>와 같은 함수를 map하는 것입니다. <span class="fixed">map
            print [1,2,3,4]</span>는 I/O action을 생성하지 않습니다. <span class="fixed">[print
            1, print 2, print 3, print 4]</span>와 같은&nbsp; I/O action 리스트를 만들어
          냅니다. I/O action 리스트를 I/O action으로 변형시키고자 한다면, sequence를 해야합니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; sequence (map print [1,2,3,4,5])
1
2
3
4
5
[(),(),(),(),()]
</pre>
        <p>마지막에 <span class="fixed">[(),(),(),(),()]</span>는 과연 무엇일까요? GHCI상에서
          I/O action을 평가하면, 결과가 <span class="fixed">()</span>이면 수행 결과가 출력되며,
          그렇다면 출력되지 않습니다. 따라서 GHCI상에서 <span class="fixed">putStrLn "hehe"</span>를
          평가하면 <span class="fixed">hehe</span> 가 출력됩니다(<span class="fixed">putStrLn
            "hehe"</span>의 결과가 담고있는 값은 <span class="fixed">()</span>이기 때문입니다).
          하지만 GHCI에서 <span class="fixed">getLine</span>를 한다면, <span class="fixed">getLine</span>은
          <span class="fixed">IO String</span> 타입을 갖기에 I/O action의 결과가 출력될 것입니다.</p>
        <p>리스트에 대한 I/O action을 반환하는 함수를 매핑(mapping)하여 순서화시키는(sequencing) 것은 매우
          일상적이기에, 유틸리티 함수 <span class="label function">mapM</span>와 <span class="label function">mapM_</span>이
          도입되었습니다. <span class="fixed">mapM</span>는 함수와 리스트를 취해, 리스트에 대해 함수를
          map한 후 sequence합니다. <span class="fixed">mapM_</span>는 동일한 일을 수행하지만,
          결과는 버려집니다. sequence된 I/O action이 가지는 결과가 무엇인지 상관치 않을때 보통&nbsp; <span
            class="fixed">mapM_</span>를 사용합니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; mapM print [1,2,3]
1
2
3
[(),(),()]
ghci&gt; mapM_ print [1,2,3]
1
2
3
</pre>
        <p><span class="label function">forever</span>는 I/O action 하나를 취해 무한히
          반복되는 I/O action을 반환합니다. 이는 <span class="fixed">Control.Monad</span>에
          위치해 있습니다. 이 작은 프로그램은 사용자에게 계속하여 입력을 요구한후 대문자로 변환시켜 돌려줄 것입니다:</p>
        <pre name="code" class="haskell:hs">import Control.Monad
import Data.Char

main = forever $ do
    putStr "Give me some input: "
    l &lt;- getLine
    putStrLn $ map toUpper l
</pre>
        <p><span class="label function">forM</span>은 ( <span class="fixed">Control.Monad</span>에
          위치한) <span class="fixed">mapM</span>와 같습니다, :TODO only that it has
          its parameters switched around. The first parameter is the list and
          the second one is the function to map over that list, which is then
          sequenced. Why is that useful? Well, with some creative use of lambdas
          and <i>do</i> notation, we can do stuff like this:</p>
        <pre name="code" class="haskell:hs">import Control.Monad

main = do 
    colors &lt;- forM [1,2,3,4] (\a -&gt; do
        putStrLn $ "Which color do you associate with the number " ++ show a ++ "?"
        color &lt;- getLine
        return color)
    putStrLn "The colors that you associate with 1, 2, 3 and 4 are: "
    mapM putStrLn colors
</pre>
        <p>The <span class="fixed">(\a -&gt; do ... )</span> is a function that
          takes a number and returns an I/O action. We have to surround it with
          parentheses, otherwise the lambda thinks the last two I/O actions
          belong to it. Notice that we do <span class="fixed">return color</span>
          in the inside <i>do</i> block. We do that so that the I/O action
          which the <i>do</i> block defines has the result of our color
          contained within it. We actually didn't have to do that, because <span
            class="fixed">getLine</span> already has that contained within it.
          Doing <span class="fixed">color &lt;- getLine</span> and then <span
            class="fixed">return color</span> is just unpacking the result from
          <span class="fixed">getLine</span> and then repackaging it again, so
          it's the same as just doing <span class="fixed">getLine</span>. The <span
            class="fixed">forM</span> (called with its two parameters) produces
          an I/O action, whose result we bind to <span class="fixed">colors</span>.
          <span class="fixed">colors</span> is just a normal list that holds
          strings. At the end, we print out all those colors by doing <span class="fixed">mapM
            putStrLn colors</span>.</p>
        <p>You can think of <span class="fixed">forM</span> as meaning: make an
          I/O action for every element in this list. What each I/O action will
          do can depend on the element that was used to make the action.
          Finally, perform those actions and bind their results to something. We
          don't have to bind it, we can also just throw it away.</p>
        <pre name="code" class="plain">$ runhaskell form_test.hs
Which color do you associate with the number 1?
white
Which color do you associate with the number 2?
blue
Which color do you associate with the number 3?
red
Which color do you associate with the number 4?
orange
The colors that you associate with 1, 2, 3 and 4 are:
white
blue
red
orange
</pre>
        <p>We could have actually done that without <span class="fixed">forM</span>,
          only with <span class="fixed">forM</span> it's more readable.
          Normally we write <span class="fixed">forM</span> when we want to map
          and sequence some actions that we define there on the spot using <i>do</i>
          notation. In the same vein, we could have replaced the last line with
          <span class="fixed">forM colors putStrLn</span>.</p>
        <p>In this section, we learned the basics of input and output. We also
          found out what I/O actions are, how they enable us to do input and
          output and when they are actually performed. To reiterate, I/O actions
          are values much like any other value in Haskell. We can pass them as
          parameters to functions and functions can return I/O actions as
          results. What's special about them is that if they fall into the <span
            class="fixed">main</span> function (or are the result in a GHCI
          line), they are performed. And that's when they get to write stuff on
          your screen or play Yakety Sax through your speakers. Each I/O action
          can also encapsulate a result with which it tells you what it got from
          the real world.</p>
        <p>Don't think of a function like <span class="fixed">putStrLn</span>과
          같은 함수를 문자열을 받아 화면에 출력하는 함수라 생각하지 마시기 바랍니다as a function that takes a
          string and prints it to the screen. Think of it as a function that
          takes a string and returns an I/O action. That I/O action will, when
          performed, print beautiful poetry to your terminal.</p>
        <a name="files-and-streams"></a>
        <h2>파일과 스트림<br>
        </h2>
        <img src="http://s3.amazonaws.com/lyah/streams.png" alt="streams" class="right"
          height="322" width="464">
        <p><span class="fixed">getChar</span>는 터미널에서 문자 하나를 읽어오는 I/O action입니다.
          <span class="fixed">getLine</span>은 터미널에서 한 줄을 읽어오는 I/O action입니다. 이
          둘은 사실 복잡하지 않으며, 대부분의 프로그래밍 언어에서 이와 상응하는 함수나 구문을 갖고있습니다. 따라서 지금은 <span
            class="label function">getContents</span>를 만나보도록 하겠습니다. <span class="fixed">getContents</span>는
          end-of-file 문자를 만나기 전까지의 표준 입력에서 모든것을 읽어오는 I/O action입니다. 이의 타입은 <span
            class="fixed">getContents :: IO String</span>입니다. What's cool about
          <span class="fixed">getContents</span> is that it does lazy I/O. <span
            class="fixed">foo &lt;- getContents</span>라 하면, 들어온 것들을 한번에 읽어것이
          아니라, 메모리에 저장한 다음, <span class="fixed">foo</span>와 bind해 줍니다. 맞습니다, 이는
          lazy입니다! It'll say: <i>"Yeah yeah, I'll read the input from the
            terminal later as we go along, when you really need it !"</i>. </p>
        <p>어떤 프로그램의 출력을 저희 프로그램의 입력으로 흘러보낼때(pipe) <span class="fixed">getContents</span>는
          매우 유용합니다. unix 시스템에서의 파이프가 하는일을 알지 못한다면, 여기 짧은 지침서가 있습니다. 다음 짧은 하이쿠를
          포함하는 텍스트 파일을 만들어 봅시다:</p>
        <pre name="code" class="plain">I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless 
</pre>
        <p>예, 이 하이쿠는 별로이지만, Yeah, the haiku sucks, what of it? 좋은 하이쿠 지침서를 아시는
          분은 제게 알려주시기 바랍니다.</p>
        <p>이제, <span class="fixed">forever</span>함수를 소계하면서 작성한 작은 프로그램을 떠올려
          봅시다. It prompted the user for a line, returned it to him in CAPSLOCK
          and then did that all over again, indefinitely. Just so you don't have
          to scroll all the way back, here it is again:</p>
        <pre name="code" class="haskell:hs">import Control.Monad
import Data.Char

main = forever $ do
    putStr "Give me some input: "
    l &lt;- getLine
    putStrLn $ map toUpper l
</pre>
        <p>이 프로그램을 <span class="fixed">capslocker.hs</span>로 저장하여 컴파일해 봅시다.
          그런다음, 유닉스 pipe를 이용하여 we're going to use a unix pipe to feed our text
          file directly to our little program. We're going to use the help of
          the 저희는 인자로 주어진 파일을 출력하는 GNU <i>cat</i>프로그램의 도움을 받을 것입니다. 첵 잇 아웃,
          부야카!</p>
        <pre name="code" class="plain">$ ghc --make capslocker 
[1 of 1] Compiling Main             ( capslocker.hs, capslocker.o )
Linking capslocker ...
$ cat haiku.txt
I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless
$ cat haiku.txt | ./capslocker
I'M A LIL' TEAPOT
WHAT'S WITH THAT AIRPLANE FOOD, HUH?
IT'S SO SMALL, TASTELESS
capslocker &lt;stdin&gt;: hGetLine: end of file
</pre>
        <p>As you can see, piping the output of one program (in our case that
          was <i>cat</i>) to the input of another (<i>capslocker</i>) is done
          with the <span class="fixed">|</span> character. What we've done is
          pretty much equivalent to just running <i>capslocker</i>, typing our
          haiku at the terminal and then issuing an end-of-file character
          (that's usually done by pressing Ctrl-D). It's like running <i>cat
            haiku.txt</i> and saying: “Wait, don't print this out to the
          terminal, tell it to <i>capslocker</i> instead!”.</p>
        <p>So what we're essentially doing with that use of <span class="fixed">forever</span>
          is taking the input and transforming it into some output. That's why
          we can use <span class="fixed">getContents</span> to make our program
          even shorter and better:</p>
        <pre name="code" class="haskell:hs">import Data.Char

main = do
    contents &lt;- getContents
    putStr (map toUpper contents)
</pre>
        <p>We run the <span class="fixed">getContents</span> I/O action and
          name the string it produces <span class="fixed">contents</span>.
          Then, we map <span class="fixed">toUpper</span> over that string and
          print that to the terminal. Keep in mind that because strings are
          basically lists, which are lazy, and <span class="fixed">getContents</span>
          is I/O lazy, it won't try to read the whole content at once and store
          it into memory before printing out the capslocked version. Rather, it
          will print out the capslocked version as it reads it, because it will
          only read a line from the input when it really needs to.</p>
        <pre name="code" class="plain">$ cat haiku.txt | ./capslocker
I'M A LIL' TEAPOT
WHAT'S WITH THAT AIRPLANE FOOD, HUH?
IT'S SO SMALL, TASTELESS
</pre>
        <p>Cool, it works. What if we just run <i>capslocker</i> and try to
          type in the lines ourselves?</p>
        <pre name="code" class="plain">$ ./capslocker
hey ho
HEY HO
lets go
LETS GO
</pre>
        <p>We got out of that by pressing Ctrl-D. Pretty nice! As you can see,
          it prints out our capslocked input back to us line by line. When the
          result of <span class="fixed">getContents</span> is bound to <span class="fixed">contents</span>,
          it's not represented in memory as a real string, but more like a
          promise that it will produce the string eventually. When we map <span
            class="fixed">toUpper</span> over <span class="fixed">contents</span>,
          that's also a promise to map that function over the eventual contents.
          And finally when <span class="fixed">putStr</span> happens, it says
          to the previous promise: <i>"Hey, I need a capslocked line!"</i>. It
          doesn't have any lines yet, so it says to <span class="fixed">contents</span>:
          <i>"Hey, how about actually getting a line from the terminal?"</i>. So
          that's when <span class="fixed">getContents</span> actually reads
          from the terminal and gives a line to the code that asked it to
          produce something tangible. That code then maps <span class="fixed">toUpper</span>
          over that line and gives it to <span class="fixed">putStr</span>,
          which prints it. And then, <span class="fixed">putStr</span> says: <i>"Hey,
            I need the next line, come on!"</i> and this repeats until there's
          no more input, which is signified by an end-of-file character.</p>
        <p>Let's make program that takes some input and prints out only those
          lines that are shorter than 10 characters. Observe:</p>
        <pre name="code" class="haskell:hs">main = do
    contents &lt;- getContents
    putStr (shortLinesOnly contents)

shortLinesOnly :: String -&gt; String
shortLinesOnly input = 
    let allLines = lines input
        shortLines = filter (\line -&gt; length line &lt; 10) allLines
        result = unlines shortLines
    in  result
</pre>
        <p>We've made our I/O part of the program as short as possible. Because
          our program is supposed to take some input and print out some output
          based on the input, we can implement it by reading the input contents,
          running a function on them and then printing out what the function
          gave back.</p>
        <p>The <span class="fixed">shortLinesOnly</span> function works like
          this: it takes a string, like <span class="fixed">"short\nlooooooooooooooong\nshort
            again"</span>. That string has three lines, two of them are short
          and the middle one is long. It runs the <span class="fixed">lines</span>
          function on that string, which converts it to <span class="fixed">["short",
            "looooooooooooooong", "short again"]</span>, which we then bind to
          the name <span class="fixed">allLines</span>. That list of string is
          then filtered so that only those lines that are shorter than 10
          characters remain in the list, producing <span class="fixed">["short",
            "short again"]</span>. And finally, <span class="fixed">unlines</span>
          joins that list into a single newline delimited string, giving <span
            class="fixed">"short\nshort again"</span>. Let's give it a go.</p>
        <pre name="code" class="plain:hs">i'm short
so am i
i am a loooooooooong line!!!
yeah i'm long so what hahahaha!!!!!!
short line
loooooooooooooooooooooooooooong
short
</pre>
        <pre name="code" class="plain:hs">$ ghc --make shortlinesonly
[1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )
Linking shortlinesonly ...
$ cat shortlines.txt | ./shortlinesonly
i'm short
so am i
short
</pre>
        <p>We pipe the contents of <i>shortlines.txt</i> into the output of <i>shortlinesonly</i>
          and as the output, we only get the short lines.</p>
        <p>This pattern of getting some string from the input, transforming it
          with a function and then outputting that is so common that there
          exists a function which makes that even easier, called <span class="label function">interact</span>.
          <span class="fixed">interact</span> takes a function of type <span class="fixed">String
            -&gt; String</span> as a parameter and returns an I/O action that
          will take some input, run that function on it and then print out the
          function's result. Let's modify our program to use that.</p>
        <pre name="code" class="haskell:hs">main = interact shortLinesOnly

shortLinesOnly :: String -&gt; String
shortLinesOnly input = 
    let allLines = lines input
        shortLines = filter (\line -&gt; length line &lt; 10) allLines
        result = unlines shortLines
    in  result
</pre>
        <p>Just to show that this can be achieved in much less code (even though
          it will be less readable) and to demonstrate our function composition
          skill, we're going to rework that a bit further.</p>
        <pre name="code" class="haskell:hs">main = interact $ unlines . filter ((&lt;10) . length) . lines
</pre>
        <p>Wow, we actually reduced that to just one line, which is pretty cool!</p>
        <p><span class="fixed">interact</span> can be used to make programs that
          are piped some contents into them and then dump some result out or it
          can be used to make programs that appear to take a line of input from
          the user, give back some result based on that line and then take
          another line and so on. There isn't actually a real distinction
          between the two, it just depends on how the user is supposed to use
          them.</p>
        <p>Let's make a program that continuously reads a line and then tells us
          if the line is a palindrome or not. We could just use <span class="fixed">getLine</span>
          to read a line, tell the user if it's a palindrome and then run <span
            class="fixed">main</span> all over again. But it's simpler if we use
          <span class="fixed">interact</span>. When using <span class="fixed">interact</span>,
          think about what you need to do to transform some input into the
          desired output. In our case, we have to replace each line of the input
          with either <span class="fixed">"palindrome"</span> or <span class="fixed">"not
            a palindrome"</span>. So we have to write a function that transforms
          something like <span class="fixed">"elephant\nABCBA\nwhatever"</span>
          into <span class="fixed">"not a palindrome\npalindrome\nnot a
            palindrome"</span>. Let's do this!</p>
        <pre name="code" class="haskell:hs">respondPalindromes contents = unlines (map (\xs -&gt; if isPalindrome xs then "palindrome" else "not a palindrome") (lines contents))
    where   isPalindrome xs = xs == reverse xs
</pre>
        <p>Let's write this in point-free.</p>
        <pre name="code" class="haskell:hs">respondPalindromes = unlines . map (\xs -&gt; if isPalindrome xs then "palindrome" else "not a palindrome") . lines
    where   isPalindrome xs = xs == reverse xs
</pre>
        <p>Pretty straightforward. First it turns something like <span class="fixed">"elephant\nABCBA\nwhatever"</span>
          into <span class="fixed">["elephant", "ABCBA", "whatever"]</span> and
          then it maps that lambda over it, giving <span class="fixed">["not a
            palindrome", "palindrome", "not a palindrome"]</span> and then <span
            class="fixed">unlines</span> joins that list into a single, newline
          delimited string. Now we can do</p>
        <pre name="code" class="haskell:hs">main = interact respondPalindromes
</pre>
        <p>Let's test this out:</p>
        <pre name="code" class="plain">$ runhaskell palindromes.hs
hehe
not a palindrome
ABCBA
palindrome
cookie
not a palindrome

</pre>
        <p>Even though we made a program that transforms one big string of input
          into another, it acts like we made a program that does it line by
          line. That's because Haskell is lazy and it wants to print the first
          line of the result string, but it can't because it doesn't have the
          first line of the input yet. So as soon as we give it the first line
          of input, it prints the first line of the output. We get out of the
          program by issuing an end-of-line character.</p>
        <p>We can also use this program by just piping a file into it. Let's say
          we have this file:</p>
        <pre name="code" class="plain">dogaroo
radar
rotor
madam
</pre>
        <p>and we save it as <span class="fixed">words.txt</span>. This is what
          we get by piping it into our program:</p>
        <pre name="code" class="plain">$ cat words.txt | runhaskell palindromes.hs
not a palindrome
palindrome
palindrome
palindrome
</pre>
        <p>Again, we get the same output as if we had run our program and put in
          the words ourselves at the standard input. We just don't see the input
          that <span class="fixed">palindromes.hs</span> because the input came
          from the file and not from us typing the words in.</p>
        <p>So now you probably see how lazy I/O works and how we can use it to
          our advantage. You can just think in terms of what the output is
          supposed to be for some given input and write a function to do that
          transformation. In lazy I/O, nothing is eaten from the input until it
          absolutely has to be because what we want to print right now depends
          on that input.</p>
        <p>So far, we've worked with I/O by printing out stuff to the terminal
          and reading from it. But what about reading and writing files? Well,
          in a way, we've already been doing that. One way to think about
          reading from the terminal is to imagine that it's like reading from a
          (somewhat special) file. Same goes for writing to the terminal, it's
          kind of like writing to a file. We can call these two files <span class="fixed">stdout</span>
          and <span class="fixed">stdin</span>, meaning <i>standard output</i>
          and <i>standard input</i>, respectively. Keeping that in mind, we'll
          see that writing to and reading from files is very much like writing
          to the standard output and reading from the standard input.</p>
        <p>We'll start off with a really simple program that opens a file called
          <i>girlfriend.txt</i>, which contains a verse from Avril Lavigne's
          #1&nbsp;hit <i>Girlfriend</i>, and just prints out out to the
          terminal. Here's <i>girlfriend.txt</i>:</p>
        <pre name="code" class="plain">Hey! Hey! You! You! 
I don't like your girlfriend! 
No way! No way! 
I think you need a new one!
</pre>
        <p>And here's our program:</p>
        <pre name="code" class="haskell:hs">import System.IO

main = do
    handle &lt;- openFile "girlfriend.txt" ReadMode
    contents &lt;- hGetContents handle
    putStr contents
    hClose handle
</pre>
        <p>Running it, we get the expected result:</p>
        <pre name="code" class="plain">$ runhaskell girlfriend.hs
Hey! Hey! You! You!
I don't like your girlfriend!
No way! No way!
I think you need a new one!
</pre>
        <p>Let's go over this line by line. The first line is just four
          exclamations, to get our attention. In the second line, Avril tells us
          that she doesn't like our current romantic partner. The third line
          serves to emphasize that disapproval, whereas the fourth line suggests
          we should seek out a new girlfriend.</p>
        <p>Let's also go over the program line by line! Our program is several
          I/O actions glued together with a <i>do</i> block. In the first line
          of the <i>do</i> block, we notice a new function called <span class="label function">openFile</span>.
          This is its type signature: <span class="fixed">openFile :: FilePath
            -&gt; IOMode -&gt; IO Handle</span>. If you read that out loud, it
          states: <span class="fixed">openFile</span> takes a file path and an
          <span class="fixed">IOMode</span> and returns an I/O action that will
          open a file and have the file's associated handle encapsulated as its
          result.</p>
        <p><span class="fixed">FilePath</span> is just a <a href="making-our-own-types-and-typeclasses#type-synonyms">type
            synonym</a> for <span class="fixed">String</span>, simply defined
          as:</p>
        <pre name="code" class="haskell:hs">type FilePath = String
</pre>
        <p><span class="fixed">IOMode</span> is a type that's defined like this:</p>
        <pre name="code" class="haskell:hs">data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
</pre> <img src="http://s3.amazonaws.com/lyah/file.png" alt="A FILE IN A CAKE!!!"
          class="left" height="340" width="232">
        <p>Just like our type that represents the seven possible values for the
          days of the week, this type is an enumeration that represents what we
          want to do with our opened file. Very simple. Just note that this type
          is <span class="fixed">IOMode</span> and not <span class="fixed">IO
            Mode</span>. <span class="fixed">IO Mode</span> would be the type
          of an I/O action that has a value of some type <span class="fixed">Mode</span>
          as its result, but <span class="fixed">IOMode</span> is just a simple
          enumeration.</p>
        <p>Finally, it returns an I/O action that will open the specified file
          in the specified mode. If we bind that action to something we get a <span
            class="fixed">Handle</span>. A value of type <span class="fixed">Handle</span>
          represents where our file is. We'll use that handle so we know which
          file to read from. It would be stupid to read a file but not bind that
          read to a handle because we wouldn't be able to do anything with the
          file. So in our case, we bound the handle to <span class="fixed">handle</span>.</p>
        <p>In the next line, we see a function called <span class="label function">hGetContents</span>.
          It takes a <span class="fixed">Handle</span>, so it knows which file
          to get the contents from and returns an <span class="fixed">IO String</span>
          — an I/O action that holds as its result the contents of the file.
          This function is pretty much like <span class="fixed">getContents</span>.
          The only difference is that <span class="fixed">getContents</span>
          will automatically read from the standard input (that is from the
          terminal), whereas <span class="fixed">hGetContents</span> takes a
          file handle which tells it which file to read from. In all other
          respects, they work the same. And just like <span class="fixed">getContents</span>,
          <span class="fixed">hGetContents</span> won't attempt to read the file
          at once and store it in memory, but it will read it as needed. That's
          really cool because we can treat <span class="fixed">contents</span>
          as the whole contents of the file, but it's not really loaded in
          memory. So if this were a really huge file, doing <span class="fixed">hGetContents</span>
          wouldn't choke up our memory, but it would read only what it needed to
          from the file, when it needed to.</p>
        <p>Note the difference between the handle used to identify a file and
          the contents of the file, bound in our program to <span class="fixed">handle</span>
          and <span class="fixed">contents</span>. The handle is just something
          by which we know what our file is. If you imagine your whole file
          system to be a really big book and each file is a chapter in the book,
          the handle is a bookmark that shows where you're currently reading (or
          writing) a chapter, whereas the contents are the actual chapter.</p>
        <p>With <span class="fixed">putStr contents</span> we just print the
          contents out to the standard output and then we do <span class="label function">hClose</span>,
          which takes a handle and returns an I/O action that closes the file.
          You have to close the file yourself after opening it with <span class="fixed">openFile</span>!</p>
        <p>Another way of doing what we just did is to use the <span class="label function">withFile</span>
          function, which has a type signature of <span class="fixed">withFile
            :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a</span>.
          It takes a path to a file, an <span class="fixed">IOMode</span> and
          then it takes a function that takes a handle and returns some I/O
          action. What it returns is an I/O action that will open that file, do
          something we want with the file and then close it. The result
          encapsulated in the final I/O action that's returned is the same as
          the result of the I/O action that the function we give it returns.
          This might sound a bit complicated, but it's really simple, especially
          with lambdas, here's our previous example rewritten to use <span class="fixed">withFile</span>:</p>
        <pre name="code" class="haskell:hs">import System.IO   
  
main = do   
    withFile "girlfriend.txt" ReadMode (\handle -&gt; do
        contents &lt;- hGetContents handle   
        putStr contents)
</pre>
        <p>As you can see, it's very similar to the previous piece of code. <span
            class="fixed">(\handle -&gt; ... )</span> is the function that takes
          a handle and returns an I/O action and it's usually done like this,
          with a lambda. The reason it has to take a function that returns an
          I/O action instead of just taking an I/O action to do and then close
          the file is because the I/O action that we'd pass to it wouldn't know
          on which file to operate. This way, <span class="fixed">withFile</span>
          opens the file and then passes the handle to the function we gave it.
          It gets an I/O action back from that function and then makes an I/O
          action that's just like it, only it closes the file afterwards. Here's
          how we can make our own <span class="fixed">withFile</span> function:</p>
        <pre name="code" class="haskell:hs">withFile' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a
withFile' path mode f = do
    handle &lt;- openFile path mode 
    result &lt;- f handle
    hClose handle
    return result
</pre> <img src="http://s3.amazonaws.com/lyah/edd.png" alt="butter toast" class="right"
          height="360" width="246">
        <p>We know the result will be an I/O action so we can just start off
          with a <i>do</i>. First we open the file and get a handle from it.
          Then, we apply <span class="fixed">handle</span> to our function to
          get back the I/O action that does all the work. We bind that action to
          <span class="fixed">result</span>, close the handle and then do <span
            class="fixed">return result</span>. By <span class="fixed">return</span>ing
          the result encapsulated in the I/O action that we got from <span class="fixed">f</span>,
          we make it so that our I/O action encapsulates the same result as the
          one we got from <span class="fixed">f handle</span>. So if <span class="fixed">f
            handle</span> returns an action that will read a number of lines
          from the standard input and write them to a file and have as its
          result encapsulated the number of lines it read, if we used that with
          <span class="fixed">withFile'</span>, the resulting I/O action would
          also have as its result the number of lines read.</p>
        <p>Just like we have <span class="fixed">hGetContents</span> that works
          like <span class="fixed">getContents</span> but for a specific file,
          there's also <span class="label function">hGetLine</span>, <span class="label function">hPutStr</span>,
          <span class="label function">hPutStrLn</span>, <span class="label function">hGetChar</span>,
          etc. They work just like their counterparts without the <i>h</i>,
          only they take a handle as a parameter and operate on that specific
          file instead of operating on standard input or standard output.
          Example: <span class="fixed">putStrLn</span> is a function that takes
          a string and returns an I/O action that will print out that string to
          the terminal and a newline after it. <span class="fixed">hPutStrLn</span>
          takes a handle and a string and returns an I/O action that will write
          that string to the file associated with the handle and then put a
          newline after it. In the same vein, <span class="fixed">hGetLine</span>
          takes a handle and returns an I/O action that reads a line from its
          file.</p>
        <p>Loading files and then treating their contents as strings is so
          common that we have these three nice little functions to make our work
          even easier:</p>
        <p> <span class="label function">readFile</span> has a type signature
          of <span class="fixed">readFile :: FilePath -&gt; IO String</span>.
          Remember, <span class="fixed">FilePath</span> is just a fancy name
          for <span class="fixed">String</span>. <span class="fixed">readFile</span>
          takes a path to a file and returns an I/O action that will read that
          file (lazily, of course) and bind its contents to something as a
          string. It's usually more handy than doing <span class="fixed">openFile</span>
          and binding it to a handle and then doing <span class="fixed">hGetContents</span>.
          Here's how we could have written our previous example with <span class="fixed">readFile</span>:
        </p>
        <pre name="code" class="haskell:hs">import System.IO

main = do
    contents &lt;- readFile "girlfriend.txt"
    putStr contents
</pre>
        <p> Because we don't get a handle with which to identify our file, we
          can't close it manually, so Haskell does that for us when we use <span
            class="fixed">readFile</span>. </p>
        <p> <span class="label function">writeFile</span> has a type of <span
            class="fixed">writeFile :: FilePath -&gt; String -&gt; IO ()</span>.
          It takes a path to a file and a string to write to that file and
          returns an I/O action that will do the writing. If such a file already
          exists, it will be stomped down to zero length before being written
          on. Here's how to turn <i>girlfriend.txt</i> into a CAPSLOCKED
          version and write it to <i>girlfriendcaps.txt</i>: </p>
        <pre name="code" class="haskell:hs">import System.IO   
import Data.Char
  
main = do   
    contents &lt;- readFile "girlfriend.txt"   
    writeFile "girlfriendcaps.txt" (map toUpper contents)
</pre>
        <pre name="code" class="plain">$ runhaskell girlfriendtocaps.hs
$ cat girlfriendcaps.txt
HEY! HEY! YOU! YOU!
I DON'T LIKE YOUR GIRLFRIEND!
NO WAY! NO WAY!
I THINK YOU NEED A NEW ONE!
</pre>
        <p><span class="label function">appendFile</span> has a type signature
          that's just like <span class="fixed">writeFile</span>, only <span class="fixed">appendFile</span>
          doesn't truncate the file to zero length if it already exists but it
          appends stuff to it.</p>
        <p>Let's say we have a file <i>todo.txt</i> that has one task per line
          that we have to do. Now let's make a program that takes a line from
          the standard input and adds that to our to-do list.</p>
        <pre name="code" class="haskell:hs">import System.IO   
  
main = do   
    todoItem &lt;- getLine
    appendFile "todo.txt" (todoItem ++ "\n")
</pre>
        <pre name="code" class="plain">$ runhaskell appendtodo.hs
Iron the dishes
$ runhaskell appendtodo.hs
Dust the dog
$ runhaskell appendtodo.hs
Take salad out of the oven
$ cat todo.txt
Iron the dishes
Dust the dog
Take salad out of the oven
</pre>
        <p>We needed to add the <span class="fixed">"\n"</span> to the end of
          each line because <span class="fixed">getLine</span> doesn't give us
          a newline character at the end.</p>
        <p>Ooh, one more thing. We talked about how doing <span class="fixed">contents
            &lt;- hGetContents handle</span> doesn't cause the whole file to be
          read at once and stored in-memory. It's I/O lazy, so doing this:</p>
        <pre name="code" class="haskell:hs">main = do 
    withFile "something.txt" ReadMode (\handle -&gt; do
        contents &lt;- hGetContents handle
        putStr contents)
</pre>
        <p>is actually like connecting a pipe from the file to the output. Just
          like you can think of lists as streams, you can also think of files as
          streams. This will read one line at a time and print it out to the
          terminal as it goes along. So you may be asking, how wide is this pipe
          then? How often will the disk be accessed? Well, for text files, the
          default buffering is line-buffering usually. That means that the
          smallest part of the file to be read at once is one line. That's why
          in this case it actually reads a line, prints it to the output, reads
          the next line, prints it, etc. For binary files, the default buffering
          is usually block-buffering. That means that it will read the file
          chunk by chunk. The chunk size is some size that your operating system
          thinks is cool.</p>
        <p>You can control how exactly buffering is done by using the <span class="fixed">hSetBuffering</span>
          function. It takes a handle and a <span class="fixed">BufferMode</span>
          and returns an I/O action that sets the buffering. <span class="fixed">BufferMode</span>
          is a simple enumeration data type and the possible values it can hold
          are: <span class="fixed">NoBuffering</span>, <span class="fixed">LineBuffering</span>
          or <span class="fixed">BlockBuffering (Maybe Int)</span>. The <span
            class="fixed">Maybe Int</span> is for how big the chunk should be,
          in bytes. If it's <span class="fixed">Nothing</span>, then the
          operating system determines the chunk size. <span class="fixed">NoBuffering</span>
          means that it will be read one character at a time. <span class="fixed">NoBuffering</span>
          usually sucks as a buffering mode because it has to access the disk so
          much.</p>
        <p>Here's our previous piece of code, only it doesn't read it line by
          line but reads the whole file in chunks of 2048 bytes.</p>
        <pre name="code" class="haskell:hs">main = do 
    withFile "something.txt" ReadMode (\handle -&gt; do
        hSetBuffering handle $ BlockBuffering (Just 2048)
        contents &lt;- hGetContents handle
        putStr contents)
</pre>
        <p>Reading files in bigger chunks can help if we want to minimize disk
          access or when our file is actually a slow network resource.</p>
        <p>We can also use <span class="label function">hFlush</span>, which is
          a function that takes a handle and returns an I/O action that will
          flush the buffer of the file associated with the handle. When we're
          doing line-buffering, the buffer is flushed after every line. When
          we're doing block-buffering, it's after we've read a chunk. It's also
          flushed after closing a handle. That means that when we've reached a
          newline character, the reading (or writing) mechanism reports all the
          data so far. But we can use <span class="fixed">hFlush</span> to
          force that reporting of data that has been read so far. After
          flushing, the data is available to other programs that are running at
          the same time.</p>
        <p>Think of reading a block-buffered file like this: your toilet bowl is
          set to flush itself after it has one gallon of water inside it. So you
          start pouring in water and once the gallon mark is reached, that water
          is automatically flushed and the data in the water that you've poured
          in so far is read. But you can flush the toilet manually too by
          pressing the button on the toilet. This makes the toilet flush and all
          the water (data) inside the toilet is read. In case you haven't
          noticed, flushing the toilet manually is a metaphor for <span class="fixed">hFlush</span>.
          This is not a very great analogy by programming analogy standards, but
          I wanted a real world object that can be flushed for the punchline.</p>
        <p>We already made a program to add a new item to our to-do list in <i>todo.txt</i>,
          now let's make a program to remove an item. I'll just paste the code
          and then we'll go over the program together so you see that it's
          really easy. We'll be using a few new functions from <span class="fixed">System.Directory</span>
          and one new function from <span class="fixed">System.IO</span>, but
          they'll all be explained.</p>
        <p>Anyway, here's the program for removing an item from <i>todo.txt</i>:</p>
        <pre name="code" class="haskell:hs">import System.IO
import System.Directory
import Data.List

main = do      
    handle &lt;- openFile "todo.txt" ReadMode
    (tempName, tempHandle) &lt;- openTempFile "." "temp"
    contents &lt;- hGetContents handle
    let todoTasks = lines contents   
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line) [0..] todoTasks   
    putStrLn "These are your TO-DO items:"
    putStr $ unlines numberedTasks
    putStrLn "Which one do you want to delete?"   
    numberString &lt;- getLine   
    let number = read numberString   
        newTodoItems = delete (todoTasks !! number) todoTasks   
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile "todo.txt"
    renameFile tempName "todo.txt"
</pre>
        <p>At first, we just open <i>todo.txt</i> in read mode and bind its
          handle to <span class="fixed">handle</span>. </p>
        <p>Next up, we use a function that we haven't met before which is from <span
            class="fixed">System.IO</span> — <span class="label function">openTempFile</span>.
          Its name is pretty self-explanatory. It takes a path to a temporary
          directory and a template name for a file and opens a temporary file.
          We used <span class="fixed">"."</span> for the temporary directory,
          because <span class="fixed">.</span> denotes the current directory on
          just about any OS. We used <span class="fixed">"temp"</span> as the
          template name for the temporary file, which means that the temporary
          file will be named <i>temp</i> plus some random characters. It
          returns an I/O action that makes the temporary file and the result in
          that I/O action is a pair of values: the name of the temporary file
          and a handle. We could just open a normal file called <i>todo2.txt</i>
          or something like that but it's better practice to use <span class="fixed">openTempFile</span>
          so you know you're probably not overwriting anything. </p>
        <p>The reason we didn't use <span class="fixed">getCurrentDirectory</span>
          to get the current directory and then pass it to <span class="fixed">openTempFile</span>
          but instead just passed <span class="fixed">"."</span> to <span class="fixed">openTempFile</span>
          is because <span class="fixed">.</span> refers to the current
          directory on unix-like system and Windows </p>
        <p>Next up, we bind the contents of <i>todo.txt</i> to <span class="fixed">contents</span>.
          Then, split that string into a list of strings, each string one line.
          So <span class="fixed">todoTasks</span> is now something like <span
            class="fixed">["Iron the dishes", "Dust the dog", "Take salad out of
            the oven"]</span>. We zip the numbers from 0 onwards and that list
          with a function that takes a number, like 3, and a string, like <span
            class="fixed">"hey"</span> and returns <span class="fixed">"3 -
            hey"</span>, so <span class="fixed">numberedTasks</span> is <span
            class="fixed">["0 - Iron the dishes", "1 - Dust the dog" ...</span>.
          We join that list of strings into a single newline delimited string
          with <span class="fixed">unlines</span> and print that string out to
          the terminal. Note that instead of doing that, we could have also done
          <span class="fixed">mapM putStrLn numberedTasks</span></p>
        <p>We ask the user which one they want to delete and wait for them to
          enter a number. Let's say they want to delete number 1, which is <span
            class="fixed">Dust the dog</span>, so they punch in <span class="fixed">1</span>.
          <span class="fixed">numberString</span> is now <span class="fixed">"1"</span>
          and because we want a number, not a string, we run <span class="fixed">read</span>
          on that to get <span class="fixed">1</span> and bind that to <span class="fixed">number</span>.</p>
        <p>Remember the <span class="fixed">delete</span> and <span class="fixed">!!</span>
          functions from <span class="fixed">Data.List</span>. <span class="fixed">!!</span>
          returns an element from a list with some index and <span class="fixed">delete</span>
          deletes the first occurence of an element in a list and returns a new
          list without that occurence. <span class="fixed">(todoTasks !!
            number)</span> (number is now <span class="fixed">1</span>) returns
          <span class="fixed">"Dust the dog"</span>. We bind <span class="fixed">todoTasks</span>
          without the first occurence of <span class="fixed">"Dust the dog"</span>
          to <span class="fixed">newTodoItems</span> and then join that into a
          single string with <span class="fixed">unlines</span> before writing
          it to the temporary file that we opened. The old file is now unchanged
          and the temporary file contains all the lines that the old one does,
          except the one we deleted.</p>
        <p>After that we close both the original and the temporary files and
          then we remove the original one with <span class="label function">removeFile</span>,
          which, as you can see, takes a path to a file and deletes it. After
          deleting the old <i>todo.txt</i>, we use <span class="label function">renameFile</span>
          to rename the temporary file to <i>todo.txt</i>. Be careful, <span class="fixed">removeFile</span>
          and <span class="fixed">renameFile</span> (which are both in <span class="fixed">System.Directory</span>
          by the way) take file paths as their parameters, not handles.</p>
        <p>And that's that! We could have done this in even fewer lines, but we
          were very careful not to overwrite any existing files and politely
          asked the operating system to tell us where we can put our temporary
          file. Let's give this a go!</p>
        <pre name="code" class="plain">$ runhaskell deletetodo.hs
These are your TO-DO items:
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven
Which one do you want to delete?
1

$ cat todo.txt
Iron the dishes
Take salad out of the oven

$ runhaskell deletetodo.hs
These are your TO-DO items:
0 - Iron the dishes
1 - Take salad out of the oven
Which one do you want to delete?
0

$ cat todo.txt
Take salad out of the oven
</pre> <a name="command-line-arguments"></a>
        <h2>명령 라인 인자</h2>
        <img src="http://s3.amazonaws.com/lyah/arguments.png" alt="COMMAND LINE ARGUMENTS!!! ARGH"
          class="right" height="380" width="449">
        <p>미널에서 돌아가는 어플리케이션이나 스크립트를 만든다 한다면, 명령 라인 인자를 처리하는 작업은 필수입니다. 다행히도,
          하스켈의 표준 라이브러리는 프로그램의 명령 라인 인자에 대한 우아한 방법을 가지고 있습니다.</p>
        <p>이전 단락에서, 해야할 일 목록에 할 일들을 추가하는 프로그램 하나와 항목을 추가하는 프로그램을 만들었습니다. 저희가 취한
          접근법에는 두가지 문제가 있습니다. 첫번째는 코드에 to-do 파일의 이름을 하드코드 하였다는 것입니다.&nbsp;<span
            style="font-style: italic;"></span><i>todo.txt</i>라고 파일 이름을 <span style="font-style: italic;"></span>정
          해버려, 사용자는 여러게의 할 일 목록들을 관리하지 못하게 되었습니다.</p>
        <p>이를 해결할 한가지 방법으로는, 사용자에게 항상 할 일 목록으로 사용하고자 하는 파일을 물어보는 것입니다. 사용자가
          삭제하고자 하는 항목을 알고자할때 이러한 접근법을 이용하였습니다. 이는 동작하긴 하지만, 사용자가 프로그램을 실행시키고,
          무언가를 요청하고 요청받는데 기다려야 하기에 별로 좋지는 않습니다. 이러한 것을 interactive 프로그램이라 부르며,
          interactive 명령 라인 프로그램과 조금 다른 차이점을 갖습니다. — what if you want to
          automate the execution of that program, like with a batch 스크립트와 같이
          프로그램이 자동적으로 실행되길 원한다면 어떻게 해야할까요? 하나의 프로그램이나 여러 프로그램을 단순히 호출하기만 하는
          batch 스크립트보다, 프로그램과 상호작용하는 batch 스크립트를 만드는 것이 어려울 것입니다.</p>
        <p>실행중에 사용자에 요구하는 프로그램 대신, 프로그램을 실행시킬때 사용자가 요청하도록 하면 That's why it's
          sometimes better to have the user tell the program what they want when
          they run the program, instead of having the program ask the user once
          it's run. And what better way to have the user tell the program what
          they want it to do when they run it than via command line arguments!</p>
        <p><span class="fixed">System.Environment</span>모듈은 두가지 훌륭한 I/O action을
          지닙니다. 하나는 <span class="label function">getArgs</span>, which has a
          type of <span class="fixed">getArgs :: IO [String]</span>타입을 지니며, and
          is an I/O action that will get the arguments that the program was run
          with and have as its contained result a list with the arguments 인자
          리스트를 결과로 포함하는 . <span class="label function">getProgName</span>는 has
          a type of <span class="fixed">getProgName :: IO String</span>타입을 지니며,
          프로그램 이름을 포함하는 I/O action입니다.</p>
        <p>여기, 이 두 개가 어떻게 동작하는지 보여주는 작은 프로그램이 있습니다:</p>
        <pre name="code" class="haskell:hs"> import System.Environment 
 import Data.List
 
 main = do
    args &lt;- getArgs
    progName &lt;- getProgName
    putStrLn "The arguments are:"
    mapM putStrLn args
    putStrLn "The program name is:"
    putStrLn progName
</pre>
        <p><span class="fixed">getArgs</span>와 <span class="fixed">progName</span>를
          <span class="fixed">args</span>와 <span class="fixed">progName</span>에
          bind하였습니다. <span class="fixed">The arguments are:</span>라 말하고,&nbsp;
          <span class="fixed">args</span>에 있는 모든 인자마다 <span class="fixed">putStrLn</span>를
          실행하였습니다. 마지막으로, 프로그램의 이름을 출력하였습니다. 이를 <span class="fixed">arg-test</span>로
          컴파일 해봅시다.</p>
        <pre name="code" class="plain">$ ./arg-test first second w00t "multi word arg"
The arguments are:
first
second
w00t
multi word arg
The program name is:
arg-test
</pre>
        <p>훌륭합니다. 이러한 지식으로 무장된 여러분은, 훌륭한 명령 라인 앱을 만들 수 있을 것입니다. 실제로 한번 만들어 봅시다.
          이전 단락에서, 프로그램을 추가하는 작업과 삭제하는 작업으로 나누었습니다. 이제, 명령 라인 인자에 기반한 하나의 프로그램으로
          합칠 것입니다. 또한 <i>todo.txt</i>가 아닌 다양한 파일에 작업할 수 있도록 만들 것입니다.</p>
        <p>이를 단순히 <i>todo</i>라 부를것이며, 이는 3가지 다른 일을 할 수 있어야 합니다:</p>
        <ul>
          <li>보기</li>
          <li>추가</li>
          <li>삭제<br>
          </li>
        </ul>
        <p>We're not going to concern ourselves with possible bad input too much
          right now.</p>
        <p>Our program will be made so that if we want to add the task <span class="fixed">Find
            the magic sword of power</span> to the file <i>todo.txt</i>, we
          have to punch in <span class="fixed">todo add todo.txt "Find the
            magic sword of power"</span> in our terminal. To view the tasks
          we'll just do <span class="fixed">todo view todo.txt</span> and to
          remove the task with the index of 2, we'll do <span class="fixed">todo
            remove todo.txt 2</span>.</p>
        <p>We'll start by making a dispatch association list. It's going to be a
          simple association list that has command line arguments as keys and
          functions as their corresponding values. All these functions will be
          of type <span class="fixed">[String] -&gt; IO ()</span>. They're
          going to take the argument list as a parameter and return an I/O
          action that does the viewing, adding, deleting, etc.</p>
        <pre name="code" class="haskell:hs">import System.Environment 
import System.Directory
import System.IO
import Data.List

dispatch :: [(String, [String] -&gt; IO ())]
dispatch =  [ ("add", add)
            , ("view", view)
            , ("remove", remove)
            ]
</pre>
        <p>We have yet to define <span class="fixed">main</span>, <span class="fixed">add</span>,
          <span class="fixed">view</span> and <span class="fixed">remove</span>,
          so let's start with <span class="fixed">main</span>:</p>
        <pre name="code" class="haskell:hs">main = do
    (command:args) &lt;- getArgs
    let (Just action) = lookup command dispatch
    action args
</pre>
        <p>First, we get the arguments and bind them to <span class="fixed">(command:args)</span>.
          If you remember your pattern matching, this means that the first
          argument will get bound to <span class="fixed">command</span> and the
          rest of them will get bound to <span class="fixed">args</span>. If we
          call our program like <span class="fixed">todo add todo.txt "Spank
            the monkey"</span>, <span class="fixed">command</span> will be <span
            class="fixed">"add"</span> and <span class="fixed">args</span> will
          be <span class="fixed">["todo.xt", "Spank the monkey"]</span>.</p>
        <p>In the next line, we look up our command in the dispatch list.
          Because <span class="fixed">"add"</span> points to <span class="fixed">add</span>,
          we get <span class="fixed">Just add</span> as a result. We use
          pattern matching again to extract our function out of the <span class="fixed">Maybe</span>.
          What happens if our command isn't in the dispatch list? Well then the
          lookup will return <span class="fixed">Nothing</span>, but we said we
          won't concern ourselves with failing gracefully too much, so the
          pattern matching will fail and our program will throw a fit.</p>
        <p>Finally, we call our <span class="fixed">action</span> function with
          the rest of the argument list. That will return an I/O action that
          either adds an item, displays a list of items or deletes an item and
          because that action is part of the <span class="fixed">main</span> <i>do</i>
          block, it will get performed. If we follow our concrete example so far
          and our <span class="fixed">action</span> function is <span class="fixed">add</span>,
          it will get called with <span class="fixed">args</span> (so <span class="fixed">["todo.txt",
            "Spank the monkey"]</span>) and return an I/O action that adds <span
            class="fixed">Spank the monkey</span> to <i>todo.txt</i>.</p>
        <p>Great! All that's left now is to implement <span class="fixed">add</span>,
          <span class="fixed">view</span> and <span class="fixed">remove</span>.
          Let's start with <span class="fixed">add</span>:</p>
        <pre name="code" class="haskell:hs">add :: [String] -&gt; IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")
</pre>
        <p>If we call our program like <span class="fixed">todo add todo.txt
            "Spank the monkey"</span>, the <span class="fixed">"add"</span>
          will get bound to <span class="fixed">command</span> in the first
          pattern match in the <span class="fixed">main</span> block, whereas <span
            class="fixed">["todo.txt", "Spank the monkey"]</span> will get
          passed to the function that we get from the dispatch list. So, because
          we're not dealing with bad input right now, we just pattern match
          against a list with those two elements right away and return an I/O
          action that appends that line to the end of the file, along with a
          newline character.</p>
        <p>Next, let's implement the list viewing functionality. If we want to
          view the items in a file, we do <span class="fixed">todo view
            todo.txt</span>. So in the first pattern match, <span class="fixed">command</span>
          will be <span class="fixed">"view"</span> and <span class="fixed">args</span>
          will be <span class="fixed">["todo.txt"]</span>.</p>
        <pre name="code" class="haskell:hs">view :: [String] -&gt; IO ()
view [fileName] = do
    contents &lt;- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line) [0..] todoTasks
    putStr $ unlines numberedTasks
</pre>
        <p>We already did pretty much the same thing in the program that only
          deleted tasks when we were displaying the tasks so that the user can
          choose one for deletion, only here we just display the tasks.</p>
        <p>And finally, we're going to implement <span class="fixed">remove</span>.
          It's going to be very similar to the program that only deleted the
          tasks, so if you don't understand how deleting an item here works,
          check out the explanation under that program. The main difference is
          that we're not hardcoding <i>todo.txt</i> but getting it as an
          argument. We're also not prompting the user for the task number to
          delete, we're getting it as an argument.</p>
        <pre name="code" class="haskell:hs">remove :: [String] -&gt; IO ()
remove [fileName, numberString] = do
    handle &lt;- openFile fileName ReadMode
    (tempName, tempHandle) &lt;- openTempFile "." "temp"
    contents &lt;- hGetContents handle
    let number = read numberString
        todoTasks = lines contents
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
</pre>
        <p>We opened up the file based on <span class="fixed">fileName</span>
          and opened a temporary file, deleted the line with the index that the
          user wants to delete, wrote that to the temporary file, removed the
          original file and renamed the temporary file back to <span class="fixed">fileName</span>.</p>
        <p>Here's the whole program at once, in all its glory!</p>
        <pre name="code" class="haskell:hs">import System.Environment 
import System.Directory
import System.IO
import Data.List

dispatch :: [(String, [String] -&gt; IO ())]
dispatch =  [ ("add", add)
            , ("view", view)
            , ("remove", remove)
            ]
 
main = do
    (command:args) &lt;- getArgs
    let (Just action) = lookup command dispatch
    action args

add :: [String] -&gt; IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")

view :: [String] -&gt; IO ()
view [fileName] = do
    contents &lt;- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line) [0..] todoTasks
    putStr $ unlines numberedTasks

remove :: [String] -&gt; IO ()
remove [fileName, numberString] = do
    handle &lt;- openFile fileName ReadMode
    (tempName, tempHandle) &lt;- openTempFile "." "temp"
    contents &lt;- hGetContents handle
    let number = read numberString
        todoTasks = lines contents
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
</pre> <img src="http://s3.amazonaws.com/lyah/salad.png" alt="fresh baked salad"
          class="left" height="200" width="143">
        <p>To summarize our solution: we made a dispatch association that maps
          from commands to functions that take some command line arguments and
          return an I/O action. We see what the command is and based on that we
          get the appropriate function from the dispatch list. We call that
          function with the rest of the command line arguments to get back an
          I/O action that will do the appropriate thing and then just perform
          that action!</p>
        <p>In other languages, we might have implemented this with a big switch
          case statement or whatever, but using higher order functions allows us
          to just tell the dispatch list to give us the appropriate function and
          then tell that function to give us an I/O action for some command line
          arguments.</p>
        <p>Let's try our app out!</p>
        <pre name="code" class="plain">$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven

$ ./todo add todo.txt "Pick up children from drycleaners"

$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven
3 - Pick up children from drycleaners

$ ./todo remove todo.txt 2

$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Pick up children from drycleaners
</pre>
        <p>Another cool thing about this is that it's easy to add extra
          functionality. Just add an entry in the dispatch association list and
          implement the corresponding function and you're laughing! As an
          exercise, you can try implementing a <span class="fixed">bump</span>
          function that will take a file and a task number and return an I/O
          action that bumps that task to the top of the to-do list.</p>
        <p>You could make this program fail a bit more gracefully in case of bad
          input (for example, if someone runs <span class="fixed">todo UP YOURS
            HAHAHAHA</span>) by making an I/O action that just reports there has
          been an error (say, <span class="fixed">errorExit :: IO ()</span>)
          and then check for possible erronous input and if there is erronous
          input, perform the error reporting I/O action. Another way is to use
          exceptions, which we will meet soon.</p>
        <a name="randomness"></a>
        <h2>무작위성</h2>
        <img src="http://s3.amazonaws.com/lyah/random.png" alt="this picture is the ultimate source of randomness and wackiness"
          class="right" height="362" width="358">
        <p>Many times while programming, you need to get some random data. Maybe
          you're making a game where a die needs to be thrown or you need to
          generate some test data to test out your program. There are a lot of
          uses for random data when programming. Well, actually, pseudo-random,
          because we all know that the only true source of randomness is a
          monkey on a unicycle with a cheese in one hand and its butt in the
          other. In this section, we'll take a look at how to make Haskell
          generate seemingly random data.</p>
        <p>In most other programming languages, you have functions that give you
          back some random number. Each time you call that function, you get
          back a (hopefully) different random number. How about Haskell? Well,
          remember, Haskell is a pure functional language. What that means is
          that it has referential transparency. What THAT means is that a
          function, if given the same parameters twice, must produce the same
          result twice. That's really cool because it allows us to reason
          differently about programs and it enables us to defer evaluation until
          we really need it. If I call a function, I can be sure that it won't
          do any funny stuff before giving me the results. All that matters are
          its results. However, this makes it a bit tricky for getting random
          numbers. If I have a function like this:</p>
        <pre name="code" class="haskell:hs">randomNumber :: (Num a) =&gt; a
randomNumber = 4
</pre>
        <p>It's not very useful as a random number function because it will
          always return <span class="fixed">4</span>, even though I can assure
          you that the 4 is completely random, because I used a die to determine
          it.</p>
        <p>How do other languages make seemingly random numbers? Well, they take
          various info from your computer, like the current time, how much and
          where you moved your mouse and what kind of noises you made behind
          your computer and based on that, give a number that looks really
          random. The combination of those factors (that randomness) is probably
          different in any given moment in time, so you get a different random
          number.</p>
        <p>Ah. So in Haskell, we can make a random number then if we make a
          function that takes as its parameter that randomness and based on that
          returns some number (or other data type).</p>
        <p>Enter the <span class="fixed">System.Random</span> module. It has
          all the functions that satisfy our need for randomness. Let's just
          dive into one of the functions it exports then, namely <span class="label function">random</span>.
          Here's its type: <span class="fixed">random :: (RandomGen g, Random
            a) =&gt; g -&gt; (a, g)</span>. Whoa! Some new typeclasses in this
          type declaration up in here! The <span class="label class">RandomGen</span>
          typeclass is for types that can act as sources of randomness. The <span
            class="label class">Random</span> typeclass is for things that can
          take on random values. A boolean value can take on a random value,
          namely <span class="fixed">True</span> or <span class="fixed">False</span>.
          A number can also take up a plethora of different random values. Can a
          function take on a random value? I don't think so, probably not! If we
          try to translate the type declaration of <span class="fixed">random</span>
          to English, we get something like: it takes a random generator (that's
          our source of randomness) and returns a random value and a new random
          generator. Why does it also return a new generator as well as a random
          value? Well, we'll see in a moment.</p>
        <p>To use our <span class="fixed">random</span> function, we have to
          get our hands on one of those random generators. The <span class="fixed">System.Random</span>
          module exports a cool type, namely <span class="label type">StdGen</span>
          that is an instance of the <span class="fixed">RandomGen</span>
          typeclass. We can either make a <span class="fixed">StdGen</span>
          manually or we can tell the system to give us one based on a multitude
          of sort of random stuff.</p>
        <p>To manually make a random generator, use the <span class="label function">mkStdGen</span>
          function. It has a type of <span class="fixed">mkStdGen :: Int -&gt;
            StdGen</span>. It takes an integer and based on that, gives us a
          random generator. Okay then, let's try using <span class="fixed">random</span>
          and <span class="fixed">mkStdGen</span> in tandem to get a (hardly
          random) number.</p>
        <pre name="code" class="haskell:hs">ghci&gt; random (mkStdGen 100)
</pre>
        <pre name="code" class="plain">&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraint:
      `Random a' arising from a use of `random' at &lt;interactive&gt;:1:0-20
    Probable fix: add a type signature that fixes these type variable(s)
</pre>
        <p>What's this? Ah, right, the <span class="fixed">random</span>
          function can return a value of any type that's part of the <span class="fixed">Random</span>
          typeclass, so we have to inform Haskell what kind of type we want.
          Also let's not forget that it returns a random value and a random
          generator in a pair.</p>
        <pre name="code" class="haskell:hs">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)
(-1352021624,651872571 1655838864)
</pre>
        <p>Finally! A number that looks kind of random! The first component of
          the tuple is our number whereas the second component is a textual
          representation of our new random generator. What happens if we call <span
            class="fixed">random</span> with the same random generator again?</p>
        <pre name="code" class="haskell:hs">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)
(-1352021624,651872571 1655838864)
</pre>
        <p>Of course. The same result for the same parameters. So let's try
          giving it a different random generator as a parameter.</p>
        <pre name="code" class="haskell:hs">ghci&gt; random (mkStdGen 949494) :: (Int, StdGen)
(539963926,466647808 1655838864)
</pre>
        <p>Alright, cool, great, a different number. We can use the type
          annotation to get different types back from that function. </p>
        <pre name="code" class="haskell:hs">ghci&gt; random (mkStdGen 949488) :: (Float, StdGen)
(0.8938442,1597344447 1655838864)
ghci&gt; random (mkStdGen 949488) :: (Bool, StdGen)
(False,1485632275 40692)
ghci&gt; random (mkStdGen 949488) :: (Integer, StdGen)
(1691547873,1597344447 1655838864)
</pre>
        <p>Let's make a function that simulates tossing a coin three times. If <span
            class="fixed">random</span> didn't return a new generator along with
          a random value, we'd have to make this function take three random
          generators as a parameter and then return coin tosses for each of
          them. But that sounds wrong because if one generator can make a random
          value of type <span class="fixed">Int</span> (which can take on a
          load of different values), it should be able to make three coin tosses
          (which can take on precisely eight combinations). So this is where <span
            class="fixed">random</span> returning a new generator along with a
          value really comes in handy.</p>
        <p>We'll represent a coin with a simple <span class="fixed">Bool</span>.
          <span class="fixed">True</span> is tails, <span class="fixed">False</span>
          is heads.</p>
        <pre name="code" class="haskell:hs">threeCoins :: StdGen -&gt; (Bool, Bool, Bool)
threeCoins gen = 
    let (firstCoin, newGen) = random gen
        (secondCoin, newGen') = random newGen
        (thirdCoin, newGen'') = random newGen'
    in  (firstCoin, secondCoin, thirdCoin)
</pre>
        <p>We call <span class="fixed">random</span> with the generator we got
          as a parameter to get a coin and a new generator. Then we call it
          again, only this time with our new generator, to get the second coin.
          We do the same for the third coin. Had we called it with the same
          generator every time, all the coins would have had the same value and
          we'd only be able to get <span class="fixed">(False, False, False)</span>
          or <span class="fixed">(True, True, True)</span> as a result.</p>
        <pre name="code" class="haskell:hs">ghci&gt; threeCoins (mkStdGen 21)
(True,True,True)
ghci&gt; threeCoins (mkStdGen 22)
(True,False,True)
ghci&gt; threeCoins (mkStdGen 943)
(True,False,True)
ghci&gt; threeCoins (mkStdGen 944)
(True,True,True)
</pre>
        <p>Notice that we didn't have to do <span class="fixed">random gen ::
            (Bool, StdGen)</span>. That's because we already specified that we
          want booleans in the type declaration of the function. That's why
          Haskell can infer that we want a boolean value in this case.</p>
        <p>So what if we want to flip four coins? Or five? Well, there's a
          function called <span class="label function">randoms</span> that
          takes a generator and returns an infinite sequence of values based on
          that generator.</p>
        <pre name="code" class="haskell:hs">ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Int]
[-1807975507,545074951,-1015194702,-1622477312,-502893664]
ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Bool]
[True,True,True,True,False]
ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Float]
[7.904789e-2,0.62691015,0.26363158,0.12223756,0.38291094]
</pre>
        <p>Why doesn't <span class="fixed">randoms</span> return a new
          generator as well as a list? We could implement the <span class="fixed">randoms</span>
          function very easily like this:</p>
        <pre name="code" class="haskell:hs">randoms' :: (RandomGen g, Random a) =&gt; g -&gt; [a]
randoms' gen = let (value, newGen) = random gen in value:randoms' newGen
</pre>
        <p>A recursive definition. We get a random value and a new generator
          from the current generator and then make a list that has the value as
          its head and random numbers based on the new generator as its tail.
          Because we have to be able to potentially generate an infinite amount
          of numbers, we can't give the new random generator back.</p>
        <p>We could make a function that generates a finite stream of numbers
          and a new generator like this:</p>
        <pre name="code" class="haskell:hs">finiteRandoms :: (RandomGen g, Random a, Num n) =&gt; n -&gt; g -&gt; ([a], g)
finiteRandoms 0 gen = ([], gen)
finiteRandoms n gen = 
    let (value, newGen) = random gen
        (restOfList, finalGen) = finiteRandoms (n-1) newGen
    in  (value:restOfList, finalGen)
</pre>
        <p>Again, a recursive definition. We say that if we want 0 numbers, we
          just return an empty list and the generator that was given to us. For
          any other number of random values, we first get one random number and
          a new generator. That will be the head. Then we say that the tail will
          be <i>n - 1</i> numbers generated with the new generator. Then we
          return the head and the rest of the list joined and the final
          generator that we got from getting the <i>n - 1</i> random numbers.</p>
        <p>What if we want a random value in some sort of range? All the random
          integers so far were outrageously big or small. What if we want to to
          throw a die? Well, we use <span class="label function">randomR</span>
          for that purpose. It has a type of <span class="fixed">randomR ::
            (RandomGen g, Random a) :: (a, a) -&gt; g -&gt; (a, g)</span>,
          meaning that it's kind of like <span class="fixed">random</span>,
          only it takes as its first parameter a pair of values that set the
          lower and upper bounds and the final value produced will be within
          those bounds.</p>
        <p> </p>
        <pre name="code" class="haskell:hs">ghci&gt; randomR (1,6) (mkStdGen 359353)
(6,1494289578 40692)
ghci&gt; randomR (1,6) (mkStdGen 35935335)
(3,1250031057 40692)
</pre>
        <p>There's also <span class="label function">randomRs</span>, which
          produces a stream of random values within our defined ranges. Check
          this out:</p>
        <pre name="code" class="haskell:hs">ghci&gt; take 10 $ randomRs ('a','z') (mkStdGen 3) :: [Char]
"ndkxbvmomg"
</pre>
        <p>Nice, looks like a super secret password or something.</p>
        <p>You may be asking yourself, what does this section have to do with
          I/O anyway? We haven't done anything concerning I/O so far. Well, so
          far we've always made our random number generator manually by making
          it with some arbitrary integer. The problem is, if we do that in our
          real programs, they will always return the same random numbers, which
          is no good for us. That's why <span class="fixed">System.Random</span>
          offers the <span class="label function">getStdGen</span> I/O action,
          which has a type of <span class="fixed">IO StdGen</span>. When your
          program starts, it asks the system for a good random number generator
          and stores that in a so called global generator. <span class="fixed">getStdGen</span>
          fetches you that global random generator when you bind it to
          something. </p>
        <p>Here's a simple program that generates a random string.</p>
        <pre name="code" class="haskell:hs">import System.Random

main = do
    gen &lt;- getStdGen
    putStr $ take 20 (randomRs ('a','z') gen)
</pre>
        <pre name="code" class="plain">$ runhaskell random_string.hs
pybphhzzhuepknbykxhe
$ runhaskell random_string.hs
eiqgcxykivpudlsvvjpg
$ runhaskell random_string.hs
nzdceoconysdgcyqjruo
$ runhaskell random_string.hs
bakzhnnuzrkgvesqplrx
</pre>
        <p>Be careful though, just performing <span class="fixed">getStdGen</span>
          twice will ask the system for the same global generator twice. If you
          do this:</p>
        <pre name="code" class="haskell:hs">import System.Random

main = do
    gen &lt;- getStdGen
    putStrLn $ take 20 (randomRs ('a','z') gen)
    gen2 &lt;- getStdGen
    putStr $ take 20 (randomRs ('a','z') gen2)
</pre>
        <p>you will get the same string printed out twice! One way to get two
          different strings of length 20 is to set up an infinite stream and
          then take the first 20 characters and print them out in one line and
          then take the second set of 20 characters and print them out in the
          second line. For this, we can use the <span class="fixed">splitAt</span>
          function from <span class="fixed">Data.List</span>, which splits a
          list at some index and returns a tuple that has the first part as the
          first component and the second part as the second component.</p>
        <pre name="code" class="haskell:hs">import System.Random
import Data.List

main = do
    gen &lt;- getStdGen
    let randomChars = randomRs ('a','z') gen
        (first20, rest) = splitAt 20 randomChars
        (second20, _) = splitAt 20 rest
    putStrLn first20
    putStr second20
</pre>
        <p>Another way is to use the <span class="label function">newStdGen</span>
          action, which splits our current random generator into two generators.
          It updates the global random generator with one of them and
          encapsulates the other as its result.</p>
        <pre name="code" class="haskell:hs">import System.Random

main = do   
    gen &lt;- getStdGen   
    putStrLn $ take 20 (randomRs ('a','z') gen)   
    gen' &lt;- newStdGen
    putStr $ take 20 (randomRs ('a','z') gen')   
</pre>
        <p>Not only do we get a new random generator when we bind <span class="fixed">newStdGen</span>
          to something, the global one gets updated as well, so if we do <span
            class="fixed">getStdGen</span> again and bind it to something, we'll
          get a generator that's not the same as <span class="fixed">gen</span>.</p>
        <p>Here's a little program that will make the user guess which number
          it's thinking of.</p>
        <pre name="code" class="haskell:hs">import System.Random
import Control.Monad(when)

main = do
    gen &lt;- getStdGen
    askForNumber gen

askForNumber :: StdGen -&gt; IO ()
askForNumber gen = do
    let (randNumber, newGen) = randomR (1,10) gen :: (Int, StdGen)
    putStr "Which number in the range from 1 to 10 am I thinking of? "
    numberString &lt;- getLine
    when (not $ null numberString) $ do
        let number = read numberString
        if randNumber == number 
            then putStrLn "You are correct!"
            else putStrLn $ "Sorry, it was " ++ show randNumber
        askForNumber newGen
</pre> <img src="http://s3.amazonaws.com/lyah/jackofdiamonds.png" alt="jack of diamonds"
          class="left" height="280" width="313">
        <p>We make a function <span class="fixed">askForNumber</span>, which
          takes a random number generator and returns an I/O action that will
          prompt the user for a number and tell him if he guessed it right. In
          that function, we first generate a random number and a new generator
          based on the generator that we got as a parameter and call them <span
            class="fixed">randNumber</span> and <span class="fixed">newGen</span>.
          Let's say that the number generated was <span class="fixed">7</span>.
          Then we tell the user to guess which number we're thinking of. We
          perform <span class="fixed">getLine</span> and bind its result to <span
            class="fixed">numberString</span>. When the user enters <span class="fixed">7</span>,
          <span class="fixed">numberString</span> becomes <span class="fixed">"7"</span>.
          Next, we use <span class="fixed">when</span> to check if the string
          the user entered is an empty string. If it is, an empty I/O action of
          <span class="fixed">return ()</span> is performed, which effectively
          ends the program. If it isn't, the action consisting of that <i>do</i>
          block right there gets performed. We use <span class="fixed">read</span>
          on <span class="fixed">numberString</span> to convert it to a number,
          so <span class="fixed">number</span> is now <span class="fixed">7</span>.</p>
        <div class="hintbox"><b>Excuse me!</b> If the user gives us some input
          here that <span class="fixed">read</span> can't read (like <span class="fixed">"haha"</span>),
          our program will crash with an ugly error message. If you don't want
          your program to crash on erronous input, use <span class="label function">reads</span>,
          which returns an empty list when it fails to read a string. When it
          succeeds, it returns a singleton list with a tuple that has our
          desired value as one component and a string with what it didn't
          consume as the other.</div>
        <p>We check if the number that we entered is equal to the one generated
          randomly and give the user the appropriate message. And then we call <span
            class="fixed">askForNumber</span> recursively, only this time with
          the new generator that we got, which gives us an I/O action that's
          just like the one we performed, only it depends on a different
          generator and we perform it.</p>
        <p><span class="fixed">main</span> consists of just getting a random
          generator from the system and calling <span class="fixed">askForNumber</span>
          with it to get the initial action.</p>
        <p>Here's our program in action!</p>
        <pre name="code" class="plain">$ runhaskell guess_the_number.hs
Which number in the range from 1 to 10 am I thinking of? 4
Sorry, it was 3
Which number in the range from 1 to 10 am I thinking of? 10
You are correct!
Which number in the range from 1 to 10 am I thinking of? 2
Sorry, it was 4
Which number in the range from 1 to 10 am I thinking of? 5
Sorry, it was 10
Which number in the range from 1 to 10 am I thinking of?

</pre>
        <p>Another way to make this same program is like this:</p>
        <pre name="code" class="haskell:hs">import System.Random
import Control.Monad(when)

main = do
    gen &lt;- getStdGen
    let (randNumber, _) = randomR (1,10) gen :: (Int, StdGen)   
    putStr "Which number in the range from 1 to 10 am I thinking of? "
    numberString &lt;- getLine
    when (not $ null numberString) $ do
        let number = read numberString
        if randNumber == number
            then putStrLn "You are correct!"
            else putStrLn $ "Sorry, it was " ++ show randNumber
        newStdGen
        main
</pre>
        <p>It's very similar to the previous version, only instead of making a
          function that takes a generator and then calls itself recursively with
          the new updated generator, we do all the work in <span class="fixed">main</span>.
          After telling the user whether they were correct in their guess or
          not, we update the global generator and then call <span class="fixed">main</span>
          again. Both approaches are valid but I like the first one more since
          it does less stuff in <span class="fixed">main</span> and also
          provides us with a function that we can reuse easily.</p>
        <a name="bytestrings"></a>
        <h2>Bytestrings</h2>
        <img src="http://s3.amazonaws.com/lyah/chainchomp.png" alt="like normal string, only they byte ... what a pedestrian pun this is"
          class="right" height="390" width="306">
        <p>Lists are a cool and useful data structure. So far, we've used them
          pretty much everywhere. There are a multitude of functions that
          operate on them and Haskell's laziness allows us to exchange the for
          and while loops of other languages for filtering and mapping over
          lists, because evaluation will only happen once it really needs to, so
          things like infinite lists (and even infinite lists of infinite
          lists!) are no problem for us. That's why lists can also be used to
          represent streams, either when reading from the standard input or when
          reading from files. We can just open a file and read it as a string,
          even though it will only be accessed when the need arises.</p>
        <p>However, processing files as strings has one drawback: it tends to be
          slow. As you know, <span class="fixed">String</span> is a type
          synonym for <span class="fixed">[Char]</span>. <span class="fixed">Char</span>s
          don't have a fixed size, because it takes several bytes to represent a
          character from, say, Unicode. Furthemore, lists are really lazy. If
          you have a list like <span class="fixed">[1,2,3,4]</span>, it will be
          evaluated only when completely necessary. So the whole list is sort of
          a promise of a list. Remember that <span class="fixed">[1,2,3,4]</span>
          is syntactic sugar for <span class="fixed">1:2:3:4:[]</span>. When
          the first element of the list is forcibly evaluated (say by printing
          it), the rest of the list <span class="fixed">2:3:4:[]</span> is
          still just a promise of a list, and so on. So you can think of lists
          as promises that the next element will be delivered once it really has
          to and along with it, the promise of the element after it. It doesn't
          take a big mental leap to conclude that processing a simple list of
          numbers as a series of promises might not be the most efficient thing
          in the world.</p>
        <p>That overhead doesn't bother us so much most of the time, but it
          turns out to be a liability when reading big files and manipulating
          them. That's why Haskell has <em>bytestrings</em>. Bytestrings are
          sort of like lists, only each element is one byte (or 8 bits) in size.
          The way they handle laziness is also different. </p>
        <p>Bytestrings come in two flavors: strict and lazy ones. Strict
          bytestrings reside in <span class="fixed">Data.ByteString</span> and
          they do away with the laziness completely. There are no promises
          involved; a strict bytestring represents a series of bytes in an
          array. You can't have things like infinite strict bytestrings. If you
          evaluate the first byte of a strict bytestring, you have to evaluate
          it whole. The upside is that there's less overhead because there are
          no thunks (the technical term for <i>promise</i>) involved. The
          downside is that they're likely to fill your memory up faster because
          they're read into memory at once.</p>
        <p>The other variety of bytestrings resides in <span class="fixed">Data.ByteString.Lazy</span>.
          They're lazy, but not quite as lazy as lists. Like we said before,
          there are as many thunks in a list as there are elements. That's what
          makes them kind of slow for some purposes. Lazy bytestrings take a
          different approach — they are stored in chunks (not to be confused
          with thunks!), each chunk has a size of 64K. So if you evaluate a byte
          in a lazy bytestring (by printing it or something), the first 64K will
          be evaluated. After that, it's just a promise for the rest of the
          chunks. Lazy bytestrings are kind of like lists of strict bytestrings
          with a size of 64K. When you process a file with lazy bytestrings, it
          will be read chunk by chunk. This is cool because it won't cause the
          memory usage to skyrocket and the 64K probably fits neatly into your
          CPU's L2 cache.</p>
        <p>If you look through the <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html">documentation</a>
          for <span class="fixed">Data.ByteString.Lazy</span>, you'll see that
          it has a lot of functions that have the same names as the ones from <span
            class="fixed">Data.List</span>, only the type signatures have <span
            class="fixed">ByteString</span> instead of <span class="fixed">[a]</span>
          and <span class="fixed">Word8</span> instead of <span class="fixed">a</span>
          in them. The functions with the same names mostly act the same as the
          ones that work on lists. Because the names are the same, we're going
          to do a qualified import in a script and then load that script into
          GHCI to play with bytestrings. </p>
        <pre name="code" class="haskell:hs">import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString as S
</pre>
        <p><span class="fixed">B</span> has lazy bytestring types and functions,
          whereas <span class="fixed">S</span> has strict ones. We'll mostly be
          using the lazy version.</p>
        <p>The function <span class="function label">pack</span> has the type
          signature <span class="fixed">pack :: [Word8] -&gt; ByteString</span>.
          What that means is that it takes a list of bytes of type <span class="fixed">Word8</span>
          and returns a <span class="fixed">ByteString</span>. You can think of
          it as taking a list, which is lazy, and making it less lazy, so that
          it's lazy only at 64K intervals.</p>
        <p>What's the deal with that <span class="fixed">Word8</span> type?
          Well, it's like <span class="fixed">Int</span>, only that it has a
          much smaller range, namely 0-255. It represents an 8-bit number. And
          just like <span class="fixed">Int</span>, it's in the <span class="fixed">Num</span>
          typeclass. For instance, we know that the value <span class="fixed">5</span>
          is polymorphic in that it can act like any numeral type. Well, it can
          also take the type of <span class="fixed">Word8</span>.</p>
        <pre name="code" class="haskell:hs">ghci&gt; B.pack [99,97,110]
Chunk "can" Empty
ghci&gt; B.pack [98..120]
Chunk "bcdefghijklmnopqrstuvwx" Empty
</pre>
        <p>As you can see, you usually don't have to worry about the <span class="fixed">Word8</span>
          too much, because the type system can makes the numbers choose that
          type. If you try to use a big number, like <span class="fixed">336</span>
          as a <span class="fixed">Word8</span>, it will just wrap around to <span
            class="fixed">80</span>.</p>
        <p>We packed only a handful of values into a <span class="fixed">ByteString</span>,
          so they fit inside one chunk. The <span class="fixed">Empty</span> is
          like the <span class="fixed">[]</span> for lists.</p>
        <p><span class="label function">unpack</span> is the inverse function of
          <span class="fixed">pack</span>. It takes a bytestring and turns it
          into a list of bytes.</p>
        <p><span class="label function">fromChunks</span> takes a list of strict
          bytestrings and converts it to a lazy bytestring. <span class="label function">toChunks</span>
          takes a lazy bytestring and converts it to a list of strict ones.</p>
        <pre name="code" class="haskell:hs">ghci&gt; B.fromChunks [S.pack [40,41,42], S.pack [43,44,45], S.pack [46,47,48]]
Chunk "()*" (Chunk "+,-" (Chunk "./0" Empty))
</pre>
        <p>This is good if you have a lot of small strict bytestrings and you
          want to process them efficiently without joining them into one big
          strict bytestring in memory first.</p>
        <p>The bytestring version of <span class="fixed">:</span> is called <span
            class="label function">cons</span> It takes a byte and a bytestring
          and puts the byte at the beginning. It's lazy though, so it will make
          a new chunk even if the first chunk in the bytestring isn't full.
          That's why it's better to use the strict version of <span class="fixed">cons</span>,
          <span class="label function">cons'</span> if you're going to be
          inserting a lot of bytes at the beginning of a bytestring.</p>
        <pre name="code" class="haskell:hs">ghci&gt; B.cons 85 $ B.pack [80,81,82,84]
Chunk "U" (Chunk "PQRT" Empty)
ghci&gt; B.cons' 85 $ B.pack [80,81,82,84]
Chunk "UPQRT" Empty
ghci&gt; foldr B.cons B.empty [50..60]
Chunk "2" (Chunk "3" (Chunk "4" (Chunk "5" (Chunk "6" (Chunk "7" (Chunk "8" (Chunk "9" (Chunk ":" (Chunk ";" (Chunk "&lt;"
Empty))))))))))
ghci&gt; foldr B.cons' B.empty [50..60]
Chunk "23456789:;&lt;" Empty
</pre>
        <p>As you can see <span class="label function">empty</span> makes an
          empty bytestring. See the difference between <span class="fixed">cons</span>
          and <span class="fixed">cons'</span>? With the <span class="fixed">foldr</span>,
          we started with an empty bytestring and then went over the list of
          numbers from the right, adding each number to the beginning of the
          bytestring. When we used <span class="fixed">cons</span>, we ended up
          with one chunk for every byte, which kind of defeats the purpose.</p>
        <p>Otherwise, the bytestring modules have a load of functions that are
          analogous to those in <span class="fixed">Data.List</span>,
          including, but not limited to, <span class="fixed">head</span>, <span
            class="fixed">tail</span>, <span class="fixed">init</span>, <span
            class="fixed">null</span>, <span class="fixed">length</span>, <span
            class="fixed">map</span>, <span class="fixed">reverse</span>, <span
            class="fixed">foldl</span>, <span class="fixed">foldr</span>, <span
            class="fixed">concat</span>, <span class="fixed">takeWhile</span>,
          <span class="fixed">filter</span>, etc. </p>
        <p>It also has functions that have the same name and behave the same as
          some functions found in <span class="fixed">System.IO</span>, only <span
            class="fixed">String</span>s are replaced with <span class="fixed">ByteString</span>s.
          For instance, the <span class="fixed">readFile</span> function in <span
            class="fixed">System.IO</span> has a type of <span class="fixed">readFile
            :: FilePath -&gt; IO String</span>, while the <span class="label function">readFile</span>
          from the bytestring modules has a type of <span class="fixed">readFile
            :: FilePath -&gt; IO ByteString</span>. Watch out, if you're using
          strict bytestrings and you attempt to read a file, it will read it
          into memory at once! With lazy bytestrings, it will read it into neat
          chunks.</p>
        <p>Let's make a simple program that takes two filenames as command-line
          arguments and copies the first file into the second file. Note that <span
            class="fixed">System.Directory</span> already has a function called
          <span class="fixed">copyFile</span>, but we're going to implement our
          own file copying function and program anyway.</p>
        <pre name="code" class="haskell:hs">import System.Environment
import qualified Data.ByteString.Lazy as B

main = do
    (fileName1:fileName2:_) &lt;- getArgs
    copyFile fileName1 fileName2

copyFile :: FilePath -&gt; FilePath -&gt; IO ()
copyFile source dest = do
    contents &lt;- B.readFile source
    B.writeFile dest contents
</pre>
        <p>We make our own function that takes two <span class="fixed">FilePath</span>s
          (remember, <span class="fixed">FilePath</span> is just a synonym for
          <span class="fixed">String</span>) and returns an I/O action that will
          copy one file into another using bytestring. In the <span class="fixed">main</span>
          function, we just get the arguments and call our function with them to
          get the I/O action, which is then performed.</p>
        <pre name="code" class="plain">$ runhaskell bytestringcopy.hs something.txt ../../something.txt
</pre>
        <p>Notice that a program that doesn't use bytestrings could look just
          like this, the only difference is that we used <span class="fixed">B.readFile</span>
          and <span class="fixed">B.writeFile</span> instead of <span class="fixed">readFile</span>
          and <span class="fixed">writeFile</span>. Many times, you can convert
          a program that uses normal strings to a program that uses bytestrings
          by just doing the necessary imports and then putting the qualified
          module names in front of some functions. Sometimes, you have to
          convert functions that you wrote to work on strings so that they work
          on bytestrings, but that's not hard.</p>
        <p>Whenever you need better performance in a program that reads a lot of
          data into strings, give bytestrings a try, chances are you'll get some
          good performance boosts with very little effort on your part. I
          usually write programs by using normal strings and then convert them
          to use bytestrings if the performance is not satisfactory.</p>
        <a name="exceptions"></a>
        <h2>예외</h2>
        <img src="http://s3.amazonaws.com/lyah/timber.png" class="left" alt="timberr!!!!"
          height="394" width="308">
        <p>All languages have procedures, functions, and pieces of code that
          might fail in some way. That's just a fact of life. Different
          languages have different ways of handling those failures. In C, we
          usually use some abnormal return value (like <span class="fixed">-1</span>
          or a null pointer) to indicate that what a function returned shouldn't
          be treated like a normal value. Java and C#, on the other hand, tend
          to use exceptions to handle failure. When an exception is thrown, the
          control flow jumps to some code that we've defined that does some
          cleanup and then maybe re-throws the exception so that some other
          error handling code can take care of some other stuff.</p>
        <p>Haskell has a very good type system. Algebraic data types allow for
          types like <span class="fixed">Maybe</span> and <span class="fixed">Either</span>
          and we can use values of those types to represent results that may be
          there or not. In C, returning, say, <span class="fixed">-1</span> on
          failure is completely a matter of convention. It only has special
          meaning to humans. If we're not careful, we might treat these abnormal
          values as ordinary ones and then they can cause havoc and dismay in
          our code. Haskell's type system gives us some much-needed safety in
          that aspect. A function <span class="fixed">a -&gt; Maybe b</span>
          clearly indicates that it it may produce a <span class="fixed">b</span>
          wrapped in <span class="fixed">Just</span> or that it may return <span
            class="fixed">Nothing</span>. The type is different from just plain
          <span class="fixed">a -&gt; b</span> and if we try to use those two
          functions interchangeably, the compiler will complain at us.</p>
        <p>Despite having expressive types that support failed computations,
          Haskell still has support for exceptions, because they make more sense
          in I/O contexts. A lot of things can go wrong when dealing with the
          outside world because it is so unreliable. For instance, when opening
          a file, a bunch of things can go wrong. The file might be locked, it
          might not be there at all or the hard disk drive or something might
          not be there at all. So it's good to be able to jump to some error
          handling part of our code when such an error occurs.</p>
        <p>Okay, so I/O code (i.e. impure code) can throw exceptions. It makes
          sense. But what about pure code? Well, it can throw exceptions too.
          Think about the <span class="fixed">div</span> and <span class="fixed">head</span>
          functions. They have types of <span class="fixed">(Integral a) =&gt;
            a -&gt; a -&gt; a</span> and <span class="fixed">[a] -&gt; a</span>,
          respectively. No <span class="fixed">Maybe</span> or <span class="fixed">Either</span>
          in their return type and yet they can both fail! <span class="fixed">div</span>
          explodes in your face if you try to divide by zero and <span class="fixed">head</span>
          throws a tantrum when you give it an empty list.</p>
        <pre name="code" class="haskell:hs">ghci&gt; 4 `div` 0
*** Exception: divide by zero
ghci&gt; head []
*** Exception: Prelude.head: empty list
</pre> <img src="http://s3.amazonaws.com/lyah/police.png" alt="Stop right there, criminal scum! Nobody breaks the law on my watch! Now pay your fine or it's off to jail."
          class="left" height="328" width="241">
        <p>Pure code can throw exceptions, but it they can only be caught in the
          I/O part of our code (when we're inside a <i>do</i> block that goes
          into <span class="fixed">main</span>). That's because you don't know
          when (or if) anything will be evaluated in pure code, because it is
          lazy and doesn't have a well-defined order of execution, whereas I/O
          code does.</p>
        <p>Earlier, we talked about how we should spend as little time as
          possible in the I/O part of our program. The logic of our program
          should reside mostly within our pure functions, because their results
          are dependant only on the parameters that the functions are called
          with. When dealing with pure functions, you only have to think about
          what a function returns, because it can't do anything else. This makes
          your life easier. Even though doing some logic in I/O is necessary
          (like opening files and the like), it should preferably be kept to a
          minimum. Pure functions are lazy by default, which means that we don't
          know when they will be evaluated and that it really shouldn't matter.
          However, once pure functions start throwing exceptions, it matters
          when they are evaluated. That's why we can only catch exceptions
          thrown from pure functions in the I/O part of our code. And that's
          bad, because we want to keep the I/O part as small as possible.
          However, if we don't catch them in the I/O part of our code, our
          program crashes. The solution? Don't mix exceptions and pure code.
          Take advantage of Haskell's powerful type system and use types like <span
            class="fixed">Either</span> and <span class="fixed">Maybe</span> to
          represent results that may have failed.</p>
        <p>That's why we'll just be looking at how to use I/O exceptions for
          now. I/O exceptions are exceptions that are caused when something goes
          wrong while we are communicating with the outside world in an I/O
          action that's part of <span class="fixed">main</span>. For example,
          we can try opening a file and then it turns out that the file has been
          deleted or something. Take a look at this program that opens a file
          whose name is given to it as a command line argument and tells us how
          many lines the file has.</p>
        <pre name="code" class="haskell:hs">import System.Environment
import System.IO

main = do (fileName:_) &lt;- getArgs
          contents &lt;- readFile fileName
          putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"
</pre>
        <p>A very simple program. We perform the <span class="fixed">getArgs</span>
          I/O action and bind the first string in the list that it yields to <span
            class="fixed">fileName</span>. Then we call the contents of the file
          with that name <span class="fixed">contents</span>. Lastly, we apply
          <span class="fixed">lines</span> to those contents to get a list of
          lines and then we get the length of that list and give it to <span class="fixed">show</span>
          to get a string representation of that number. It works as expected,
          but what happens when we give it the name of a file that doesn't
          exist?</p>
        <pre name="code" class="plain">$ runhaskell linecount.hs i_dont_exist.txt
linecount.hs: i_dont_exist.txt: openFile: does not exist (No such file or directory)
</pre>
        <p>Aha, we get an error from GHC, telling us that the file does not
          exist. Our program crashes. What if we wanted to print out a nicer
          message if the file doesn't exist? One way to do that is to check if
          the file exists before trying to open it by using the <span class="label function">doesFileExist</span>
          function from <span class="fixed">System.Directory</span>.</p>
        <pre name="code" class="haskell:hs">import System.Environment
import System.IO
import System.Directory

main = do (fileName:_) &lt;- getArgs
          fileExists &lt;- doesFileExist fileName
          if fileExists
              then do contents &lt;- readFile fileName
                      putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"
              else do putStrLn "The file doesn't exist!"
</pre>
        <p>We did <span class="fixed">fileExists &lt;- doesFileExist fileName</span>
          because <span class="fixed">doesFileExist</span> has a type of <span
            class="fixed">doesFileExist :: FilePath -&gt; IO Bool</span>, which
          means that it returns an I/O action that has as its result a boolean
          value which tells us if the file exists. We can't just use <span class="fixed">doesFileExist</span>
          in an <i>if</i> expression directly.</p>
        <p>Another solution here would be to use exceptions. It's perfectly
          acceptable to use them in this context. A file not existing is an
          exception that arises from I/O, so catching it in I/O is fine and
          dandy.</p>
        <p>To deal with this by using exceptions, we're going to take advantage
          of the <span class="label function">catch</span> function from <span
            class="fixed">System.IO.Error</span>. Its type is <span class="fixed">catch
            :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a</span>. It takes two
          parameters. The first one is an I/O action. For instance, it could be
          an I/O action that tries to open a file. The second one is the
          so-called handler. If the first I/O action passed to <span class="fixed">catch</span>
          throws an I/O exception, that exception gets passed to the handler,
          which then decides what to do. So the final result is an I/O action
          that will either act the same as the first parameter or it will do
          what the handler tells it if the first I/O action throws an exception.</p>
        <img src="http://s3.amazonaws.com/lyah/puppy.png" alt="non sequitor" class="right"
          height="240" width="334">
        <p>If you're familiar with <i>try-catch</i> blocks in languages like
          Java or Python, the <span class="fixed">catch</span> function is
          similar to them. The first parameter is the thing to try, kind of like
          the stuff in the <i>try</i> block in other, imperative languages. The
          second parameter is the handler that takes an exception, just like
          most <i>catch</i> blocks take exceptions that you can then examine to
          see what happened. The handler is invoked if an exception is thrown.</p>
        <p>The handler takes a value of type <span class="fixed">IOError</span>,
          which is a value that signifies that an I/O exception occurred. It
          also carries information regarding the type of the exception that was
          thrown. How this type is implemented depends on the implementation of
          the language itself, which means that we can't inspect values of the
          type <span class="fixed">IOError</span> by pattern matching against
          them, just like we can't pattern match against values of type <span class="fixed">IO
            <i>something</i></span>. We can use a bunch of useful predicates to
          find out stuff about values of type <span class="fixed">IOError</span>
          as we'll learn in a second.</p>
        <p>So let's put our new friend <span class="fixed">catch</span> to use!</p>
        <pre name="code" class="haskell:hs">import System.Environment
import System.IO
import System.IO.Error

main = toTry `catch` handler
            
toTry :: IO ()
toTry = do (fileName:_) &lt;- getArgs
           contents &lt;- readFile fileName
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"

handler :: IOError -&gt; IO ()
handler e = putStrLn "Whoops, had some trouble!"
</pre>
        <p>First of all, you'll see that put backticks around it so that we can
          use it as an infix function, because it takes two parameters. Using it
          as an infix function makes it more readable. So <span class="fixed">toTry
            `catch` handler</span> is the same as <span class="fixed">catch
            toTry handler</span>, which fits well with its type. <span class="fixed">toTry</span>
          is the I/O action that we try to carry out and <span class="fixed">handler</span>
          is the function that takes an <span class="fixed">IOError</span> and
          returns an action to be carried out in case of an exception.</p>
        <p>Let's give this a go:</p>
        <pre name="code" class="plain">$ runhaskell count_lines.hs i_exist.txt
The file has 3 lines!

$ runhaskell count_lines.hs i_dont_exist.txt
Whoops, had some trouble!
</pre>
        <p>In the handler, we didn't check to see what kind of <span class="fixed">IOError</span>
          we got. We just say <span class="fixed">"Whoops, had some trouble!"</span>
          for any kind of error. Just catching all types of exceptions in one
          handler is bad practice in Haskell just like it is in most other
          languages. What if some other exception happens that we don't want to
          catch, like us interrupting the program or something? That's why we're
          going to do the same thing that's usually done in other languages as
          well: we'll check to see what kind of exception we got. If it's the
          kind of exception we're waiting to catch, we do our stuff. If it's
          not, we throw that exception back into the wild. Let's modify our
          program to catch only the exceptions caused by a file not existing.</p>
        <pre name="code" class="haskell:hs">import System.Environment
import System.IO
import System.IO.Error

main = toTry `catch` handler
            
toTry :: IO ()
toTry = do (fileName:_) &lt;- getArgs
           contents &lt;- readFile fileName
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"

handler :: IOError -&gt; IO ()
handler e
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"
    | otherwise = ioError e
</pre>
        <p>Everything stays the same except the handler, which we modified to
          only catch a certain group of I/O exceptions. Here we used two new
          functions from <span class="fixed">System.IO.Error</span> — <span class="label function">isDoesNotExistError</span>
          and <span class="label function">ioError</span>. <span class="fixed">isDoesNotExistError</span>
          is a predicate over <span class="fixed">IOError</span>s, which means
          that it's a function that takes an <span class="fixed">IOError</span>
          and returns a <span class="fixed">True</span> or <span class="fixed">False</span>,
          meaning it has a type of <span class="fixed">isDoesNotExistError ::
            IOError -&gt; Bool</span>. We use it on the exception that gets
          passed to our handler to see if it's an error caused by a file not
          existing. We use <a href="syntax-in-functions#guards-guards">guard</a>
          syntax here, but we could have also used an <i>if else</i>. If it's
          not caused by a file not existing, we re-throw the exception that was
          passed by the handler with the <span class="fixed">ioError</span>
          function. It has a type of <span class="fixed">ioError :: IOException
            -&gt; IO a</span>, so it takes an <span class="fixed">IOError</span>
          and produces an I/O action that will throw it. The I/O action has a
          type of <span class="fixed">IO a</span>, because it never actually
          yields a result, so it can act as <span class="fixed">IO <i>anything</i></span>.</p>
        <p>So the exception thrown in the <span class="fixed">toTry</span> I/O
          action that we glued together with a <i>do</i> block isn't caused by
          a file existing, <span class="fixed">toTry `catch` handler</span>
          will catch that and then re-throw it. Pretty cool, huh?</p>
        <p>There are several predicates that act on <span class="fixed">IOError</span>
          and if a guard doesn't evaluate to <span class="fixed">True</span>,
          evaluation falls through to the next guard. The predicates that act on
          <span class="fixed">IOError</span> are:</p>
        <ul>
          <li><span class="function label">isAlreadyExistsError</span></li>
          <li><span class="function label">isDoesNotExistError</span></li>
          <li><span class="function label">isAlreadyInUseError</span></li>
          <li><span class="function label">isFullError</span></li>
          <li><span class="function label">isEOFError</span></li>
          <li><span class="function label">isIllegalOperation</span></li>
          <li><span class="function label">isPermissionError</span></li>
          <li><span class="function label">isUserError</span></li>
        </ul>
        <p>Most of these are pretty self-explanatory. <span class="fixed">isUserError</span>
          evaluates to <span class="fixed">True</span> when we use the function
          <span class="label function">userError</span> to make the exception,
          which is used for making exceptions from our code and equipping them
          with a string. For instance, you can do <span class="fixed">ioError $
            userError "remote computer unplugged!"</span>, although It's
          prefered you use types like <span class="fixed">Either</span> and <span
            class="fixed">Maybe</span> to express possible failure instead of
          throwing exceptions yourself with <span class="fixed">userError</span>.</p>
        <p>So you could have a handler that looks something like this:</p>
        <pre name="code" class="haskell:hs">handler :: IOError -&gt; IO ()
handler e
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"
    | isFullError e = freeSomeSpace
    | isIllegalOperation e = notifyCops
    | otherwise = ioError e
</pre>
        <p>Where <span class="fixed">notifyCops</span> and <span class="fixed">freeSomeSpace</span>
          are some I/O actions that you define. Be sure to re-throw exceptions
          if they don't match any of your criteria, otherwise you're causing
          your program to fail silently in some cases where it shouldn't.</p>
        <p><span class="fixed">System.IO.Error</span> also exports functions
          that enable us to ask our exceptions for some attributes, like what
          the handle of the file that caused the error is, or what the filename
          is. These start with <span class="fixed">ioe</span> and you can see a
          <a href="http://www.haskell.org/ghc/docs/6.10.1/html/libraries/base/System-IO-Error.html#3">full
            list of them</a> in the documentation. Say we want to print the
          filename that caused our error. We can't print the <span class="fixed">fileName</span>
          that we got from <span class="fixed">getArgs</span>, because only the
          <span class="fixed">IOError</span> is passed to the handler and the
          handler doesn't know about anything else. A function depends only on
          the parameters it was called with. That's why we can use the <span class="label function">ioeGetFileName</span>
          function, which has a type of <span class="fixed">ioeGetFileName ::
            IOError -&gt; Maybe FilePath</span>. It takes an <span class="fixed">IOError</span>
          as a parameter and maybe returns a <span class="fixed">FilePath</span>
          (which is just a type synonym for <span class="fixed">String</span>,
          remember, so it's kind of the same thing). Basically, what it does is
          it extracts the file path from the <span class="fixed">IOError</span>,
          if it can. Let's modify our program to print out the file path that's
          responsible for the exception occurring. </p>
        <pre name="code" class="haskell:hs">import System.Environment   
import System.IO   
import System.IO.Error   
  
main = toTry `catch` handler   
               
toTry :: IO ()   
toTry = do (fileName:_) &lt;- getArgs   
           contents &lt;- readFile fileName   
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"   
  
handler :: IOError -&gt; IO ()   
handler e   
    | isDoesNotExistError e = 
        case ioeGetFileName e of Just path -&gt; putStrLn $ "Whoops! File does not exist at: " ++ path
                                 Nothing -&gt; putStrLn "Whoops! File does not exist at unknown location!"
    | otherwise = ioError e   
</pre>
        <p>In the guard where <span class="fixed">isDoesNotExistError</span> is
          <span class="fixed">True</span>, we used a <i>case</i> expression to
          call <span class="fixed">ioeGetFileName</span> with <span class="fixed">e</span>
          and then pattern match against the <span class="fixed">Maybe</span>
          value that it returned. Using <i>case</i> expressions is commonly
          used when you want to pattern match against something without bringing
          in a new function.</p>
        <p>You don't have to use one handler to <span class="fixed">catch</span>
          exceptions in your whole I/O part. You can just cover certain parts of
          your I/O code with <span class="fixed">catch</span> or you can cover
          several of them with <span class="fixed">catch</span> and use
          different handlers for them, like so:</p>
        <pre name="code" class="haskell:hs">main = do toTry `catch` handler1
          thenTryThis `catch` handler2
          launchRockets
</pre>
        <p>Here, <span class="fixed">toTry</span> uses <span class="fixed">handler1</span>
          as the handler and <span class="fixed">thenTryThis</span> uses <span
            class="fixed">handler2</span>. <span class="fixed">launchRockets</span>
          isn't a parameter to <span class="fixed">catch</span>, so whichever
          exceptions it might throw will likely crash our program, unless <span
            class="fixed">launchRockets</span> uses <span class="fixed">catch</span>
          internally to handle its own exceptions. Of course <span class="fixed">toTry</span>,
          <span class="fixed">thenTryThis</span> and <span class="fixed">launchRockets</span>
          are I/O actions that have been glued together using <i>do</i> syntax
          and hypothetically defined somewhere else. This is kind of similar to
          <i>try-catch</i> blocks of other languages, where you can surround
          your whole program in a single <i>try-catch</i> or you can use a more
          fine-grained approach and use different ones in different parts of
          your code to control what kind of error handling happens where.</p>
        <p>Now you know how to deal with I/O exceptions! Throwing exceptions
          from pure code and dealing with them hasn't been covered here, mainly
          because, like we said, Haskell offers much better ways to indicate
          errors than reverting to I/O to catch them. Even when glueing together
          I/O actions that might fail, I prefer to have their type be something
          like <span class="fixed">IO (Either a b)</span>, meaning that they're
          normal I/O actions but the result that they yield when performed is of
          type <span class="fixed">Either a b</span>, meaning it's either <span
            class="fixed">Left a</span> or <span class="fixed">Right b</span>.</p>
        <div class="footdiv">
          <ul>
            <li style="text-align:left"> <a href="making-our-own-types-and-typeclasses"
                class="prevlink">Making Our Own Types and Typeclasses</a> </li>
            <li style="text-align:center"> <a href="chapters">목 차<br>
              </a> </li>
            <li style="text-align:right"> <a href="functionally-solving-problems"
                class="nxtlink">Functionally Solving Problems</a> </li>
          </ul>
        </div>
      </div>
      <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
      <script type="text/javascript" src="shBrushHaskell.js"></script>
      <script type="text/javascript" src="shBrushPlain.js"></script>
      <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script> </div>
    <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script> </body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>Learn You a Haskell for Great Good! - Input and Output</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <base href="http://learnyouahaskell.com/">
    <style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style><link rel="shortcut icon" href="favicon.png" type="image/png">
    <link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
    <link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
  </head>
  <body class="introcontent">
    <div class="bgwrapper">
      <div id="content">
        <div class="footdiv" style="margin-bottom:25px;">
          <ul>
            <li style="text-align:left"> <a href="making-our-own-types-and-typeclasses"
                class="prevlink">Making Our Own Types and Typeclasses</a> </li>
            <li style="text-align:center"> <a href="chapters">목차</a> </li>
            <li style="text-align:right"> <a href="functionally-solving-problems"
                class="nxtlink">Functionally Solving Problems</a> </li>
          </ul>
        </div>
        <h1>입력과 출력<br>
        </h1>
        <img src="http://s3.amazonaws.com/lyah/dognap.png" alt="poor dog" class="right"
          height="382" width="261">
        <p>전에 제가 하스켈은 순수한 함수형 언어라고 했습니다. imperative 언어에선 컴퓨터에게 실행 단계를 나열하여 일을
          처리하는데 중점을 두지만, 함수형 프로그래밍에서는 어떠한 것을 정의하는 것에 더욱 중점을 줍니다. 하스켈에서 함수는 변수의
          내용을 바꾸는 것과 같은, 어떠한 상태를 변화시키지 않습니다 (상태를 변화시키는 함수를 가리켜, 부수효과(<i>side-effects)</i>를
          지녔다고 합니다). 하스켈에서 함수가 하는 일은 인자에 기반하여 어떠한 결과를 돌려주는 것입니다. 함수가 동일한 인자로
          호출된다면, 동일한 결과를 반환해야 합니다. imperative세계에서 온 여러분은 이를 조금 밖에 맛보진 못했지만, 이것이
          실제로 매우 멋지다는 것을 보았습니다. imperative 언어에서는, 어떠한 숫자를 처리하는 간단한 함수가 집을 태우거나,
          소중한 개를 납치하거나, 감자에 차가 흠집을 내지 않다라는것을 보장할 수 없습니다. 예를들어, 이진 탐색 트리를 만들려면, 그
          장소에서 바로 트리를 수정하여 원소를 삽입해서는 안됩니다. 이전것을 바꿔서는 안되기에, 이진 탐색 트리에 삽입하는 함수는
          새로운 트리를 반환하게 됩니다.</p>
        <p> 상태를 변화시키지 않는 함수가 프로그램을 분석하는데 있어 도움이 되지만, 문제가 하나 있습니다. 이 세계에서 함수가 어떠한
          것도 변화시키지 않는다면, 계산된 것을 어떻게 알려줄까요? 계산된 것을 알려주기 위해선, 출력 장치의 상태를 변화시켜(보통
          화면의 상태), 저희 머리속을 돌아 다니게될 광자를 배출해, 우리 사람의 생각을 변화시켜야 합니다.</p>
        <p>저희가 배운게 부질없는일이 아니니, 실망하지 마시기 바랍니다. 하스켈은 프로그램을 순수한 부분과 키보드나 화면을 다루는
          지저분한 부분으로 깔끔하게 나눔으로써, 부수효과를 지닌 함수를 다루는데 있어 아주 영리한 시스템을 지녔습니다. 이렇게 두
          부분으로 나눔으로써, 순수한 프로그램에 대해 사고할 수 있고, 외부 세계와 효율적으로 소통하면서 laziness,
          robustness, modularity와 같은 순수함이 제공하는 이점들을 취할 수 있습니다.</p>
        <a name="hello-world"></a>
        <h2>Hello, world!</h2>
        <img src="http://s3.amazonaws.com/lyah/helloworld.png" alt="HELLO!" class="left"
          height="179" width="223">
        <p>지금까지, 저희는 항상 GHCI에서 함수를 로드하여 테스트하였습니다. 또한 이러한 방식으로 표준 라이브러리 함수를
          살펴보았습니다. 하지만 지금부터는 <i>진짜</i> 하스켈 프로그램을 작성해 나갈 것입니다. 예! 두 말할것도 없이, 저희의
          오랜 친구 <span class="fixed">"hello, world"</span>부터 시작할 것입니다.</p>
        <div class="hintbox"><em>잠시만요!</em> 이번 장에선, 하스켈을 배우기 위해 유닉스 환경을 사용한다고
          가정할 것입니다. 윈도우 환경이라면, 리눅스와 유사한 환경을 제공해주는 <a href="http://www.cygwin.com/">Cygwin</a>을
          다운받는 것을 추천합니다.</div>
        <p>그럼 시작에 앞서, 다음 문장을 여러분이 선호하는 문서 편집기에 입력하시기 바랍니다:</p>
        <pre name="code" class="haskell:hs">main = putStrLn "hello, world"
</pre>
        <p><span class="fixed">main</span>이란 이름을 정의하였고, 내부에선 <span class="fixed">"hello,
            world"</span>를 인자로 갖는 <span class="fixed">putStrLn</span>를 호출하였습니다.
          지극히 평범해 보이지만, 잠시후 보시게될 것처럼 사실은 간단하지 않습니다. 이를 <span class="fixed">helloworld.hs</span>파
          일로 저장합시다.</p>
        <p>지금부터, 이제까지 해보지 못한 무언가를 해보겠습니다. 프로그램을 실제로 컴파일 해볼 것입니다! 터미널을 여시고, <span
            class="fixed">helloworld.hs</span>가 있는 폴더에 가서 다음을 실행합니다:</p>
        <pre name="code" class="plain">$ ghc --make helloworld
[1 of 1] Compiling Main             ( helloworld.hs, helloworld.o )
Linking helloworld ...
</pre>
        <p>좋습니다! 이와 같은 결과를 얻었다면, 한번 <span class="fixed">./helloworld</span>로
          프로그램을 돌려 봅시다.</p>
        <pre name="code" class="haskell:hs">$ ./helloworld
hello, world
</pre>
        <p> 성공적으로, 터미널에 무언가를 출력하는 프로그램을 컴파일 했습니다. 뭐 별로 특별한 것이 없습니다.</p>
        <p>작성한 것을 한번 분석해 봅시다. 우선, <span class="fixed">putStrLn</span>함수의 타입을
          살펴봅시다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; :t putStrLn
putStrLn :: String -&gt; IO ()
ghci&gt; :t putStrLn "hello, world"
putStrLn "hello, world" :: IO ()
</pre>
        <p><span class="fixed">putStrLn</span>타입을 다음과 같이 읽을 수 있습니다: <span class="fixed">putStrLn</span>은
          문자열을 받아 <span class="fixed">()</span>의 결과 타입(즉, unit으로 알려진 비어있는 튜플)을
          갖는 <em>I/O action</em>을 반환한다. I/O action은 매 수행마다, 부수효과를 가져다주며(이는 보통
          입력으로부터 무언가를 읽거나, 화면상에 무언가를 출력하는 것입니다.) 반환값을 내부에 저장합니다. 문자열을 터미널에 출력하는데
          있어 값을 반환하는 것은 별로 중요치 않기에, 더미 값인 <span class="fixed">()</span>을 이용합니다.</p>
        <div class="hintbox">비어있는 튜플의 값은 <span class="fixed">()</span>이며, 타입 또한
          <span class="fixed">()</span>입니다.</div>
        <p>그러면, I/O action은 언제 수행될까요? 음, 이는 <span class="fixed">main</span>에 왔을
          때 수행됩니다. I/O action은 <span class="fixed">main</span>이란 이름을 주고 프로그램을
          돌렸을때 수행됩니다.</p>
        <p>하나의 I/O action만을 갖는 프로그램은 제한되어 보입니다. 따라서 여러 I/O action들을 하나로 묶기 위해선 <i>do</i>
          문법을 이용해야 합니다. 다음 예제를 살펴봅시다:</p>
        <pre name="code" class="haskell:hs">main = do
    putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
</pre>
        <p>아, 흥미롭군요. 새로운 문법입니다! 그리고 이는 마치 imperative프로그램처럼 읽힙니다. 이를 컴파일 하고 돌려보면,
          아마 예상했던대로 수행할 것입니다. <i>do</i>라고 한 다음, imperative 프로그램처럼 여러 단계를 나열한 것에
          주목하시기 바랍니다. 이 각각의 단계가 I/O action입니다. 이를 do문법속에 넣음으로써, 하나의 I/O action으로
          묶었습니다. 내부 마지막 타입이 I/O action타입이기에, 저희가 얻게되는 action은 <span class="fixed">IO
            ()</span>타입을 가졌습니다.</p>
        <p>이러한 이유로, <span class="fixed"><i>something</i></span>을 어떠한 구체적인 타입이라고
          한다면, <span class="fixed">main</span>은 항상 <span class="fixed">main ::
            IO <i>something</i></span>타입 서명을 지녔습니다. 관례에 따라, 저희는 <span class="fixed">main</span>의
          타입 선언을 명시하지 않을 것입니다.</p>
        <p>세번째 줄 <span class="fixed">name &lt;- getLine</span>은 저희가 이제까지 만나보지
          못한 흥미로운 것입니다. 이는 입력장치에서 한 줄을 읽어, <span class="fixed">name</span>이 란
          변수에 저장하는 것처럼 보입니다. 실제로도 그러할까요? 흠, <span class="fixed">getLine</span>의
          타입을 살펴봅시다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; :t getLine
getLine :: IO String
</pre> <img src="http://s3.amazonaws.com/lyah/luggage.png" alt="luggage" class="left"
          height="200" width="204">
        <p>아하, 알겠습니다. <span class="fixed">getLine</span>은 <span class="fixed">String</span>을
          결과 타입으로 갖는 I/O action입니다. 터미널에서 사용자로부터 무언가를 입력받기위해 기다리며, 후에 그 무언가를
          문자열로 출력하기 때문입니다. 그럼, <span class="fixed">name &lt;- getLine</span>가
          하는 일은 도대체 무엇일까요? 다음과 같이 생각할 수 있겠습니다: <em>I/O action <span class="fixed">getLine</span>을
            수행하고, 결과 값을 </em><em><span class="fixed">name</span></em><em>에 넣어라</em>.
          <span class="fixed">getLine</span>은&nbsp; <span class="fixed">IO
            String</span>타입을 지녔으므로, <span class="fixed">name</span>은 <span class="fixed">String</span>타
          입을 지닐 것입니다. I/O action을, 실제 세계로 나가 (벽에 낙서를 한다던가와 같은)무언가를 한뒤에, 데이터를 가지고
          오는 작은 발들이 달린 상자라 할 수 있겠습니다. 만약 이것이 데이터를 가져왔다면, 상자를 열어 내부에 있는 데이터를 가져올
          수 있는 유일한 방법은 <span class="fixed">&lt;-</span>구조를 이용하는 것입니다. I/O
          action에서 데이터를 꺼내려면, 또 다른 I/O action 안에서 데이터를 가져와야 합니다. 이것이 바로 하스켈이 코드를
          순수한 부분과 지저분한 부분으로 나눠 관리하는 방식입니다. <span class="fixed">getLine</span>은
          매 수행마다 동일한 결과 값을 보장하지 않기에, 어떤 의미에선 지저분합니다. 이것이 바로 I/O 코드에서, 데이터를 얻어오기
          위해 <i>지저분한</i> <span class="fixed">IO</span>타입 구조자(constructor)가
          존재하는 이유입니다. I/O코드 역시 더럽고, 더러운 I/O데이터에 의존하는 계산은 더러운 결과를 가져오게될 것이기
          때문입니다.</p>
        <p>제가 <i>더럽다</i> 라고 말한 것은, I/O action이 수반한 결과를 순수한 코드에서 결코 다시 사용하지 않는다는
          것을 의미하는 것은 아닙니다. 네, 내부에 있는 데이터를 I/O action을 <span class="fixed">name</span>에
          bind할때 잠시나마 <i>더럽혀지지 않을 것입니다</i>. <span class="fixed">name &lt;-
            getLine</span>라 하면, <span class="fixed">name</span>은 상자 내부에 있는 것을
          나타내기에 평범한 문자열이 될 것입니다. 이를 이용하여 이름(평범한 문자열)을 인자로 받아 미래를 알려주는 매우 복잡한 함수를
          만들 수도 있습니다. 이렇게 할 수 있습니다:</p>
        <pre name="code" class="haskell:hs">main = do
    putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn $ "Read this carefully, because this is your future: " ++ tellFortune name
</pre>
        <p><span class="fixed">tellFortune</span>은 (혹은 <span class="fixed">name</span>을
          넘겨받는 어떠한 함수라도) I/O에 관한 어떠한 것도 알지못하는, 단순히 평범한 <span class="fixed">String
            -&gt; String</span> 함수입니다!</p>
        <p>코드를 살펴봅시다. 이게 과연 유효한 것일까요?</p>
        <pre name="code" class="haskell:hs">nameTag = "Hello, my name is " ++ getLine
</pre>
        <p>그렇지 않다고 답한 당신, 과자를 드세요. 그렇다고 답한 당신, 철철 흐르는 용암 한사발을 들이키세요. 농담이고, 절대 하지
          않습니다! 동작하지 않는 이유는 <span class="fixed">++</span>는 동일한 타입의 리스트를 인자로
          요구하기 때문입니다. 좌측 인자의 타입은 <span class="fixed">String</span> (혹은 <span class="fixed">[Char]</span>)
          인 반면, <span class="fixed">getLine</span>은 <span class="fixed">IO
            String</span>타입을 갖습니다. 문자열과 I/O action을 연결(concatenate)할 순 없습니다. <span
            class="fixed">String</span>타입의 값을 얻기위해 I/O action의 결과를 얻어와야만 하며, 이를
          행할 유일한 방법은 또 다른 I/O action내부에서 <span class="fixed">name &lt;- getLine</span>과
          같은 무언가를 행하는 것입니다. 지저분한 데이터를 다루어야 한다면, 지저분한 환경에서 이를 처리해야 합니다. 이러한 불순한
          더러움이 마치 죽음의 질병처럼 퍼져있으며, 저희의 주된 관심사는 코드의 I/O 부분을 가능한 작게 유지하는 것입니다.<br>
        </p>
        <p>수행된 모든 I/O aciton은 내부에 결과를 담고 있습니다. 그러므로 이전 예제 프로그램이 다음과 같이 쓰여질 수
          있습니다:</p>
        <pre name="code" class="haskell:hs">main = do
    foo &lt;- putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
</pre>
        <p><span class="fixed">foo</span>는 <span class="fixed">()</span>를 값으로
          가질 것이므로 고려대상이 아닙니다. 마지막 <span class="fixed">putStrLn</span>이 다른것과 엮이지
          않은 것을 주목하시기 바랍니다. 이는 <i>do</i>블록 내부에선, 처음 2개와 달리<span style="font-weight: bold;">
          </span><em>마지막 action은 name과 엮여서는 안되기</em> 때문입니다. 정확히 왜 이러한 지에 대해서는,
          조금 뒤인 모나드 세계를 경험할때 살펴보도록 하겠습니다. 지금은, <i>do</i>블록은 '자동적으로 마지막 action에서
          값을 추출하여, 결과로 내보낸다' 라고 생각하시면 됩니다.</p>
        <p>마지막 줄을 제외하고, <i>do</i> 블록내에 있는 bind되지 않은 모든 줄을 bind를 써서 작성할 수 도
          있습니다. 따라서 <span class="fixed">putStrLn "BLAH"</span>을 <span class="fixed">_
            &lt;- putStrLn "BLAH"</span>로 바꿔쓸 수 있습니다. 하지만 이는 쓰잘데기 없는 짓이므로, <span
            class="fixed">putStrLn <i>something</i></span>와 같이 별로 중요하지 않는 결과를
          지닌 I/O action에 대해서는 <span class="fixed">&lt;-</span>을 뺄 것입니다.</p>
        <p>초보자들은 종종 이렇게 생각하기도 합니다.</p>
        <pre name="code" class="haskell:hs">name = getLine
</pre>
        <p>입력에서 읽어서, <span class="fixed">name</span>에 값을 bind한다. 흠, 그렇지 않습니다.
          이것이 행하는 일은 <span class="fixed">getLine</span> I/O action에게 <span class="fixed">name</span>라
          불리는 이름을 붙여준 것입니다. I/O action에서 값을 얻어오려면, <span class="fixed">&lt;-</span>로
          이름(name)과 엮어(bind) 또 다른 I/O action 내부에서 수행해야 한다는 것을 기억하시기 바랍니다.</p>
        <p>I/O action은 <span class="fixed">main</span>이란 이름이 주어지거나, <i>do</i>블
          록으로 구성된 커다란 I/O action내부에 있을때만 수행됩니다. 또한 <i>do</i>블록을 이용하여 여러 I/O
          action들을 서로 묶을 <i></i>수 있으며, 이러한 I/O action을 또 다른 I/O action에서 이용할 수
          있습니다. 어찌됐던 간에, 최종적으로 <span class="fixed">main</span>에 도달해서야 수행됩니다.</p>
        <p>아, 맞습니다. I/O action이 수행되는 몇가지 경우의 수가 있습니다. GHCI에서 I/O action을 입력하고
          엔터를 누르면 I/O action이 수행됩니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; putStrLn "HEEY"
HEEY
</pre>
        <p>GHCI에서 함수를 호출하거나 숫자를 때려넣어 엔터를 누르면, 필요한 만큼 평가를 한다음 <span class="fixed">show</span>를
          호출하여, <span class="fixed">putStrLn</span>구현을 이용하여 터미널에 문자열을 출력할 것입니다.</p>
        <p><i>let</i> bindings이 기억나십니까? 그렇지 않다면, <a href="syntax-in-functions#let-it-be">이
            장</a>을 읽어 기억을 상기시켜 보시기 바랍니다. let binding은 <span class="fixed">let <i>bindings</i>
            in <i>expression</i></span>형태를 띄는데, <span class="fixed"><i>bindings</i></span>은
          표현식에 사용되는 이름들이며, <span class="fixed"><i>expression</i></span>은 평가되는
          표현식입니다. 또한 이를 <i>in</i>부분이 필요치 않는 list comprehensions로 나타낼 수 있었습니다.
          그리고, list comprehensions에서 이용했던 것 처럼 <i>do</i> 블록 내에서 이용할 수 도 있습니다.
          확인해봅시다:</p>
        <pre name="code" class="haskell:hs">import Data.Char

main = do
    putStrLn "What's your first name?"
    firstName &lt;- getLine
    putStrLn "What's your last name?"
    lastName &lt;- getLine
    let bigFirstName = map toUpper firstName
        bigLastName = map toUpper lastName
    putStrLn $ "hey " ++ bigFirstName ++ " " ++ bigLastName ++ ", how are you?"
</pre>
        <p><i>do</i>블록에 줄줄이 있는 I/O action들이 보이십니까? 또 I/O action들과 <i>let</i>이,
          그리고 <i>let</i>의 이름끼리 서로 줄맞춰 있다는것을 눈치채셨습니까? 이는 하스켈의 줄맞춤의 중요성을 보여주는 훌륭한
          예제입니다. 여기서, <span class="fixed">"John"</span>를 더욱 멋진 <span class="fixed">"JOHN"</span>와
          같이 더욱 멋진 문자열로 바꾸는 <span class="fixed">map toUpper firstName</span>를
          수행하였습니다. 대문자로된 문자열을 name으로 bind하여, 나중에 이를 터미널에 출력할때 사용하였습니다.</p>
        <p>여러분들이 아마 언제 <span class="fixed">&lt;-</span>를 사용하고 언제 <i>let</i>
          bindings을 사용하는지를 혼란스러워 하실지도 모르겠습니다. 그렇다면, 당장은 <span class="fixed">&lt;-</span>은
          I/O actions을 수행하고 그 결과를 name에 bind하기 위한 것이라고 기억하시기 바랍니다. 하지만, <span class="fixed">map
            toUpper firstName</span>은 I/O action이 아닙니다. 이는 하스켈에서 순수한 표현식입니다.
          따라서&nbsp; I/O action의 결과를 name에 bind하고자 할때 <span class="fixed">&lt;-</span>를
          사용하시고, 순수한 표현식을 name에 bind하고자 할때는 <i>let</i> bindings을 사용하시기 바랍니다. <span
            class="fixed">let firstName = getLine</span>이라 한다면, <span class="fixed">getLine</span>
          I/O action을 다른 이름으로 부를 수 있으며, 또한 여전히 <span class="fixed">&lt;-</span>를
          통해서도 이를 행할 수 있습니다.</p>
        <p>이제 계속하여 줄을 읽고, 동일한 줄에 단어를 뒤집어서 출력하는 프로그램을 만들어봅시다. 비어있는 줄을 입력할때 프로그램의
          실행은 멈추게 됩니다. 여기 프로그램이 있습니다:</p>
        <pre name="code" class="haskell:hs">main = do 
    line &lt;- getLine
    if null line
        then return ()
        else do
            putStrLn $ reverseWords line
            main

reverseWords :: String -&gt; String
reverseWords = unwords . map reverse . words
</pre>
        <p>코드를 살펴보기 전에,&nbsp; 이를 먼저 돌려봐서 어떠한 일을 행하는지 느껴보도록 합시다.</p>
        <div class="hintbox"><em>전문가의 조언</em>: <span class="fixed">ghc --make
            helloworld</span>로 컴파일을 하여 <span class="fixed">./helloworld</span>로
          실행파일을 실행하거나, <span class="fixed">runhaskell helloworld.hs</span>와 같이
          <span class="fixed">runhaskell</span>명령어를 이용하여 프로그램을 돌려볼 수 있습니다.</div>
        <p>우선, <span class="fixed">reverseWords</span>함수를 살펴봅시다. 이는 평범한 함수인데,
          우선 <span class="fixed">"hey there man"</span>와 같은 문자열을 받아 <span class="fixed">words</span>를
          호출하여 <span class="fixed">["hey","there","man"]</span>와 같은 단어 리스트를
          만듭니다. 다음으로 <span class="fixed">reverse</span>를 그 리스트에 map하여 <span class="fixed">["yeh","ereht","nam"]</span>을
          얻은다음, <span class="fixed">unwords</span>을 이용하여 하나의 문자열을 돌려줌으로, 최종 결과는
          <span class="fixed">"yeh ereht nam"</span>가 됩니다. 함수 composition을 어떻게
          활용하는지를 잘 살펴보시기 바랍니다. 함수 composition이 없다면, <span class="fixed">reverseWords
            st = unwords (map reverse (words st))</span>라고 작성해야만 합니다.</p>
        <p><span class="fixed">main</span>은 어떨까요? 우선, <span class="fixed">getLine</span>을
          호출하여 터미널에서 <span class="fixed">line</span>을 받습니다. 그리고 하스켈에선, 모든 표현식은
          값을 지녀야 하므로, <i>if</i>와 <i>else</i>를 대응시켜야 한다는 것을 명심하시기 바랍니다. <i>if</i>는
          조건이 참일때 I/O action을 수행하고, 그렇지 않을때에는<span style="font-style: italic;">
          </span><i>else</i>아래에 있는 I/O action이 수행됩니다. 이것이 바로 왜 I/O <i>do</i>블
          록안에 <i>if</i>가&nbsp; <span class="fixed">if <i>조건문</i> then <i>I/O
              action</i> else <i>I/O action</i></span>라는 형태를 띄어야 하는지에 대한 이유입니다.</p>
        <p>우선 <i>else</i>절 아레서 무슨 일이 일어나는지 살펴보도록 하겠습니다. <i>else </i>다음에는 정확히
          하나의 I/O action만을 지녀야하기에, <i>do</i>블록을 이용하여 두 I/O action을 하나로 만들었습니다.
          이 부분을 다음과 같이 작성할 수 도 있습니다:</p>
        <pre name="code" class="haskell:hs">        else (do
            putStrLn $ reverseWords line
            main)
</pre>
        <p><i>do</i>블록을 하나의 I/O action로 보이게 만들었지만, 생긴건 못생겼습니다. 어쨋건, <i>do</i>블록
          내부에서 <span class="fixed">getLine</span>으로 얻은 라인에 대해 <span class="fixed">reverseWords</span>을
          호출하여 이를 터미널에 출력하였습니다. 이를 마친 후에는 <span class="fixed">main</span>을
          수행하였습니다. <span class="fixed">main</span> 그 자체가 하나의 I/O action이기에,
          재귀적으로 호출하는것 역시 괜찮습니다. 따라서, 어떤 의미에선 프로그램의 시작 부분으로 거슬러 올라갑니다.</p>
        <p>그러면 <span class="fixed">null line</span>이 참을 만족하면 어떻게 될까요? 이러한 경우 <i>then</i>이
          수행됩니다. 자세히 살펴본다면, <span class="fixed">then return ()</span>를 발견할 수 있을
          것입니다. 여러분들이 C, Java, Python과 같은 imperative언어를 경험하였다면, 아마 <span class="fixed">return</span>이
          하는 일이 무엇인지 알고있다고 생각하여 실제론 기나긴 패러다임을 이미 넘어섰다고 생각할지도 모르겠습니다. 흠, 과연 그럴까요?
          <em>하스켈에서의 <span class="fixed">return</span>은 실제로, 다른 대부분의 언어에서의 <span
              class="fixed">return</span>과 같지 않습니다!</em> 동일한 이름을 가져 많은 사람들을
          혼란스럽게 하지만, 사실 매우 다릅니다. imperative언어에서의 <span class="fixed">return</span>은
          보통 메소드나 서브루틴의 실행을 끝내거나, 호출한 누군가에게 값을 제공합니다. 하스켈에선 (특히 I/O actions에선),
          I/O action에서 순수한 값을 얻어오는 것입니다. 전에 상자에 비유한 것을 들쳐보자면, I/O action은 얻어온 값을
          상자안에 가둬버립니다. I/O action의 결과는 사실 아무것도 하지 않으며, 이의 결과로 봉인된 값을 갖고 있기만 합니다.
          따라서 I/O context에서의 <span class="fixed">return "haha"</span>은 <span class="fixed">IO
            String</span>타입을 지닐 것입니다. I/O action이 아무것도 하지않고 순수한 값을 속에 품고 옮기기만 하는
          이유가 무엇일까요? 왜 저희 프로그램이 <span class="fixed">IO</span>로 인해 더럽혀질까요? 비어있는
          라인을 처리하려면 어떠한 I/O action이 필요합니다. 이것이 바로 <span class="fixed">return ()</span>라
          작성하여 아무것도 행하는 모조 I/O action을 만들어야 되는 이유입니다. </p>
        <p><span class="fixed">return</span>은 I/O <i>do</i> 블록의 실행을 끝내거나 그와 비슷한
          일을 하지 않습니다. 예를들어, 다음 프로그램은 마지막 줄까지 순조롭게 진행될 것입니다:</p>
        <pre name="code" class="haskell:hs">main = do
    return ()
    return "HAHAHA"
    line &lt;- getLine
    return "BLAH BLAH BLAH"
    return 4
    putStrLn line
</pre>
        <p>여기나온 <span class="fixed">return</span>들이 하는 일은, 봉인된 값을 갖는 것을 제외하고는
          어떠한 일도 하지 않는 I/O action들을 만드는 것이며, name에 bind되지 않았기에 그 결과는 버려지게 됩니다.
          무언가를 name에 bind하기 위해 <span class="fixed">return</span>을 <span class="fixed">&lt;-</span>와
          결합하여 사용할 수 있습니다.</p>
        <pre name="code" class="haskell:hs">main = do
    a &lt;- return "hell"
    b &lt;- return "yeah!"
    putStrLn $ a ++ " " ++ b
</pre>
        <p>보시다시피, <span class="fixed">return</span>은 <span class="fixed">&lt;-</span>와
          반대되는 개념입니다. <span class="fixed">return</span>은 값을 취해 상자에 가둬넣지만, <span
            class="fixed">&lt;-</span>은 상자를 받아 속에 있는 값을 꺼내 name에 bind합니다. 하지만,
          다음처럼 <i>do</i>블록 내에서 <i>let</i> binding을 이용하여 name에 bind할 수 있기에 이처럼
          할 필요가 없습니다: </p>
        <pre name="code" class="haskell:hs">main = do
    let a = "hell"
        b = "yeah"
    putStrLn $ a ++ " " ++ b
</pre>
        <p> 거의 대부분, 아무것도 하지 않는 I/O action을 만들 필요가 있을때나, <i>do</i>블록으로부터 만들어진
          I/O action이 마지막 action의 결과가 아닌 다양한 결과값을 갖도록 하기 위해 <span class="fixed">return</span>을
          사용하므로, I/O <i>do</i>블록을 다룰 때에는 원하는 결과를 포함하는 I/O action을 만들기 위해서 항상 <span
            class="fixed">return</span>을 사용할 것이며, 이를 마지막에 넣을 것입니다.</p>
        <div class="hintbox">또한 <i>do</i>블록은 단순히 하나의 I/O action만을 가질 수 있습니다.
          이러한 경우, 하나의 I/O action만을 쓴 것과 같습니다. <i>else</i> 또한 이러한 경우 <i></i><i>do</i>를
          포함하기에, 몇몇 사람들은 <span class="fixed">then do return ()</span>라 작성하는 것을
          선호하기도 합니다.</div>
        <p>파일로 넘어가기전에 먼저, I/O를 다루는데 있어 유용한 함수들을 살펴봅시다.</p>
        <p><span class="label function">putStr</span>은 문자열을 인자로 받아 터미널에 문자열로
          출력되는 I/O action을 반환하는 점에서는 <span class="fixed">putStrLn</span>와
          닮았지만,&nbsp; <span class="fixed">putStrLn</span>은 문자열을 출력하고 새로운 줄로
          넘어가는 반면 <span class="fixed">putStr</span>는 그렇지 않습니다.</p>
        <pre name="code" class="haskell:hs">main = do   putStr "Hey, "
            putStr "I'm "
            putStrLn "Andy!" 
</pre>
        <pre name="code" class="plain">$ runhaskell putstr_test.hs
Hey, I'm Andy!
</pre>
        <p>타입서명은 <span class="fixed">putStr :: String -&gt; IO ()</span>이므로,
          I/O action의 결과로 동봉된 결과값은 unit입니다. 가짜 값이므로, bind하지 않는게 이치에 맞습니다.</p>
        <p><span class="label function">putChar</span>는 문자를 취해, 터미널에 그 문자를 출력하는
          I/O action을 반환합니다..</p>
        <pre name="code" class="haskell:hs">main = do   putChar 't'
            putChar 'e'
            putChar 'h'
</pre>
        <pre name="code" class="plain">$ runhaskell putchar_test.hs
teh
</pre>
        <p><span class="fixed">putStr</span>는 사실 <span class="fixed">putChar</span>의
          도움으로 재귀적으로 정의되었습니다. <span class="fixed">putStr</span>의 주변조건은 비어있는
          문자열이므로, 비어있는 문자열을 출력하고자 한다면, <span class="fixed">return ()</span>을
          이용하여 아무런 일도 하지 않는 I/O action을 반환합니다. 비어있지 않다면, <span class="fixed">putChar</span>를
          이용하여 문자열의 첫번째 문자를 출력하고, <span class="fixed">putStr</span>를 이용하여 나머지를
          출력합니다.</p>
        <pre name="code" class="haskell:hs">putStr :: String -&gt; IO ()
putStr [] = return ()
putStr (x:xs) = do
    putChar x
    putStr xs
</pre>
        <p>순수한 코드에서처럼, I/O에서 재귀를 사용할 수 있는것에 주목하시기 바랍니다. 순수한 코드에서 처럼, 주변 조건을
          정의하였고 실제 결과가 무엇인지 생각하였습니다. 우선 첫번째 문자를 출력하고, 나머지 문자열을 출력하였습니다.</p>
        <p><span class="label function">print</span>는 값을 문자열로 만드는 <span class="fixed">show</span>라
          불리는 <span class="fixed">Show</span> 인스턴스 타입의 값을 취해 터미널에 출력합니다. 근본적으로
          이는 단지 <span class="fixed">putStrLn . show</span>입니다. 우선 <span class="fixed">show</span>를
          돌려, <span class="fixed">putStrLn</span>에게 값을 넘겨 출력시킵니다.</p>
        <pre name="code" class="haskell:hs">main = do   print True
            print 2
            print "haha"
            print 3.2
            print [3,4,3]
</pre>
        <pre name="code" class="haskell:hs">$ runhaskell print_test.hs
True
2
"haha"
3.2
[3,4,3]
</pre>
        <p>보시다시피, 이는 매우 편리한 함수입니다. <span class="fixed">main</span>에 닿거나,&nbsp;
          GHCI 프롬프트에서 평가할때 어떻게 I/O action이 수행되는지에 대해 예기했던 기억이 나십니까? 사실 (<span class="fixed">3</span>이
          나 <span class="fixed">[1,2,3]</span>와 같은) 값을 입력하고 엔터를 누르면, GHCI는 터미널에
          그 값을 보여주기 위해 <span class="fixed">print</span>를 이용합니다! </p>
        <pre name="code" class="haskell:hs">ghci&gt; 3
3
ghci&gt; print 3
3
ghci&gt; map (++"!") ["hey","ho","woo"]
["hey!","ho!","woo!"]
ghci&gt; print (map (++"!") ["hey","ho","woo"])
["hey!","ho!","woo!"]
</pre>
        <p>문자열 출력시, quote를 피하고자 할 때에는 보통 <span class="fixed">putStrLn</span>을
          사용하며, 터미널에 다른 타입의 값들을 출력하는데 있어선 <span class="fixed">print</span>가 가장
          많이 쓰입니다.</p>
        <p><span class="function label">getChar</span>는 입력에서 문자를 읽어오는 I/O
          action입니다. 따라서, I/O action이 담고있는 결과가 <span class="fixed">Char</span>이
          며, 타입서명은 <span class="fixed">getChar :: IO Char</span>입니다. 버퍼링으로 인해,
          엔터키를 누르기 전까지 문자를 읽어오지 않는다는 것을 주의하시기 바랍니다.</p>
        <pre name="code" class="haskell:hs">main = do   
    c &lt;- getChar
    if c /= ' '
        then do
            putChar c
            main
        else return ()
</pre>
        <p>이 프로그램은 문자를 읽어 띄어쓰기를 검사하는 것처럼 보입니다. 띄어쓰기가 있다면 실행을 멈추고, 그렇지 않다면 터미널에
          출력후 동일한 일을 다시 반복하는 것처럼 보입니다. 흠, 이는 여러분의 생각과는 다르게 행동합니다. 확인해 봅시다:</p>
        <pre name="code" class="plain">$ runhaskell getchar_test.hs
hello sir
hello
</pre>
        <p>두번째 줄이 입력입니다. 저는 <span class="fixed">hello sir</span>라고 입력한 후 엔터를
          눌렀습니다. 버퍼링으로 인해 문자를 입력할 때마다가 아닌, 엔터키를 누른 다음에 프로그램이 실행됩니다. 엔터가 눌리면,
          이제까지 입력한 것에 기반하여 행동하게 됩니다. 한번 이 프로그램을 돌려봐서 어떠한 일을 하는지 느껴봅시다!</p>
        <p><span class="label function">when</span>함수는 <span class="fixed">Control.Monad</span>에
          서 찾을 수 있습니다 (접근하려면,&nbsp; <span class="fixed">import Control.Monad</span>를
          해야합니다). 흥미로운점은 <i>do</i>블록 내에서의 조건문과 흡사해 보이지만, 사실 평범한 함수라는 것입니다. 이는
          부울값과 I/O action을 취해, 부울값이 <span class="fixed">True</span>인 경우 제공한 것과
          동일한 I/O action을 반환합니다. 그렇지않고 <span class="fixed">False</span>라면
          action <span class="fixed">return ()</span>을 반환하며, 이러한 I/O action 은
          아무런 일도 하지 않습니다. 이전 코드를 <span class="fixed">when</span>을 이용하여 <span class="fixed">getChar</span>의
          예를 보여주도록 작성해 보았습니다:</p>
        <pre name="code" class="haskell:hs">import Control.Monad 

main = do
    c &lt;- getChar
    when (c /= ' ') $ do
        putChar c
        main
</pre>
        <p>보시다시피, when은 <span class="fixed">if <i>something</i> then do <i>some
              I/O action</i> else return ()</span> 패턴을 녹여내는데 있어 유용합니다.</p>
        <p><span class="label function">sequence</span>는 I/O action 리스트를 받아
          순차적으로 실행되는 I/O action을 반환합니다. 이러한 I/O action이 포함하는 결과는 모든 I/O action이
          수행된 결과를 담은 리스트가 될 것입니다. sequence의 타입 서명은 <span class="fixed">sequence
            :: [IO a] -&gt; IO [a]</span>입니다. 다음과 같은 일을 할 수 있습니다:</p>
        <pre name="code" class="haskell:hs">main = do
    a &lt;- getLine
    b &lt;- getLine
    c &lt;- getLine
    print [a,b,c]
</pre>
        <p>이것이 하는일은 다음과 같습니다:</p>
        <pre name="code" class="haskell:hs">main = do
    rs &lt;- sequence [getLine, getLine, getLine]
    print rs
</pre>
        <p>따라서 <span class="fixed">sequence [getLine, getLine, getLine]</span>는
          <span class="fixed">getLine</span>을 3번 수행하는 I/O action을 만들어 냅니다. 이러한
          action을 name과 bind한다면 결과는 결과 리스트가 될 것이며, 위 경우에서는 사용자가 프롬프트에 입력한 3개를 담은
          리스트가 될 것입니다.</p>
        <p><span class="fixed">sequence</span>에 대한 일반적인 패턴은 리스트에 대해 <span class="fixed">print</span>나
          <span class="fixed">putStrLn</span>와 같은 함수를 map하는 것입니다. <span class="fixed">map
            print [1,2,3,4]</span>는 I/O action을 생성하지 않습니다. <span class="fixed">[print
            1, print 2, print 3, print 4]</span>와 같은&nbsp; I/O action 리스트를 만들어
          냅니다. I/O action 리스트를 I/O action으로 변형시키고자 한다면, sequence를 해야합니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; sequence (map print [1,2,3,4,5])
1
2
3
4
5
[(),(),(),(),()]
</pre>
        <p>마지막에 <span class="fixed">[(),(),(),(),()]</span>는 과연 무엇일까요? GHCI상에서
          I/O action을 평가하면, 결과가 <span class="fixed">()</span>이면 수행 결과가 출력되며,
          그렇다면 출력되지 않습니다. 따라서 GHCI상에서 <span class="fixed">putStrLn "hehe"</span>를
          평가하면 <span class="fixed">hehe</span> 가 출력됩니다(<span class="fixed">putStrLn
            "hehe"</span>의 결과가 담고있는 값은 <span class="fixed">()</span>이기 때문입니다).
          하지만 GHCI에서 <span class="fixed">getLine</span>를 한다면, <span class="fixed">getLine</span>은
          <span class="fixed">IO String</span> 타입을 갖기에 I/O action의 결과가 출력될 것입니다.</p>
        <p>리스트에 대한 I/O action을 반환하는 함수를 매핑(mapping)하여 순서화시키는(sequencing) 것은 매우
          일상적이기에, 유틸리티 함수 <span class="label function">mapM</span>와 <span class="label function">mapM</span>이
          도입되었습니다. <span class="fixed">mapM</span>는 함수와 리스트를 취해, 리스트에 대해 함수를
          map한 후 sequence합니다. <span class="fixed">mapM_</span>는 동일한 일을 수행하지만,
          결과는 버려집니다. sequence된 I/O action이 가지는 결과가 무엇인지 상관치 않을때 보통&nbsp; <span
            class="fixed">mapM_</span>를 사용합니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; mapM print [1,2,3]
1
2
3
[(),(),()]
ghci&gt; mapM_ print [1,2,3]
1
2
3
</pre>
        <p><span class="label function">forever</span>는 I/O action 하나를 취해 무한히
          반복되는 I/O action을 반환합니다. 이는 <span class="fixed">Control.Monad</span>에
          위치해 있습니다. 이 작은 프로그램은 사용자에게 계속하여 입력을 요구한후 대문자로 변환시켜 돌려줄 것입니다:</p>
        <pre name="code" class="haskell:hs">import Control.Monad
import Data.Char

main = forever $ do
    putStr "Give me some input: "
    l &lt;- getLine
    putStrLn $ map toUpper l
</pre>
        <p><span class="label function">forM</span>은 (<span class="fixed">Control.Monad</span>에
          위치한) <span class="fixed">mapM</span>와 인자만 바뀌었을뿐 같습니다. 첫번째 인자는 리스트이며,
          두번째는 sequence될 리스트에 map시킬 함수입니다. 이것이 과연 유용할까요? lambda와 do 표기를 창의적으로
          사용하여, 다음과 같은 일을 할 수 있습니다:</p>
        <pre name="code" class="haskell:hs">import Control.Monad

main = do 
    colors &lt;- forM [1,2,3,4] (\a -&gt; do
        putStrLn $ "Which color do you associate with the number " ++ show a ++ "?"
        color &lt;- getLine
        return color)
    putStrLn "The colors that you associate with 1, 2, 3 and 4 are: "
    mapM putStrLn colors
</pre>
        <p><span class="fixed">(\a -&gt; do ... )</span>는 수를 받아 I/O action을
          반환합니다. 괄호로 감싸지 않으면, lambda는 마지막 두 I/O action이 lambda에 속한다고 생각할 것입니다. <span
            class="fixed">return color</span> in the inside <i>do</i> 블록 내부에서 <span
            class="fixed">return color</span>를 한것에 주목하시기 바랍니다. <i>do</i>블록에서
          정의된 I/O action은 내부에 색상(color)를 결과로 가질 것이기에 이렇게 했습니다. 사실 <span class="fixed">getLine</span>이
          이미 내부에 포함하고 있기에 그렇게 하지 않아도 됐었습니다. <span class="fixed">color &lt;-
            getLine</span>라고 한 다음 <span class="fixed">return color</span>라고 하는
          것은 <span class="fixed">getLine</span>에서 결과를 꺼내와서 다시 집어넣는 것이므로, 단순히 <span
            class="fixed">getLine</span>이라 한 것과 동일합니다. <span class="fixed">forM</span>은
          I/O action을 만들어내며, 그 결과는 <span class="fixed">colors</span>에
          bind되었습니다. <span class="fixed">colors</span>는 단지 문자열을 담고있는 평범한
          리스트입니다. 마지막부분에선, 이러한 색상들(colors)을 <span class="fixed">mapM putStrLn
            colors</span>로 출력하였습니다.</p>
        <p><span class="fixed">forM</span>를 다음과 같이 생각할 수 있습니다: 리스트에 있는 모든 원소들에
          대한 I/O action을 만드는 것. 각 I/O action이 수행하는 일은 각 action을 만드는데 이용된 원소에
          기반합니다. 마지막으로, 이러한 action들이 수행되고 그 결과를 무언가에 bind합니다. 물론 bind하지 않고 버릴 수
          도 있습니다.</p>
        <pre name="code" class="plain">$ runhaskell form_test.hs
Which color do you associate with the number 1?
white
Which color do you associate with the number 2?
blue
Which color do you associate with the number 3?
red
Which color do you associate with the number 4?
orange
The colors that you associate with 1, 2, 3 and 4 are:
white
blue
red
orange
</pre>
        <p>사실 <span class="fixed">forM</span>없이도 할 수 있지만, <span class="fixed">forM</span>이
          있는게 더욱 읽기쉽습니다.<i></i><span style="font-style: italic;"></span> 보통 <span
            class="fixed">forM</span>은, <span style="font-style: italic;">do</span>
          표기법을 사용한 곳에 정의된 action들에 대해 map하고 sequence할때 씁니다. 같은 맥락에서, 마지막 줄을 <span
            class="fixed">forM colors putStrLn</span>으로 바꿀 수 있습니다.</p>
        <p>이번 단락에서 입/출력의 기본에 대해 배웠습니다. 또한 I/O action이 무엇인가, 어떻게 입력과 출력이 가능하며 언제
          수행되는가에 대해 밝혀냈습니다. 반복해서 말하지만, I/O action은 하스켈에서의 다른 값들과 유사합니다. I/O
          action은 함수의 인자로 넘길 수 있으며, 함수의 결과로 반환할 수 있습니다. 특별한점은 <span class="fixed">main</span>에
          왔을때 (혹은 GHCI에서) 실행되며, 화면에 무언가를 출력하거나 스피커를 통해 Yakety Sax를 틀게됩니다. 또한 각
          I/O action은, 실제 세계에서 얻어온 것이 무엇인지 알려주는 결과를 봉인할 수 있습니다.</p>
        <p><span class="fixed">putStrLn</span>과 같은 함수를 문자열을 받아 화면에 출력하는 함수라 생각지
          마시기 바랍니다. 문자열을 받아 I/O action을 반환하는 함수라 생각하시기 바랍니다. 이러한 I/O action이
          수행될때에, 비로써 터미널에 아름다운 시가 출력될 것입니다.</p>
        <a name="files-and-streams"></a>
        <h2>파일과 스트림<br>
        </h2>
        <img src="http://s3.amazonaws.com/lyah/streams.png" alt="streams" class="right"
          height="322" width="464">
        <p><span class="fixed">getChar</span>는 터미널에서 문자 하나를 읽어오는 I/O action입니다.
          <span class="fixed">getLine</span>은 터미널에서 한 줄을 읽어오는 I/O action입니다. 이
          둘은 사실 복잡하지 않으며, 대부분의 프로그래밍 언어에서 이와 상응하는 함수나 구문을 갖고있습니다. 따라서 지금은 <span
            class="label function">getContents</span>를 만나보도록 하겠습니다. <span class="fixed">getContents</span>는
          end-of-file 문자를 만나기 전까지의 표준 입력에서 모든것을 읽어오는 I/O action입니다. 타입은 <span class="fixed">getContents
            :: IO String</span>입니다. <span class="fixed">getContents</span>에서 멋진
          점은 lazy I/O를 수행한다는 것입니다. <span class="fixed">foo &lt;- getContents</span>라
          하면, 들어온 것들을 한번에 읽어것이 아니라, 메모리에 저장한 다음, <span class="fixed">foo</span>와
          bind해 줍니다. 맞습니다, 이는 lazy입니다! 말하길: <i>"예 예, 진짜로 필요할때 터미널에서 입력을
            읽어들일거야!"</i>. </p>
        <p> <span class="fixed">getContents</span>는 어떤 프로그램의 출력을 저희 프로그램의 입력으로
          흘러보낼때(pipe) 매우 유용합니다. unix 시스템에서의 파이프가 하는일을 알지 못한다면, 여기 짧은 지침서가 있습니다.
          다음 짧은 하이쿠를 포함하는 텍스트 파일을 만들어 봅시다:</p>
        <pre name="code" class="plain">I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless 
</pre>
        <p>예, 이 하이쿠는 별로이지만, 어떡합니까? 좋은 하이쿠 지침서를 아시는 분은 제게 알려주시기 바랍니다.</p>
        <p>이제, <span class="fixed">forever</span>함수를 소계하면서 작성한 작은 프로그램을 떠올려
          봅시다. 문장을 입력받아, 대문자로 변형시켜 사용자에게반환한 다음, 동일한 일을 무한히 반복하였습니다. 여러분이 뒤로
          스크롤하지 않을 것이라 예상되어, 여기 다시 보여드리겠습니다:</p>
        <pre name="code" class="haskell:hs">import Control.Monad
import Data.Char

main = forever $ do
    putStr "Give me some input: "
    l &lt;- getLine
    putStrLn $ map toUpper l
</pre>
        <p>이 프로그램을 <span class="fixed">capslocker.hs</span>로 저장하여 컴파일해 봅시다. 그런
          다음, 유닉스 pipe를 이용하여 문서 파일을 프로그램에 넘겨줄 것입니다. 저희는 인자로 주어진 파일을 출력하는 GNU <i>cat</i>프
          로그램의 도움을 받을 것입니다. 첵 잇 아웃, 부야카!</p>
        <pre name="code" class="plain">$ ghc --make capslocker 
[1 of 1] Compiling Main             ( capslocker.hs, capslocker.o )
Linking capslocker ...
$ cat haiku.txt
I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless
$ cat haiku.txt | ./capslocker
I'M A LIL' TEAPOT
WHAT'S WITH THAT AIRPLANE FOOD, HUH?
IT'S SO SMALL, TASTELESS
capslocker &lt;stdin&gt;: hGetLine: end of file
</pre>
        <p>보시다시피, <span class="fixed">|</span>문자로 <i>cat</i>의 출력이 <i>capslocker</i>의
          입력으로 piping되었습니다. 저희가 한 일은<span style="font-style: italic;"> </span><i>capslocker</i>를
          실행하여 터미널에 하이쿠를 입력한 다음 (보통 Ctrl-D를 눌러) end-of-file 문자를 삽입한 것과 같습니다. 이는
          <i>cat haiku.txt</i>를 실행 후 다음과 같이 말한 것입니다: “잠깐, 터미널에 출력하지말고, <i>capslocker</i>에
          게 넘겨줘!”.</p>
        <p>그러나 <span class="fixed">forever</span>의 사용에 있어, 입력을 취하는 작업과 어떠한 출력으로
          형태를 변화시키는 작업이 필요합니다. 이것이 바로 더 짧막하고 더 나은 프로그램을 만들기 위해 <span class="fixed">getContents</span>를
          사용해야 되는 이유입니다:</p>
        <pre name="code" class="haskell:hs">import Data.Char

main = do
    contents &lt;- getContents
    putStr (map toUpper contents)
</pre>
        <p><span class="fixed">getContents</span> I/O action을 실행하고, 생성된 문자열에 <span
            class="fixed">contents</span>란 이름을 붙였습니다. 그런 다음, 문자열에 <span class="fixed">toUpper</span>를
          mapr하고 터미널에 출력하였습니다. 문자열은 기본적으로 lazy한 리스트이며 <span class="fixed">getContents</span>는
          I/O lazy이기에, 대문자로해서 출력하기 전에 한번에 전체 내용을 읽어 메모리에 저장하지 않는다는 것을 명심하시기
          바랍니다. 하지만, 이는 필요할때마다 한 줄 씩 읽어들일 것이기에, 읽자마자 출력할 것입니다.</p>
        <pre name="code" class="plain">$ cat haiku.txt | ./capslocker
I'M A LIL' TEAPOT
WHAT'S WITH THAT AIRPLANE FOOD, HUH?
IT'S SO SMALL, TASTELESS
</pre>
        <p>멋지게 동작합니다. <i>capslocker</i>만 실행하고 한줄씩 입력하면 어떻게 될까요?</p>
        <pre name="code" class="plain">$ ./capslocker
hey ho
HEY HO
lets go
LETS GO
</pre>
        <p>빠저나가기 위해선 Ctrl-D를 누르시기 바랍니다. 매우 멋집니다! 보시다시피, 줄 단위로 입력을 대문자로 바꾸어
          출력해줍니다. <span class="fixed">getContents</span>의 결과가 <span class="fixed">contents</span>에
          bind된다는 것은, 메모리상에 실제 문자열로 표현되는 것이 아니라, 후에 문자열을 생성할 거라는 약속에 가깝습니다. <span
            class="fixed">contents</span>에 <span class="fixed">toUpper</span>를
          map하는것 또한, 나중에 toUpper에 map할 거라는 약속입니다. 그리고 마지막으로 <span class="fixed">putStr</span>이
          발생하면, 이전 약속을 지키라 재촉하게됩니다: <i>"이봐, 대문자로된게 필요하다고!"</i>. 아직 어떠한 줄도 얻지
          못하였으므로, <span class="fixed">contents</span>에게 물어봅니다: <i>"이봐, 터미널에서
            진짜로 문장을 읽어들이는게 어때?"</i>. 그러면<span class="fixed">getContents</span>이
          실제로 터미널에서 읽고 실질적인 무언가를 생성하도록 요청한 코드에게 읽은 줄을 넘겨줍니다. 이러한 문장을 받은 코드는 얻어온
          줄에 <span class="fixed">toUpper</span>을 map하여, <span class="fixed">putStr</span>에
          넘겨 출력하게 합니다. 그런 다음, <span class="fixed">putStr</span>이 다음과 같이 말합니다: <i>"
            이봐, 빨리 다음 줄을 넘겨주라고!"</i>. 이러한 작업이 end-of-file 문자로 표시하는, 입력없음이 나타날
          때까지 반복됩니다.</p>
        <p>입력을 받아 문장이 10개보다 적은 문자로 구성되면 출력하는 프로그램을 만들어 봅시다. 살펴봅시다:</p>
        <pre name="code" class="haskell:hs">main = do
    contents &lt;- getContents
    putStr (shortLinesOnly contents)

shortLinesOnly :: String -&gt; String
shortLinesOnly input = 
    let allLines = lines input
        shortLines = filter (\line -&gt; length line &lt; 10) allLines
        result = unlines shortLines
    in  result
</pre>
        <p>저희는 프로그램의 I/O 부분을 가능한 짧게 만들어야 합니다. 입력을 받아 그에 기반하여 출력을 해야하기에, 입력된 내용을
          읽어 함수를 적용하여 함수가 돌려준 것을 출력해야 합니다.</p>
        <p><span class="fixed">shortLinesOnly</span>함수는 다음과 같은 일을 합니다: <span class="fixed">"short\nlooooooooooooooong\nshort
            again"</span>라는 문자열을 취했다고 가정해봅시다. 이 문자열은 3개의 줄로 되어있으며, 가운데 줄이 가장
          깁니다. 이 문장에 <span class="fixed">lines</span>함수를 돌려 <span class="fixed">["short",
            "looooooooooooooong", "short again"]</span>로 변환시킨 다음 <span class="fixed">allLines</span>에
          bind합니다. 후에 문자열 리스트가 filter되어 10문자 이하인 줄만 남아있게 되어 <span class="fixed">["short",
            "short again"]</span>을 생성하게 됩니다. 마지막으로, <span class="fixed">unlines</span>이
          이러한 리스트를 하나의 새로운 줄으로 합치어 <span class="fixed">"short\nshort again"</span>을
          돌려주게 됩니다. 다음을 입력하여 돌려봅시다.</p>
        <pre name="code" class="plain:hs">i'm short
so am i
i am a loooooooooong line!!!
yeah i'm long so what hahahaha!!!!!!
short line
loooooooooooooooooooooooooooong
short
</pre>
        <pre name="code" class="plain:hs">$ ghc --make shortlinesonly
[1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )
Linking shortlinesonly ...
$ cat shortlines.txt | ./shortlinesonly
i'm short
so am i
short
</pre>
        <p><i>shortlines.txt</i>의 내용을 <i>shortlinesonly</i>의 출력에 pipe하여, 보다 짧은
          줄을 출력으로 얻게 되었습니다.</p>
        <p>입력에서 어떠한 문자열을 얻어 함수에 넘겨주고 출력하는 이러한 패턴은 매우 일반적이며, 이러한 것을 쉽게 구현할 수 있는 <span
            class="label function">interact</span>라는 함수가 이미 존재합니다. <span class="fixed">interact</span>는
          <span class="fixed">String -&gt; String</span>타입의 함수를 인자로 받아 I/O
          action을 반환하는데, 이 I/O action은 어떠한 입력을 받아 함수를 적용시키고 그 함수의 결과를 출력하게 됩니다.
          interact를 이용하도록 프로그램을 수정해 봅시다.</p>
        <pre name="code" class="haskell:hs">main = interact shortLinesOnly

shortLinesOnly :: String -&gt; String
shortLinesOnly input = 
    let allLines = lines input
        shortLines = filter (\line -&gt; length line &lt; 10) allLines
        result = unlines shortLines
    in  result
</pre>
        <p>보이는 것처럼 (비록 가독성이 떨어지더라도) 더 적은 코드로 구현할 수 있으며, 함수 composition 기법을 이용하여
          조금 더 낫게 고칠 수 있습니다</p>
        <pre name="code" class="haskell:hs">main = interact $ unlines . filter ((&lt;10) . length) . lines
</pre>
        <p>와우, 매우 멋지게 한 줄로 줄여버렸습니다!</p>
        <p><span class="fixed">interact</span>는 어떠한 내용이 들어있는 pipe된 프로그램이나, 사용자의
          입력을 받아 그 입력에 기반하여 결과를 돌려주는걸 반복하는프로그램을 만들때 사용됩니다. 사실 이 둘 간의 차이점은 없으며,
          사용자가 어떻게 이를 생각하는지에 달려있습니다.</p>
        <p>입력된 줄을 계속 읽어들여, 회문(回文)인지 알려주는 프로그램을 만들어 봅시다. <span class="fixed">getLine</span>을
          이용하여 한 줄을 읽고, 사용자에게 회문 여부를 알려준 다음, <span class="fixed">main</span>을
          다시 실행시킴으로써 만들 수 있습니다. 하지만 <span class="fixed">interact</span>을 쓰면 더욱
          간편하게 작성할 수 있습니다. <span class="fixed">interact</span>을 사용할 때에는, 어떠한
          입력을 원하는 출력으로 전송하기 위해 필요한 것이 무엇인지 생각해야 합니다. 이번 경우에선, 각각의 줄을 <span class="fixed">"palindrome"</span>나
          <span class="fixed">"not a palindrome"</span>로 바꿀 것입니다. 따라서 저희는 <span
            class="fixed">"elephant\nABCBA\nwhatever"</span>를 <span class="fixed">"not
            a palindrome\npalindrome\nnot a palindrome"</span>로 변형시키는 함수를 작성할
          것입니다. 한번 해 봅시다!</p>
        <pre name="code" class="haskell:hs">respondPalindromes contents = unlines (map (\xs -&gt; if isPalindrome xs then "palindrome" else "not a palindrome") (lines contents))
    where   isPalindrome xs = xs == reverse xs
</pre>
        <p>점을 이용하여 작성해 봅시다.</p>
        <pre name="code" class="haskell:hs">respondPalindromes = unlines . map (\xs -&gt; if isPalindrome xs then "palindrome" else "not a palindrome") . lines
    where   isPalindrome xs = xs == reverse xs
</pre>
        <p>매우 간단합니다. 우선 프로그램은 <span class="fixed">"elephant\nABCBA\nwhatever"</span>을
          <span class="fixed">["elephant", "ABCBA", "whatever"]</span>로
          만든다음,&nbsp; lambda를 map하여 <span class="fixed">["not a palindrome",
            "palindrome", "not a palindrome"]</span>를 만듭니다. 그런 다음 <span class="fixed">unlines</span>로
          개행문자로 분리된 하나의 문자열로 만듭니다. 이제 다음과 같이 할 수 있습니다</p>
        <pre name="code" class="haskell:hs">main = interact respondPalindromes
</pre>
        <p>한번 돌려봅시다:</p>
        <pre name="code" class="plain">$ runhaskell palindromes.hs
hehe
not a palindrome
ABCBA
palindrome
cookie
not a palindrome

</pre>
        <p>입력받은 하나의 큰 문자열을 다른 곳으로 전송하는 프로그램을 만들지라도, 줄 단위로 행하는 프로그램처럼 행동하게 됩니다.
          하스켈이 lazy이기 때문인데, 결과 문자열의 첫번째 줄을 출력하려해도, 입력으로부터 첫번째 줄을 얻지 못했기에 그러할 수
          없습니다. 따라서 입력을 받자마자, 출력할 것입니다. end-of-line 문자로 프로그램을 빠저나가도록 하겠습니다.</p>
        <p>저희는 또한 파일을 pipe하여 여용할 수 도 있습니다. 다음을 지닌 파일을 갖고있다 가정해 봅시다:</p>
        <pre name="code" class="plain">dogaroo
radar
rotor
madam
</pre>
        <p>이를 <span class="fixed">words.txt</span>로 저장합니다. 다음 나온 것은 저희 프로그램으로
          pipe하여 얻게되는 결과입니다:</p>
        <pre name="code" class="plain">$ cat words.txt | runhaskell palindromes.hs
not a palindrome
palindrome
palindrome
palindrome
</pre>
        <p>또 다시, 프로그램을 실행시켜 표준입력에 단어를 입력한 것과 동일한 출력을 얻게되었습니다.&nbsp; 사용자의 입력이 아닌
          파일로 입력이 들어왔기에 <span class="fixed">palindromes.hs</span>의 입력을 확인할 수
          없습니다.</p>
        <p>아마 여러분은 이제 어떻게 lazy I/O가 동작하는지, 어떻게 이 이점을 활용할 수 있는지를 깨달았을 것입니다. 주어진
          어떠한 입력을 추정하여 출력이 무엇인가를 생각할 수 있으며, 전송을 하는 함수를 작성할 수 있습니다. lazy I/O에는
          입력에 맞춰 출력을 하므로, 입력을 완료하기 전까지 아무런 일도 하지 안습니다..</p>
        <p>지금까지 저희는 무언가를 터미널에 출력하고 읽으며 I/O를 다루어봤습니다. 하지만 파일을 읽고 쓰는 작업은 어떨까요? 음..
          한편으로 보자면, 저희는 이미 그러한 작업을 했습니다. 터미널에서 무언가를 읽는 작업을 파일에서 읽어오는 것이라 생각할 수
          있습니다. 터미널에 무언가를 쓰는 것은 파일에 무언가를 쓰는것이라 할 수 있습니다. 이러한 두 파일을 <span class="fixed">stdout</span>와
          <span class="fixed">stdin</span>라 부를 수 있으며, 이는 각각 <i>표준 출력(standard
            output</i>)과 <i>표준 입력(standard input</i>)을 의미합니다. 명심하시기 바랍니다. 파일을
          읽고 쓰는 작업은, 표준 출력에 쓰는 작업과 표준 입력에서 읽어들이는 작업과 매우 유사하다는 것을 곧 보게될 것입니다.</p>
        <p>Avril Lavigne's의 히트작인 <i>Girlfriend</i> 가사를 담고있는 <i>girlfriend.txt</i>을
          열어, 터미널에 출력하는 매우 간단한 프로그램부터 시작해 보도록 하겠습니다. 여기 <i>girlfriend.txt</i>가
          있습니다:</p>
        <pre name="code" class="plain">Hey! Hey! You! You! 
I don't like your girlfriend! 
No way! No way! 
I think you need a new one!
</pre>
        <p>그리고 여기 저희 프로그램이 있습니다:</p>
        <pre name="code" class="haskell:hs">import System.IO

main = do
    handle &lt;- openFile "girlfriend.txt" ReadMode
    contents &lt;- hGetContents handle
    putStr contents
    hClose handle
</pre>
        <p>돌려보면 예상했던 결과를 얻을 수 있습니다:</p>
        <pre name="code" class="plain">$ runhaskell girlfriend.hs
Hey! Hey! You! You!
I don't like your girlfriend!
No way! No way!
I think you need a new one!
</pre>
        <p>줄 단위로 살펴봅시다. 첫번째 줄은 단순히 주의를 끌기위한 외침입니다. 두번째 줄에서, Avril가 여러분의 파트너가 맘에
          들지 않다고 말하고 있습니다. 세번째 줄에서는 반감을 나타내는 반면, 4번째 줄에서는 새로운 배우자를 찾기를 권하고 있습니다.</p>
        <p>이번에는 줄 단위로 프로그램을 살펴보도록 하겠습니다! 저희 프로그램은 <i>do</i>블록으로 뭉쳐진 I/O
          action입니다. <i>do</i> 블록의 첫번째 줄에서, 새로운 함수 <span class="label function">openFile</span>를
          발견할 수 있을 것입니다. 타입서명은 다음과 같습니다: <span class="fixed">openFile ::
            FilePath -&gt; IOMode -&gt; IO Handle</span>. 이를 자세히 읽어보면, 다음과 같다는
          것을 알 수 있습니다: <span class="fixed">openFile</span>은 파일경로와 <span class="fixed">IOMode</span>를
          받아, 파일을 열어 결과로 파일에 관계된 핸들을 봉인한 I/O action을 반환한다.</p>
        <p><span class="fixed">FilePath</span>는 <span class="fixed">String</span>과
          <a href="making-our-own-types-and-typeclasses#type-synonyms">동일한 타입</a>이
          며, 다음과 같이 간단하게 정의되었습니다:</p>
        <pre name="code" class="haskell:hs">type FilePath = String
</pre>
        <p><span class="fixed">IOMode</span>의 타입은 다음과 같이 정의되었습니다:</p>
        <pre name="code" class="haskell:hs">data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
</pre> <img src="http://s3.amazonaws.com/lyah/file.png" alt="A FILE IN A CAKE!!!"
          class="left" height="340" width="232">
        <p> 주중 가능한 요일을 나타내는 것과 비슷한 여기 나온 타입은, 연 파일에 대해 어떠한 작업을 하는지 나타내는
          열거(enumeration)입 니다. 이는 매우 단순합니다. 이 타입이&nbsp; <span class="fixed">IOMode</span>인
          지 <span class="fixed">IO Mode</span>가 아닌지에 주목하기만 하면 됩니다. <span class="fixed">IO
            Mode</span>는 어떠한 타입 <span class="fixed">Mode</span>를 결과 값으로 지닌 I/O
          action이지만, <span class="fixed">IOMode</span>는 단지 간단한
          열거(enumeration)입니다.</p>
        <p>마지막으로, 특정 파일을 특정모드로 여는 I/O action을 반환합니다. 이러한 action을 무언가에 bind한다면 <span
            class="fixed">Handle</span>을 얻게됩니다. <span class="fixed">Handle</span>
          타입의 값은 파일의 위치를 나타냅니다. 이 핸들을 이용하여 읽어온 파일의 위치를 알아낼 수 있습니다. 파일 읽어 핸들에
          bind하지 않으면, 파일을 가지고 아무런 일도 못하고 멍하게 있어야 합니다 . 따라서 이러한 경우 핸들을 <span class="fixed">handle</span>에
          bind합니다.</p>
        <p>다음 줄에서, <span class="label function">hGetContents</span>라는 함수를 볼 수
          있습니다. 이는 <span class="fixed">Handle</span>을 취해, 얻어올 내용이 있는 파일의 위치를
          알아내,&nbsp; 파일의 내용을 담고있는 <span class="fixed">IO String</span>을 반환합니다.
          이 함수는 <span class="fixed">getContents</span>와 비슷합니다. 차이점은 <span class="fixed">getContents</span>는
          (터미널에서)표준입력에서 자동적으로 읽어오는 반면,&nbsp; <span class="fixed">hGetContents</span>는
          파일의 위치를 알려주는 파일 핸들을 취합니다. 어떠한 측면에서는, 이 모두 동일한 일을 합니다. <span class="fixed">getContents</span>,
          <span class="fixed">hGetContents</span>는 파일을 한번에 읽어 메모리에 저장하려 하지 않고,
          필요할때 읽습니다. <span class="fixed">contents</span>를 파일의 전체 내용으로 다룰수 있지만,
          실제로 메모리에 적제하지 않는 것은 매우 멋진 일입니다. 그럼으로써, 매우 큰 파일이 있어, <span class="fixed">hGetContents</span>을
          하는 것은 메모리를 고갈시키지 않고 필요한 부분만 파일에서 읽어올 수 있게 됩니다.</p>
        <p><span class="fixed">handle</span>과 <span class="fixed">contents</span>에
          bind된 파일을 지시하는데 사용된 핸들과 파일의 내용의 차이점에 주목하시기 바랍니다. 핸들은 파일이 무엇인지 알고있는 어떠한
          것입니다. 매우 큰 책은 전체 파일 시스템이며 각 장을 파일이라 생각한다면, 핸들은 현재 읽고(쓰고)있는 장을 나타내는
          즐겨찾기이며, 내용은 실재 장에 나타난 것이라고 볼 수 있을 것입니다.</p>
        <p><span class="fixed">putStr contents</span>로 contents를 표준 출력으로 출력한 다음
          <span class="label function">hClose</span>를 하여,&nbsp; 핸들을 취해 파일을 닫는
          I/O action을 반환하도록 하였습니다. <span class="fixed">openFile</span>로 파일을 연
          다음에는 반드시 닫아야만 합니다!</p>
        <p>이를 행할 또 다른 방법으로는, <span class="fixed">withFile :: FilePath -&gt;
            IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a</span> 타입서명을 지닌 <span class="label function">withFile</span>함
          수를 이용하는 것입니다. 파일의 경로, <span class="fixed">IOMode</span>, 핸들을 취하는 함수를
          받아 I/O action을 반환합니다. 반환된 I/O action는 파일을 열어 무언가를 하고 파일을 닫는 작업을 합니다.
          반환된 마지막 I/O action에 봉인된 결과는 저희가 넘겨준 함수가 반환하는 I/O action의 결과와 같습니다.
          복잡하게 들릴지 모르지만 lambda로 하면 매우 단순하며, 여기 <span class="fixed">withFile</span>을
          써서 이전 예제를 다시 작성한게 나와 있습니다:</p>
        <pre name="code" class="haskell:hs">import System.IO   
  
main = do   
    withFile "girlfriend.txt" ReadMode (\handle -&gt; do
        contents &lt;- hGetContents handle   
        putStr contents)
</pre>
        <p>보시다시피,&nbsp; 이는 이전 코드와 매우 유사합니다. <span class="fixed">(\handle -&gt;
            ... )</span>은 핸들을 취해 I/O action을 반환하는 함수이며, 보통 이와 같이 lambda로 합니다.
          단순히 할일을 하고 파일을 닫는 I/O action을 취하는 대신, I/O action을 반환하는 함수를 취하는 이유는 넘겨준
          I/O action이 어떤 파일에 대해 작업해야할지 모르기 때문입니다. 이러한 방식으로, <span class="fixed">withFile</span>는
          파일을 열어 핸들을 함수로 넘겨줍니다. 함수에서 얻은 I/O action으로 파일을 닫는 I/O action을 만듭니다. 여기
          <span class="fixed">withFile</span>함수의 구현 방법이 나와있습니다:</p>
        <pre name="code" class="haskell:hs">withFile' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a
withFile' path mode f = do
    handle &lt;- openFile path mode 
    result &lt;- f handle
    hClose handle
    return result
</pre> <img src="http://s3.amazonaws.com/lyah/edd.png" alt="butter toast" class="right"
          height="360" width="246">
        <p>결과가 I/O action이 될 것이므로, <i>do</i>부터 시작하겠습니다. 우선 파일을 열어 핸들을 얻어옵니다. 그런
          다음, <span class="fixed">handle</span>에 함수를 적용시켜 이 모든 일을 수행할 I/O
          action을 반환받습니다. 이 action을 <span class="fixed">result</span>에 bind하여,
          핸들을 닫은 다음 <span class="fixed">return result</span>를 하였습니다. <span class="fixed">f</span>로
          얻은 I/O action에 봉인된 결과를 <span class="fixed">return</span>받음으로써, I/O
          action은 <span class="fixed">f handle</span>에서 얻은 것과 동일한 결과를 봉인합니다.
          따라서 <span class="fixed">withFile'</span>사용하고&nbsp; <span class="fixed">f
            handle</span>이 표준 입력에서 줄의 갯수를 읽어 파일에 작성하고 읽은 줄의 갯수를 봉인된 결과로 갖는
          action을 반환한다면, 결과 I/O action 또한 읽은 줄의 갯수를 결과로 가질 것입니다.</p>
        <p><span class="fixed">getContents</span>와 비슷한 <span class="fixed">hGetContents</span>함
          수도 있지만 <span class="label function">hGetLine</span>, <span class="label function">hPutStr</span>,
          <span class="label function">hPutStrLn</span>, <span class="label function">hGetChar</span>도
          있습니다. 이들은 <i>h</i>가 없는 것과 대응되는 작업을 하지만 표준 입력이나 표준 출력과 관계된 작업을 하는 대신,
          핸들을 인자로 받아 특정 파일에 동작합니다. 예: <span class="fixed">putStrLn</span>은 문자열을
          취해 터미널에 그 문자열과 개행문자를 출력하는 I/O action을 반환합니다. <span class="fixed">hPutStrLn</span>는
          핸들과 문자열을 취해, 핸들에 연결된 파일에 문자열과 개행문자를 써넣는 I/O action을 반환합니다. 같은 맥락으로, <span
            class="fixed">hGetLine</span>은 핸들을 받아, 파일에서 한 줄을 읽는 I/O action을
          반환합니다.</p>
        <p>파일을 불러와서 그 내용을 문자열로 취급하는 것은 매우 일반적이므로, 이러한 작업을 좀더 편하게 만들 작고 멋진 함수를
          가졌습니다:</p>
        <p> <span class="label function">readFile</span>는 <span class="fixed">readFile
            :: FilePath -&gt; IO String</span> 타입서명을 갖습니다. <span class="fixed">FilePath</span>는
          <span class="fixed">String</span>의 색다른 이름이라는 것을 명심하시기 바랍니다. <span class="fixed">readFile</span>은
          파일의 경로를 받아 파일을 읽어(물론 lazily하게) 그 내용을 무언가에 문자열로 bind하는 I/O action을
          반환합니다. 이는 보통, <span class="fixed">openFile</span>를 활용하여 핸들에 bind한 후 <span
            class="fixed">hGetContents</span>를 실행하는 것보다 훨신 간편합니다. 여기 이전 예제를 어떻게
          <span class="fixed">readFile</span>로 작성하는지가 나와있습니다: </p>
        <pre name="code" class="haskell:hs">import System.IO

main = do
    contents &lt;- readFile "girlfriend.txt"
    putStr contents
</pre>
        <p><span class="fixed">readFile</span>를 이용하면 파일에 대한 핸들을 얻지 않았으므로, 수동으로
          파일을 닫을 수 없기에 하스켈이 대신 처리해 줍니다. </p>
        <p> <span class="label function">writeFile</span>은 <span class="fixed">writeFile
            :: FilePath -&gt; String -&gt; IO ()</span> 타입서명을 갖습니다. 이는 파일의 경로와
          문자열을 취해 파일에 문자열을 써넣는 I/O action을 반환합니다. 파일이 존재한다면 문자열을 써넣기 전에 크기를 0으로
          만듭니다. 여기<i> girlfriend.txt</i>가 대문자화 되어 <i>girlfriendcaps.txt</i>로
          저장되는 것이 나와있습니다: </p>
        <pre name="code" class="haskell:hs">import System.IO   
import Data.Char
  
main = do   
    contents &lt;- readFile "girlfriend.txt"   
    writeFile "girlfriendcaps.txt" (map toUpper contents)
</pre>
        <pre name="code" class="plain">$ runhaskell girlfriendtocaps.hs
$ cat girlfriendcaps.txt
HEY! HEY! YOU! YOU!
I DON'T LIKE YOUR GIRLFRIEND!
NO WAY! NO WAY!
I THINK YOU NEED A NEW ONE!
</pre>
        <p><span class="label function">appendFile</span>는 <span class="fixed">writeFile</span>와
          같은 타입서명을 지니지만, <span class="fixed">appendFile</span>는 파일이 존재하면 크기를
          0으로 만들지 않고 무언가를 덧붙입니다.</p>
        <p>각 줄마다 해야할 작업이 있는 파일 <i>todo.txt</i>가 있다고 가정해 봅시다. 이제 표준입력에서 한 줄을
          받아들여 todo 목록에 추가하는 함수를 만들어보겠습니다.</p>
        <pre name="code" class="haskell:hs">import System.IO   
  
main = do   
    todoItem &lt;- getLine
    appendFile "todo.txt" (todoItem ++ "\n")
</pre>
        <pre name="code" class="plain">$ runhaskell appendtodo.hs
Iron the dishes
$ runhaskell appendtodo.hs
Dust the dog
$ runhaskell appendtodo.hs
Take salad out of the oven
$ cat todo.txt
Iron the dishes
Dust the dog
Take salad out of the oven
</pre>
        <p> <span class="fixed">getLine</span>은 끝에 개행문자를 붙이지 않기에, 각 줄의 끝에 <span
            class="fixed">"\n"</span>를 추가해줘야 합니다.</p>
        <p>워, 하나 더. <span class="fixed">contents &lt;- hGetContents handle</span>가
          전체 파일을 한번에 읽어 메모리에 저장하지 않는다고 예기했습니다. 이는 I/O lazy이므로, 다음과 같이 해야합니다:</p>
        <pre name="code" class="haskell:hs">main = do 
    withFile "something.txt" ReadMode (\handle -&gt; do
        contents &lt;- hGetContents handle
        putStr contents)
</pre>
        <p>이는 실제로 파일에서 출력으로 pipe로 연결한 것과 같습니다. 리스트를 스트림이라 생각할 수 있다면, 파일을 스트림이라
          생각할 수 도 있을것입니다. 이는 한번에 한 줄을 읽어가며 터미널에 출력할 것입니다. 아마 여러분은 'pipe가 얼마나
          넓은가? 얼머나 자주 디스크에 접근할까?' 라고 물어보실 수 도 있을 것입니다. 텍스트 파일에서 기본 버퍼링은 보통 줄단위
          버퍼링이 됩니다. 이는 한번에 파일에서 읽을 가장 작은 단위가 줄 단위라는 것을 의미합니다. 한 줄을 읽고 출력하고, 한 줄을
          읽고 출력하는 이유가 바로 이겁니다. 이진 파일에서의 기본 버퍼링은 보통 블럭-버퍼링이 됩니다. 이는 파일을 덩어리 단위로
          읽는다는 것을 의미합니다. 덩어리의 크기는 운영체제가 생각하기에 괜찮다고 여겨지는 크기가 됩니다.</p>
        <p><span class="fixed">hSetBuffering</span>함수를 이용하여 버퍼링을 제어할 수 있습니다. 이
          함수는 핸들과 <span class="fixed">BufferMode</span>를 취해&nbsp; 버퍼링을 설정하는 I/O
          action을 반환합니다. <span class="fixed">BufferMode</span>은 단순한 열거 자료구조이며,
          가능한 값은 다음과 같습니다: <span class="fixed">NoBuffering</span>, <span class="fixed">LineBuffering</span>,
          <span class="fixed">BlockBuffering (Maybe Int)</span>. <span class="fixed">Maybe
            Int</span>는 덩어리의 크기로 바이트 단위입니다. <span class="fixed">Nothing</span>이
          라면 운영체제가 덩어리의 크기를 결정하게 됩니다. <span class="fixed">NoBuffering</span>는
          한번에 문자 하나를 읽는다는 것을 의미합니다. <span class="fixed">NoBuffering</span>는
          디스크에 많이 접근하기에 버퍼링 모드로는 보통 썩 좋지는 않습니다.</p>
        <p>여기 이전 코드를 줄 단위로 읽는게 아니라 2048 바이트씩 읽도록 한 것이 나와 있습니다.</p>
        <pre name="code" class="haskell:hs">main = do 
    withFile "something.txt" ReadMode (\handle -&gt; do
        hSetBuffering handle $ BlockBuffering (Just 2048)
        contents &lt;- hGetContents handle
        putStr contents)
</pre>
        <p>디스크 접근을 최소화 하거나 느린 네트워크 자원에서, 큰 덩어리 단위로 파일을 읽는 것이 도움이 됩니다.</p>
        <p>또한 <span class="label function">hFlush</span>를 이용할 수 있으며, 이는 핸들을 받아
          handle핸들에 연결돤 파일의 버퍼를 비워주는 I/O action을 반환합니다. 줄단위 버퍼링을 할때, 버퍼는 줄마다
          비워지게 됩니다. 블록 단위 버퍼링을 한다면, 한 덩어리를 읽을때마다 비워지게 됩니다. 또한 핸들을 닫을때도 비워집니다. 개행
          문자를 만나면, 읽는(혹은 쓰는) 매커니즘이 모든 데이터를 날려버린다는 것을 의미합니다. 이제까지 읽은 데이터를 강제로
          보고하는데에도 <span class="fixed">hFlush</span>를 사용할 수 있습니다.&nbsp; flush를
          하고 나면, 동시간에 실행되고 있는 다른 프로그램에서 그 데이터를 이용할 수 있게됩니다.</p>
        <p>블록-버퍼단위로 파일을 읽는 것을 다음과 같이 생각할 수 있습니다: 변기가 있고 물를 내리면 1갤론의 물을 체워넣다고
          가정해봅시다. 물을 내리면 1갤론에 도달하기 까지 자동대로 물을 체울 것이며, 내려진 물 속에 있는 데이터는 읽혀질 것입니다.
          또한 수동으로 변기 레버를 내림으로써 변기 물을 내릴 수 도 있습니다. 변기 물을 내림으로써 변기에 있는 모든 물(데이터)를
          읽을 수 있게 만들어 줍니다. 눈치체셨지도 모르겠지만, 변기 물을 수동으로 내리는 것이 <span class="fixed">hFlush</span>에
          대한 비유였습니다. 이는 프로그래밍적 기준에는 좋은 비유가 아니지만, 핵심을 나타내기 위해 실생활의 물체를 선택했습니다.</p>
        <p> <i>todo.txt</i>에 새로운 항목을 추가하는 프로그램을 만들었으므로, 이번엔 항목을 삭제하는 프로그램을 만들어
          봅시다. 코드를 붙여놓아 같이 살펴보다보면, 실제론 매우 쉽다는 것을 발견하실 수 있을 것입니다.&nbsp; <span class="fixed">System.IO</span>와
          <span class="fixed">System.Directory</span>에 있는 새로운 함수들을 이용할 것이지만, 이들
          모두 설명드릴 것입니다.</p>
        <p>어찌됐건, 여기 <i>todo.txt</i>에서 항목을 제거하는 프로그램이 있습니다:</p>
        <pre name="code" class="haskell:hs">import System.IO
import System.Directory
import Data.List

main = do      
    handle &lt;- openFile "todo.txt" ReadMode
    (tempName, tempHandle) &lt;- openTempFile "." "temp"
    contents &lt;- hGetContents handle
    let todoTasks = lines contents   
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line) [0..] todoTasks   
    putStrLn "These are your TO-DO items:"
    putStr $ unlines numberedTasks
    putStrLn "Which one do you want to delete?"   
    numberString &lt;- getLine   
    let number = read numberString   
        newTodoItems = delete (todoTasks !! number) todoTasks   
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile "todo.txt"
    renameFile tempName "todo.txt"
</pre>
        <p>우선, <i>todo.txt</i>를 읽기모드로 열어서 핸들을 <span class="fixed">handle</span>에
          bind하였습니다. </p>
        <p>다음으로, <span class="fixed">System.IO</span>에서 이제껏 만나지 못했던 <span class="label function">openTempFile</span>함
          수를 이용하였습니다. 이름 참 잘지었습니다. 이는 임시 디렉토리과 파일을 받아 임시파일을 엽니다. <span class="fixed">.</span>는
          어떠한 OS라도 현재 디렉토리라는 것을 알리기에, 임시 디렉토리로 <span class="fixed">"."</span>를
          이용하였습니다. 임시 파일 이름으론 <span class="fixed">"temp"</span>를 사용했으며, 이는 <i>temp</i>란
          이름에 무작위 문자가 붙는 다는 것을 의미합니다. <span class="label function">openTempFile</span>함
          수는 임시 파일을 만드는 I/O action을 반환하고 그 결과는 2개의 값이 됩니다: 임시 파일의 이름과 핸들. <i>todo2.txt</i>나
          비슷한 파일을 열 수도 있지만, 어떠한 파일도 덮어쓰지 않는다는 것을 알 수 있으므로 <span class="fixed">openTempFile</span>를
          사용하는게 좋은 습관이 될 것입니다.</p>
        <p><span class="fixed">getCurrentDirectory</span>을 이용하여 현재 디렉토리를 얻어 <span
            class="fixed">openTempFile</span>로 넘기는 대신, 단순히 <span class="fixed">"."</span>를
          <span class="fixed">openTempFile</span>에 넘긴 이유는 <span class="fixed">.</span>가
          유닉스(유사한) 시스템과 윈도우에서 현재 디렉토리를 가리키기 때문입니다.</p>
        <p>다음으로 넘어가서, <i>todo.txt</i>의 내용을 <span class="fixed">contents</span>에
          bind하였습니다. 그런 다음, 문자열을 줄 단위로 문자열 리스트로 나누었습니다. 따라서 <span class="fixed">todoTasks</span>는
          이제 <span class="fixed">["Iron the dishes", "Dust the dog", "Take
            salad out of the oven"]</span>와 같아질 것입니다. 이 리스트와 0부터 시작하는 숫자를,
          숫자(3)와 문자열(<span class="fixed">"hey"</span>)을 취해 <span class="fixed">"3
            - hey"</span>을 반환하는 함수와 zip시킬 것이므로, <span class="fixed">numberedTasks</span>는
          <span class="fixed">["0 - Iron the dishes", "1 - Dust the dog" ...</span>가
          될 것입니다. 이 문자열 리스트를 <span class="fixed">unlines</span>로 개행문자를 추가하여
          join하여 터미널에 출력할 것입니다. <span class="fixed">mapM putStrLn numberedTasks</span>로
          도 그러한 일을 할 수 있다는 것을 주목하시기 바랍니다.</p>
        <p>저희는 삭제하고자 하는 것이 무엇인지 사용자에게 요청할 것이며, 숫자를 입력할 때까지 기다릴 것입니다. <span class="fixed">Dust
            the dog</span>인 숫자 1을 삭제하려 <span class="fixed">1</span>을 누른다고 가정해
          봅니다, which is <span class="fixed">Dust the dog</span>, so they punch
          in <span class="fixed">1</span>. 현재 <span class="fixed">numberString</span>은
          <span class="fixed">"1"</span>이며, 원하는 것은 문자열이 아닌 숫자이므로 <span class="fixed">read</span>를
          돌려 <span class="fixed">1</span>를 얻은 후 <span class="fixed">number</span>에
          bind합니다.</p>
        <p><span class="fixed">delete</span>와 <span class="fixed">!!</span>함수가
          <span class="fixed">Data.List</span>에서 나왔단 사실을 명심하시기 바랍니다. <span class="fixed">!!</span>는
          리스트와 색인으로 원소를 반환하고 <span class="fixed">delete</span>는 리스트에서 첫번째로 나타난
          것을 지우고, 그 나타난 것을 제외한 새로운 리스트를반환합니다. <span class="fixed">(todoTasks !!
            number)</span> (number는 현재 <span class="fixed">1</span>) 은 <span class="fixed">"Dust
            the dog"</span>을 반환합니다. 첫번째로 나타난&nbsp; <span class="fixed">"Dust
            the dog"</span>을 제외한&nbsp; <span class="fixed">todoTasks</span>를 <span
            class="fixed">newTodoItems</span>에 bind하여, 저희가 연 임시 파일에 작성하기 전에 <span
            class="fixed">unlines</span>으로 하나의 문자열로 join시켰습니다. 이제 예전 파일은 바뀌지 않고,
          임시파일은 삭제한 것을 제외한 예전 파일의 모든 줄을 포함하게 되었습니다.</p>
        <p>원본과 임시파일을 닫은 후에 원본 파일&nbsp;<span class="label function">removeFile</span>로
          지웠습니다. 보시는 바처럼 <span class="label function">removeFile</span>는 파일 경로를
          취해 해당하는 파일을 지웁니다. 예전 <i>todo.txt</i>을 지운 후에, <span class="label function">renameFile</span>을
          이용하여 임시파일을 <i>todo.txt</i>로 이름 바꾸었습니다. <span class="fixed">removeFile</span>과
          <span class="fixed">renameFile</span> (모두 <span class="fixed">System.Directory</span>에
          있긴 하지만)는 핸들이 아닌 파일 경로를 인자로 받는다는 것을 주의하시기 바랍니다.</p>
        <p>이제 끝입니다! 더 적은 라인으로 작성할 수 도 있지만, 기존에 존재하는 파일을 덮어쓰지 않도록 주의해야 하며, 임시파일을
          어디에 두어도 괜찮은지 운영체제에게 공손히 물어봐야만 합니다. 한번 돌려봅시다!</p>
        <pre name="code" class="plain">$ runhaskell deletetodo.hs
These are your TO-DO items:
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven
Which one do you want to delete?
1

$ cat todo.txt
Iron the dishes
Take salad out of the oven

$ runhaskell deletetodo.hs
These are your TO-DO items:
0 - Iron the dishes
1 - Take salad out of the oven
Which one do you want to delete?
0

$ cat todo.txt
Take salad out of the oven
</pre> <a name="command-line-arguments"></a>
        <h2>명령 라인 인자</h2>
        <img src="http://s3.amazonaws.com/lyah/arguments.png" alt="COMMAND LINE ARGUMENTS!!! ARGH"
          class="right" height="380" width="449">
        <p>터미널에서 돌아가는 어플리케이션이나 스크립트를 만든다 한다면, 명령 라인 인자를 처리하는 작업은 필수입니다. 다행히도,
          하스켈의 표준 라이브러리는 프로그램의 명령 라인 인자에 대한 우아한 방법을 지니고 있습니다.</p>
        <p>이전 단락에서, 해야할 일 목록에 할 일들을 추가하는 프로그램 하나와 항목을 추가하는 프로그램을 만들었습니다. 저희가 취한
          접근법에는 두가지 문제가 있습니다. 첫번째는 코드에 to-do 파일의 이름을 하드코드 하였다는 것입니다.&nbsp;<span
            style="font-style: italic;"></span><i>todo.txt</i>라고 파일 이름을 <span style="font-style: italic;"></span>정
          해버려, 사용자는 여러개의 할 일 목록들을 관리하지 못하게 되었습니다.</p>
        <p>이를 해결할 한가지 방법으로는, 사용자에게 항상 할 일 목록으로 사용하고자 하는 파일을 물어보는 것입니다. 사용자가
          삭제하고자 하는 항목을 알고자할때 이러한 접근법을 이용하였습니다. 이는 동작하긴 하지만, 사용자가 프로그램을 실행시키고,
          무언가를 요청하고 요청받는데 기다려야 하기에 별로 좋지는 않습니다. 이러한 것을 interactive 프로그램이라 부르며,
          interactive 명령 라인 프로그램과 조금 다른 차이점을 갖습니다. 스크립트와 같이 프로그램이 자동적으로 실행되길
          원한다면 어떻게 해야할까요? 하나의 프로그램이나 여러 프로그램을 단순히 호출하기만 하는 batch스크립트보다, 프로그램과
          상호작용하는 batch스크립트를 만드는 것이 어려울 것입니다.</p>
        <p>실행중에 사용자에게 요청하는 대신, 프로그램을 실행시킬때 사용자의 요구를 받아들이도록 하면 더 좋을 것입니다. 그리고 더
          나은 방법은, 명령 라인 인자를 통해 사용자가 원하는것을 알려주는 것입니다 !</p>
        <p><span class="fixed">System.Environment</span>모듈은 두가지 훌륭한 I/O action을
          지닙니다. 하나는 <span class="fixed">getArgs :: IO [String]</span>타입을 지닌 <span
            class="label function">getArgs</span>이며, 프로그램을 돌릴시에 인자를 얻어 그 인자 리스트를
          결과로 포함하는 I/O action입니다. <span class="label function">getProgName</span>는
          <span class="fixed">getProgName :: IO String</span>타입을 지니며, 프로그램 이름을
          포함하는 I/O action입니다.</p>
        <p>여기, 이 두 개가 어떻게 동작하는지 보여주는 작은 프로그램이 있습니다:</p>
        <pre name="code" class="haskell:hs"> import System.Environment 
 import Data.List
 
 main = do
    args &lt;- getArgs
    progName &lt;- getProgName
    putStrLn "The arguments are:"
    mapM putStrLn args
    putStrLn "The program name is:"
    putStrLn progName
</pre>
        <p><span class="fixed">getArgs</span>와 <span class="fixed">progName</span>를
          <span class="fixed">args</span>와 <span class="fixed">progName</span>에
          bind하였습니다. <span class="fixed">The arguments are:</span>라 말하고,&nbsp;
          <span class="fixed">args</span>에 있는 모든 인자마다 <span class="fixed">putStrLn</span>를
          실행하였습니다. 마지막으로, 프로그램의 이름을 출력하였습니다. 이를 <span class="fixed">arg-test</span>로
          컴파일을 해봅시다.</p>
        <pre name="code" class="plain">$ ./arg-test first second w00t "multi word arg"
The arguments are:
first
second
w00t
multi word arg
The program name is:
arg-test
</pre>
        <p>훌륭합니다. 이러한 지식으로 무장된 여러분은, 훌륭한 명령 라인 앱을 만들 수 있을 것입니다. 실제로 한번 만들어 봅시다.
          이전 단락에서, 프로그램을 추가하는 작업과 삭제하는 작업으로 나누었습니다. 이제, 명령 라인 인자에 기반한 하나의 프로그램으로
          합칠 것입니다. 또한 <i>todo.txt</i>가 아닌 다양한 파일에 작업할 수 있도록 만들 것입니다.</p>
        <p>이를 단순히 <i>todo</i>라 부를것이며, 이는 3가지 다른 일을 할 수 있어야 합니다:</p>
        <ul>
          <li>보기</li>
          <li>추가</li>
          <li>삭제<br>
          </li>
        </ul>
        <p>지금은 예외적인 입력에 대한 것은 넘어갈 것입니다.</p>
        <p>터미널에 <span class="fixed">todo add todo.txt "Find the magic sword of
            power"</span>를 입력하여, <span class="fixed">Find the magic sword of
            power</span>를 <i>todo.txt</i>파일에 추가는 프로그램을 만들 것입니다. 해야할 작업을 보기 위해선
          <span class="fixed">todo view todo.txt</span>라 해야하며, 두번째에 위치한 작업을
          삭제하려면 <span class="fixed">todo remove todo.txt 2</span>라 해야합니다.</p>
        <p>저희는 먼저 dispatch 연관 리스트를 만드는 것부터 시작할 것입니다. 이는 명령 라인 인자를 키로, 함수를 그에
          대응하는 값으로 갖는 단순한 연관리스트입니다. 함수의 타입은 <span class="fixed">[String] -&gt;
            IO ()</span>가 될 것입니다. 인자 리스트를 취해, 보고, 추가하고, 삭제하는 I/O action을 반환하게 될
          것입니다.</p>
        <pre name="code" class="haskell:hs">import System.Environment 
import System.Directory
import System.IO
import Data.List

dispatch :: [(String, [String] -&gt; IO ())]
dispatch =  [ ("add", add)
            , ("view", view)
            , ("remove", remove)
            ]
</pre>
        <p><span class="fixed">main</span>, <span class="fixed">add</span>, <span
            class="fixed">view</span>, <span class="fixed">remove</span>를 정의하지
          않았으며, <span class="fixed">main</span>부터 시작해 봅시다:</p>
        <pre name="code" class="haskell:hs">main = do
    (command:args) &lt;- getArgs
    let (Just action) = lookup command dispatch
    action args
</pre>
        <p>우선, 인자를 받아들여&nbsp; <span class="fixed">(command:args)</span>에
          bind하였습니다. 패턴 매칭을 기억하신다면, 첫번째 인자는 <span class="fixed">command</span>에
          bind할 것이며 나머지는 <span class="fixed">args</span>에 bind될 것입니다. <span class="fixed">todo
            add todo.txt "Spank the monkey"</span>으로 프로그램을 호출한다면, <span class="fixed">command</span>는
          <span class="fixed">"add"</span>가 될 것이며 <span class="fixed">args</span>는
          <span class="fixed">["todo.xt", "Spank the monkey"]</span>가 될 것입니다.</p>
        <p>다음 줄에선, dispatch 리스트에서 command를 살펴봅니다. <span class="fixed">"add"</span>는
          <span class="fixed">add</span>를 가리킬 것이므로 <span class="fixed">Just add</span>를
          결과로 얻게될 것입니다. 그리고 함수에서 <span class="fixed">Maybe</span>를 배제하기 위해 다시한번
          패턴 매칭을 사용하였습니다. dispatch 리스트에 command가 없으면 어떤일이 발생할까요? command가 없다면
          lookup은 <span class="fixed">Nothing</span>을 반환할 것이며, 이에 대한 대비를 안했기에,
          패턴 매칭은 실패할 것이며 프로그램은 나락으로 떨어질 것입니다.</p>
        <p>마지막으로, 나머지 인자 리스트와 함께 <span class="fixed">action</span>함수를 호출하였습니다.
          이는 리스트의 항목들을 보여주거나 항목을 추가하거나 삭제하는 I/O action을 반환하며, 이러한 action은 <span
            class="fixed">main</span> <i>do</i> 블록의 일부로 수행될 것입니다. 구체적인 예를 들자하면,
          <span class="fixed">action</span>함 수는 <span class="fixed">add</span>이
          며, <span class="fixed">args</span> (<span class="fixed">["todo.txt",
            "Spank the monkey"]</span>)로 호출되어 <span class="fixed">Spank the
            monkey</span>을 <i>todo.txt</i>에 추가하는 I/O action을 반환할 것입니다.</p>
        <p>훌륭합니다! 이제 구현해야 할것으로 <span class="fixed">add</span>, <span class="fixed">view</span>,
          <span class="fixed">remove</span>가 남았습니다. <span class="fixed">add</span>부
          터 시작해봅시다:</p>
        <pre name="code" class="haskell:hs">add :: [String] -&gt; IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")
</pre>
        <p><span class="fixed">todo add todo.txt "Spank the monkey"</span>로
          프로그램이 호출되면, <span class="fixed">"add"</span>는&nbsp; <span class="fixed">main</span>블
          록의 첫번째 패턴 매치에서 <span class="fixed">command</span>에 bind될 것이며,<span class="fixed">["todo.txt",
            "Spank the monkey"]</span>은 dispatch리스트에서 얻은 함수로 넘겨질 것입니다. 지금 당장은
          잘못된 입력을 다루지 않을 것이므로, 곧장 리스트의 두 원소에 대해 패턴 매치를 하여, 개행문자를 포함하여 파일 끝에 그 줄을
          추가하는 I/O action을 반환합니다.</p>
        <p>다음으로, 목록을 확인하는 기능을 구현해 봅시다. 파일에 있는 항목들을 확인하려면, <span class="fixed">todo
            view todo.txt</span>라 할 것입니다. 따라서 처음 패턴 매치에서, <span class="fixed">command</span>는
          <span class="fixed">"view"</span>가 될 것이며 <span class="fixed">args</span>는
          <span class="fixed">["todo.txt"]</span>가 될 것입니다.</p>
        <pre name="code" class="haskell:hs">view :: [String] -&gt; IO ()
view [fileName] = do
    contents &lt;- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line) [0..] todoTasks
    putStr $ unlines numberedTasks
</pre>
        <p>작업들을 보여줘서, 사용자가 삭제할것을 고를수 있게 하는 프로그램에서 이와 똑같은 일을 이미 하였으며, 여기선 단지 작업들만
          보여주도록 하였습니다.</p>
        <p>마지막으로, <span class="fixed">remove</span>를 구현해 봅시다. 이는 작업을 삭제하는 프로그램과
          매우 유사하므로, 어떻게 항목이 삭제되는지 이해하지 못했다면, 다음 프로그램의 설명을 주의깊게 듣기 바랍니다. 주된 차이점은
          <i>todo.txt</i>라 하드코딩하지 않고, 인자로 받았다는 것입니다. 또한, 삭제할 작업 번호를 사용자에게 물어보지
          않고, 인자로 받았습니다.</p>
        <pre name="code" class="haskell:hs">remove :: [String] -&gt; IO ()
remove [fileName, numberString] = do
    handle &lt;- openFile fileName ReadMode
    (tempName, tempHandle) &lt;- openTempFile "." "temp"
    contents &lt;- hGetContents handle
    let number = read numberString
        todoTasks = lines contents
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
</pre>
        <p><span class="fixed">fileName</span>에 해당하는 파일과 임시 파일을 열어, 사용자가 삭제하기를
          원하는 줄을 삭제하여 임시 파일에 저장하고, 원본 파일을 삭제하여 임시파일을 <span class="fixed">fileName</span>으
          로 이름을 바꾸었습니다.</p>
        <p>여기 이 모든것이 들어있는 전체 프로그램이 있습니다!</p>
        <pre name="code" class="haskell:hs">import System.Environment 
import System.Directory
import System.IO
import Data.List

dispatch :: [(String, [String] -&gt; IO ())]
dispatch =  [ ("add", add)
            , ("view", view)
            , ("remove", remove)
            ]
 
main = do
    (command:args) &lt;- getArgs
    let (Just action) = lookup command dispatch
    action args

add :: [String] -&gt; IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")

view :: [String] -&gt; IO ()
view [fileName] = do
    contents &lt;- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line) [0..] todoTasks
    putStr $ unlines numberedTasks

remove :: [String] -&gt; IO ()
remove [fileName, numberString] = do
    handle &lt;- openFile fileName ReadMode
    (tempName, tempHandle) &lt;- openTempFile "." "temp"
    contents &lt;- hGetContents handle
    let number = read numberString
        todoTasks = lines contents
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
</pre> <img src="http://s3.amazonaws.com/lyah/salad.png" alt="fresh baked salad"
          class="left" height="200" width="143">
        <p>저희의 해결책을 요약하자면: 명령 라인 인자에서 명령어와 함수의 연관을 dispatch하여 I/O action을
          반환하였습니다. 저희는 어떤 명령인지 확인할 수 있으며, dispatch 리스트에서 적절한 함수를 얻을 수 있습니다. 나머지
          명령 라인 인자로 함수를 호출하여, 적절한 일을 처리하는 I/O action을 되돌려 받아 그 action을 수행하게 됩니다.</p>
        <p>다른 언어에서는 커다란 switch case문이나 다른 것으로 이를 구현해야만 했을 것입니다. 하지만 저희는 higher
          order 함수를 이용하여 dispatch 리스트로부터 적절한 함수를 돌려 받았으며, 이 함수는 명령 라인 인자에 대한 I/O
          action을 줍니다.</p>
        <p>한번 저희 앱을 돌려봅시다!</p>
        <pre name="code" class="plain">$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven

$ ./todo add todo.txt "Pick up children from drycleaners"

$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven
3 - Pick up children from drycleaners

$ ./todo remove todo.txt 2

$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Pick up children from drycleaners
</pre>
        <p>여기서 또다른 멋있는 점 하나는, 기능을 추가하기 쉽다는 것입니다. 단지, 연관 리스트의 항목을 추가하고, 대응하는 함수를
          구현하고 약간의 웃음만 있으면 됩니다! 연습으로, 파일과 작업 번호를 취해, 그 작업을 to-do리스트의 최 상단으로 올리는
          <span class="fixed">bump</span>함수를 구현해 볼 수 도 있습니다.</p>
        <p>(<span class="fixed">todo UP YOURS HAHAHAHA</span>와 같은) 잘못된 입력에 대해
          error(예로, <span class="fixed">errorExit :: IO ()</span>)를 보고하는 I/O
          action 을 만든다음, 에러를 유발하는 입력인지 확인하고, 만일 그러하다면 error를 보고하는 I/O action을
          수행함으로써 좀더 우아하게 처리하는 프로그램을 만들 수 도 있습니다. 또다른 방법은 저희가 곧 만나게될 예외를 이용하는
          것입니다.</p>
        <a name="randomness"></a>
        <h2>무작위성</h2>
        <img src="http://s3.amazonaws.com/lyah/random.png" alt="this picture is the ultimate source of randomness and wackiness"
          class="right" height="362" width="358">
        <p>프로그래밍을 하면서, 여러분은 무작위 데이터를 얻어오는 작업 많이 해야할 것입니다. 주사위를 던지는 게임을 만들던가,
          프로그램을 테스트하기 위한 데이터를 생성해야만 할지도 모릅니다. 프로그래밍할때 무작위 데이터를 이용하는 경우가 많이 있습니다.
          흠, 사실 이는 가짜입니다. 예측 불가능 한것은, 원숭이가 한손엔 치즈를 다른 한손은 엉덩이에대고 외발자전거를 타는 것입니다.
          이번 단락에서는, 하스켈이 어떻게 (보기에) 무작위 데이터를 만드는지 살펴보도록 하겠습니다.</p>
        <p>대부분의 프로그래밍 언어에는 무작위 수를 돌려주는 함수가 있습니다. 함수를 호출할 때마다, 다양한 무작위 수를 얻게됩니다.
          하스켈은 어떨까요? 흠, 하스켈은 순수한 함수형 언어라는 것을 기억하시기 바랍니다. 이는 참조투명성(referential
          transparency)을 갖는다는 것을의미합니다. 참조투명성은 동일한 인자를 넣으면, 동일한 결과가 생성되는 것입니다.
          이는, 프로그램에 대해 다르게 사고할 수 있으며, 평가가 필요하기 전까지 미룰 수 있는 매우 멋진 기능입니다. 함수를
          호출한다고 한다면, 결과를 돌려주기 전에는 어떠한 재미난 일도 하지 않는 다는 것을 확신할 수 있습니다. 중요한 것은
          결과입니다. 하지만 이는 무작위 수를 얻기에 곤란합니다. 다음과 같은 함수가 있다고 가정해봅시다:</p>
        <pre name="code" class="haskell:hs">randomNumber :: (Num a) =&gt; a
randomNumber = 4
</pre>
        <p>항상 <span class="fixed">4</span>를 반환할 것이기에, 유용한 무작위 수 함수가 아닙니다. (하지만,
          저는 4가 완벽한 무작위 수라고 말할 수 있습니다. 제 주사위의 눈꿈이 모두 4이기 때문입니다)</p>
        <p>다른 언어는 무작위 수를 어떻게 만들까요? 컴퓨터에서 현재 시간, 마우스의 좌표와 컴퓨터 내부에서 일어나는 노이즈 비슷한
          변하는 것을 취해, 실제 무작위 수처럼 보이는 숫자를 돌려줍니다. 이러한 요소들의 조합이 순간마다 아마도 다양한 수를 돌려
          줌으로, 다양한 무작위 수를 얻을 수 있습니다.</p>
        <p>아. 하스켈에서는, 무작위 수를 만들어 인자로 취하고 이에 기반하는 어떠한 숫자(혹은 다른 타입)를 반환할 수 도 있습니다.</p>
        <p><span class="fixed">System.Random</span>모듈로 들어가봅시다. 이는 무작위성을 만족시켜줄
          함수를 가지고 있습니다. 이것을 export하여 <span class="label function">random</span>함
          수를 좀더 살펴봅시다. 여기 타입이 나와 있습니다: <span class="fixed">random :: (RandomGen
            g, Random a) =&gt; g -&gt; (a, g)</span>. 우와! 이 타입 선언에는 새로운 타입클래스가
          있습니다! <span class="label class">RandomGen</span>타 입클래스는 무작위성의 근본으로 하는
          타입을 위한 것입니다. <span class="label class">Random</span>타입클래스는 무작위 값을 취할
          수 있습니다. 부울값으로 취할 수 있는 무작위 값은&nbsp; <span class="fixed">True</span>나 <span
            class="fixed">False</span>입니다. 숫자로는 엄청나게 다양한 무작위 수를 취할 수 있습니다. 함수가
          무작위 값을 취할 수 있을까요? 잘 모르겠지만, 아마도 안될 것입니다!&nbsp; <span class="fixed">random</span>의
          타입선언을 영어로 번역한다면, 이와 같은 것을 얻게될 것입니다: (무작위성의 원천인)난수 발생기를 취해 무작위 값과 새로운
          난수 발생기를 반환한다. 무작위 값 말고도 새로운 난수 발생기를 반환하는 이유가 무엇일까요? 흠, 곧 만나보도록 하겠습니다.</p>
        <p><span class="fixed">random</span>함수를 이용하여, 난수 발생기를 손에 얻을 수 있습니다. The
          <span class="fixed">System.Random</span>모듈은 <span class="fixed">RandomGen</span>
          타입클래스의 인스턴스인 <span class="label type">StdGen</span>라는 멋진 타입을 export
          합니다. 저희는 수동으로 <span class="fixed">StdGen</span>을 만들거나, 무작위스러운 다양한 것에
          기반한 무언가를 시스템에게 요구할 수 있습니다.</p>
        <p> <span class="label function">mkStdGen</span>함수를 이용하여 난수를 생성하는 장치를
          만들어보도록 하겠습니다. mkStdGen은 <span class="fixed">mkStdGen :: Int -&gt;
            StdGen</span>타입을 지녔습니다. 이는 정수를 취해 이에 기반한 난수를 생성합니다. 좋습니다. 이제 <span
            class="fixed">random</span>과 <span class="fixed">mkStdGen</span>을
          동시에 이용하여 (난수에 가까운) 수를 얻어 봅시다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; random (mkStdGen 100)
</pre>
        <pre name="code" class="plain">&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraint:
      `Random a' arising from a use of `random' at &lt;interactive&gt;:1:0-20
    Probable fix: add a type signature that fixes these type variable(s)
</pre>
        <p>이게 뭘까요? 아, 맞습니다. <span class="fixed">random</span>함수는 <span class="fixed">Random</span>타
          입클래스의 타입값을 반환하므로, 하스켈에게 저희가 원하는 타입을 알려줘야 합니다. 또한 무작위 값과 난수 발생기를 쌍으로
          반환한 다는 것을 잊지 마시기 바랍니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)
(-1352021624,651872571 1655838864)
</pre>
        <p>마침내 난수가 나타났습니다! 튜플의 첫번째 구성물은 숫자이며, 두번째 구성물은 새로운 난수 발생기를 문자로 표현한 것입니다.
          동일한 난수 발생기에 <span class="fixed">random</span>을 호출하면 어떠한 일이 발생할까요?</p>
        <pre name="code" class="haskell:hs">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)
(-1352021624,651872571 1655838864)
</pre>
        <p>물론 동일한 인자에 동일한 결과가 나타났습니다. 그럼 다른 난수 발생기를 인자로 넣어보도록 하겠습니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; random (mkStdGen 949494) :: (Int, StdGen)
(539963926,466647808 1655838864)
</pre>
        <p>오우 좋습니다. 다른 숫자입니다. 함수에 타입 어노테이션을 사용하여 다양한 타입을 돌려받을 수 있습니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; random (mkStdGen 949488) :: (Float, StdGen)
(0.8938442,1597344447 1655838864)
ghci&gt; random (mkStdGen 949488) :: (Bool, StdGen)
(False,1485632275 40692)
ghci&gt; random (mkStdGen 949488) :: (Integer, StdGen)
(1691547873,1597344447 1655838864)
</pre>
        <p>동전을 세번 던지는 함수를 만들어 봅시다. <span class="fixed">random</span>이 새로운
          난수발생기를 반환하지 않는다면, 저희는 인자로 3개의 난수 발생기를 받아, 각각에 대해 동전을 던지는 함수를 만들어야 합니다.
          하지만, 좀 이상합니다. 난수 발생기가 <span class="fixed">Int</span>타입의 난수를 생성할 수
          있으면, 3개의 동전을 던질 수 있어야 합니다. 따라서 값과 함께 새로운 난수 발생기를 반환하는 <span class="fixed">random</span>은
          매우 편리합니다.</p>
        <p>동전을 단순하게 <span class="fixed">Bool</span>로 나타내도록 하겠습니다. <span class="fixed">True</span>는
          앞면, <span class="fixed">False</span>는 뒷면입니다.</p>
        <pre name="code" class="haskell:hs">threeCoins :: StdGen -&gt; (Bool, Bool, Bool)
threeCoins gen = 
    let (firstCoin, newGen) = random gen
        (secondCoin, newGen') = random newGen
        (thirdCoin, newGen'') = random newGen'
    in  (firstCoin, secondCoin, thirdCoin)
</pre>
        <p>난수발생기에 <span class="fixed">random</span>을 호출하여 동전과 새로운 난수 발생기를 인자로
          받았습니다. 그런 다음 두번째 동전을 얻기위해 새로운 난수발생기로 다시 호출하였습니다. 세번째 동전에도 동일하게 하였습니다.
          동일한 난수 발생기로 호출한다면, 동전은 모두 같은 값기 될 것이므로 <span class="fixed">(False,
            False, False)</span>나 <span class="fixed">(True, True, True)</span>를
          결과로 얻게 될 것입니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; threeCoins (mkStdGen 21)
(True,True,True)
ghci&gt; threeCoins (mkStdGen 22)
(True,False,True)
ghci&gt; threeCoins (mkStdGen 943)
(True,False,True)
ghci&gt; threeCoins (mkStdGen 944)
(True,True,True)
</pre>
        <p><span class="fixed">random gen :: (Bool, StdGen)</span>라고 하지 않은것에
          주목하시기 바랍니다. 저희가 이미 함수의 타입선언에 부울값을 명시했기 때문입니다. 이것이 바로 하스켈이 저희가 부울값을
          원한다는 것을 추론할 수 있게된 까닭입니다..</p>
        <p>4개 혹은 5개의 동전을 돌린다면 어떻게 될까요? 난수 발생기를 받아 그에 기반하는 무한한 값들을 반환하는 <span class="label function">randoms</span>함
          수가 있습니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Int]
[-1807975507,545074951,-1015194702,-1622477312,-502893664]
ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Bool]
[True,True,True,True,False]
ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Float]
[7.904789e-2,0.62691015,0.26363158,0.12223756,0.38291094]
</pre>
        <p>왜 <span class="fixed">randoms</span>는 새로운 난수 발생기를 리스트로 반환하지 않을까요? <span
            class="fixed">randoms</span>함수를 다음과 같이 매우 쉽게 구현할 수 있습니다:</p>
        <pre name="code" class="haskell:hs">randoms' :: (RandomGen g, Random a) =&gt; g -&gt; [a]
randoms' gen = let (value, newGen) = random gen in value:randoms' newGen
</pre>
        <p>재귀적으로 정의하였습니다. 현재 난수 발생기에서 무작위 값과 새로운 난수 발생기를 얻어, head를 값으로 갖고 새로운 난수
          발생기에 기반한 무작위 숫자를 tail로 하는 리스트를 만들었습니다. 잠재적으로 무한한 수를 생성하기에, 새로운 난수 발생기를
          돌려 받을 수 없습니다.</p>
        <p>다음과 갈이 숫자와 새로운 난수 발생기를 무한하게 생성하는 함수를 만들 수 있습니다:</p>
        <pre name="code" class="haskell:hs">finiteRandoms :: (RandomGen g, Random a, Num n) =&gt; n -&gt; g -&gt; ([a], g)
finiteRandoms 0 gen = ([], gen)
finiteRandoms n gen = 
    let (value, newGen) = random gen
        (restOfList, finalGen) = finiteRandoms (n-1) newGen
    in  (value:restOfList, finalGen)
</pre>
        <p>이 역시 재귀적인 정의입니다. 숫자가 0이라면, 비어있는 리스트와 넘겨준 난수 발생기를 반환받는다고 하였습니다. 다른
          숫자라면, 무작위 수와 새로운 난수 발생기를 얻게됩니다. 여기서 무작위 수는 head가 될 것입니다. 그리고 tail은 새로운
          난수발생기로 생성된 <i>n - 1</i>개의 숫자가 될 것입니다. 그런 다음 head와 나머지 리스트를 합친것과, <i>n
            - 1</i>번째 난수에서 얻은 마지막 난수발생기를 반환합니다.</p>
        <p>어떠한 범위안에서 무작위 값을 얻으려 한다면 어떻게 할까요? 지금까지 난수들은 매우 크거나 작았습니다. 주사위를 던진다고
          가정하면 어떨까요? 흠, 이러한 목적에는 <span class="label function">randomR</span>을
          사용하는게 좋습니다. 타입은&nbsp; <span class="fixed">random</span>과 비슷한<span class="fixed">randomR
            :: (RandomGen g, Random a) :: (a, a) -&gt; g -&gt; (a, g)</span>이며,
          상한값과 하한값의 쌍을 첫번째 인자로 받으며, 최종값은 이 범위 사이에 있는 값이 될 것입니다.</p>
        <p> </p>
        <pre name="code" class="haskell:hs">ghci&gt; randomR (1,6) (mkStdGen 359353)
(6,1494289578 40692)
ghci&gt; randomR (1,6) (mkStdGen 35935335)
(3,1250031057 40692)
</pre>
        <p>지정된 범위에서 난수 스트림을 생성하는 <span class="label function">randomRs</span>도
          마찬가지 입니다. 확인해 봅시다:</p>
        <pre name="code" class="haskell:hs">ghci&gt; take 10 $ randomRs ('a','z') (mkStdGen 3) :: [Char]
"ndkxbvmomg"
</pre>
        <p>멋집니다. 강력한 비밀번호처럼 보입니다.</p>
        <p>여러분 스스로 되물어 볼 지도 모르겠습니다. what does this section have to do with I/O
          anyway? 지금까지 I/O에 관한 어떠한 것오 하지 않았습니다. 또한, 지금까지 저희는 임의의 정수를 만듬으로써 난수
          발생기를 수동으로 돌렸습니다. 문제는 실 프로그램에서 이렇게 한다면 항상 동일한 난수를 얻게 될 것이라는 것이며, 이는 좋지
          않습니다. 이것이 바로 <span class="fixed">System.Random</span>이 <span class="fixed">IO
            StdGen</span>의 타입을 지닌 <span class="label function">getStdGen</span>
          I/O action을 제공하는 이유입니다. 프로그램이 시작하면, 이는 시스템에게 난수 발생기로 괜찮은 녀석을 얻어와서 전역
          난수 발생기에 저장합니다. 이러한 전역 난수 발생기를 여러분이 무언가에 bind할때&nbsp; <span class="fixed">getStdGen</span>가
          가져옵니다.</p>
        <p>여기 문자열을 무작위로 생성하는 간단한 프로그램이 있습니다.</p>
        <pre name="code" class="haskell:hs">import System.Random

main = do
    gen &lt;- getStdGen
    putStr $ take 20 (randomRs ('a','z') gen)
</pre>
        <pre name="code" class="plain">$ runhaskell random_string.hs
pybphhzzhuepknbykxhe
$ runhaskell random_string.hs
eiqgcxykivpudlsvvjpg
$ runhaskell random_string.hs
nzdceoconysdgcyqjruo
$ runhaskell random_string.hs
bakzhnnuzrkgvesqplrx
</pre>
        <p><span class="fixed">getStdGen</span>를 두번 수행하는 것은 시스템에 동일한 전역 난수발생기 두번
          요청하는 것이기에 주의하시기 바랍니다. 다음과 같이 한다 가정해 봅시다:</p>
        <pre name="code" class="haskell:hs">import System.Random

main = do
    gen &lt;- getStdGen
    putStrLn $ take 20 (randomRs ('a','z') gen)
    gen2 &lt;- getStdGen
    putStr $ take 20 (randomRs ('a','z') gen2)
</pre>
        <p>두번 모두 출력된 문자열이 같을 것입니다! 길이가 20인 서로 다른 문자열을 얻기 위해선, 스트림을 무한하게 설정하여 처음
          20문자를 취하여 출력한 다음, 두번째로 20문자를 취해 다음 줄에 출력하는 것입니다. 이러한 일에, 리스트를 어떠한 인덱스로
          나누어 튜플로 반환하는 <span class="fixed">Data.List</span>의 <span class="fixed">splitAt</span>를
          사용할 수 있습니다.</p>
        <pre name="code" class="haskell:hs">import System.Random
import Data.List

main = do
    gen &lt;- getStdGen
    let randomChars = randomRs ('a','z') gen
        (first20, rest) = splitAt 20 randomChars
        (second20, _) = splitAt 20 rest
    putStrLn first20
    putStr second20
</pre>
        <p>또 다른 방법은 현재 난수 발생기를 두개로 나누는 <span class="label function">newStdGen</span>
          action을 이용하는 것입니다. 이는 전역 난수 발생기를 갱신하여 새로운 것을 결과로 감싸도록 하는 것입니다.</p>
        <pre name="code" class="haskell:hs">import System.Random

main = do   
    gen &lt;- getStdGen   
    putStrLn $ take 20 (randomRs ('a','z') gen)   
    gen' &lt;- newStdGen
    putStr $ take 20 (randomRs ('a','z') gen')   
</pre>
        <p><span class="fixed">newStdGen</span>를 다른 것에 bind하면 새로운 난수 발생기를 얻을 뿐만
          아니라 전역 난수 발생기 갱신되므로,&nbsp; <span class="fixed">getStdGen</span>을 하여
          다른 것에 bind한다면 <span class="fixed">gen</span>과는 다른 난수 발생기를 얻게 될 것입니다.</p>
        <p>여기 사용자가 숫자를 알아맞추는 자그마한 프로그램이 있습니다.</p>
        <pre name="code" class="haskell:hs">import System.Random
import Control.Monad(when)

main = do
    gen &lt;- getStdGen
    askForNumber gen

askForNumber :: StdGen -&gt; IO ()
askForNumber gen = do
    let (randNumber, newGen) = randomR (1,10) gen :: (Int, StdGen)
    putStr "Which number in the range from 1 to 10 am I thinking of? "
    numberString &lt;- getLine
    when (not $ null numberString) $ do
        let number = read numberString
        if randNumber == number 
            then putStrLn "You are correct!"
            else putStrLn $ "Sorry, it was " ++ show randNumber
        askForNumber newGen
</pre> <img src="http://s3.amazonaws.com/lyah/jackofdiamonds.png" alt="jack of diamonds"
          class="left" height="280" width="313">
        <p><span class="fixed">askForNumber</span>란 함수를 만들었는데, 이 함수는 난수 발생기를
          취해&nbsp; 사용자에게 숫자를 물어 추측한 값이 맞는지 알려주는 I/O action을 반환합니다. 이 함수에서, 저희는
          우선 인자로 받은 난수발생기로 난수와 새로운 난수 발생기를 생성하고 이들을 <span class="fixed">randNumber</span>와
          <span class="fixed">newGen</span>로 하였습니다. Let's say 생성된 숫자가 <span class="fixed">7</span>이
          라고 가정해 봅시다.&nbsp; 사용자에게 저희가 생각한 수가 무엇인지 물어볼 것입니다. <span class="fixed">getLine</span>을
          수행하여 결과를 <span class="fixed">numberString</span>에 bind하였습니다.
          사용자가&nbsp; <span class="fixed">7</span>을 입력하면, <span class="fixed">numberString</span>는
          <span class="fixed">"7"</span>이 될 것입니다. 다음으로, 사용자가 입력한 문자열이 빈 문자열인지
          확인하기 위해&nbsp; <span class="fixed">when</span>을 이용하였습니다. 빈 문자열이라면, 사실상
          프로그램을 종료하는 빈 I/O action인 <span class="fixed">return ()</span>이 수행됩니다.
          빈 문자열이 아니라면, 바로 옆에 있는 <i>do</i>블록이 구성하고 있는 action이 수행됩니다. 다음으로 <span
            class="fixed">numberString</span>에 <span class="fixed">read</span>를
          사용하여 숫자로 변환시켜, <span class="fixed">number</span>는 이제&nbsp; <span class="fixed">7</span>이
          됬습니다.</p>
        <div class="hintbox"><b>잠시만요!</b> : 사용자가 (<span class="fixed">"haha"</span>와
          같이) <span class="fixed">read</span>가 읽지 못하는 입력을 넣으면, 프로그램은&nbsp; 이상한
          에러 메시지를 뿜어내며 멈출 것입니다. 이상한 입력에 대해 프로그램이 멈추지 않길 원한다면, 문자열을 읽어들이는데 실패하면 빈
          리스트를 반환하는 <span class="label function">reads</span>를 사용하시기 바랍니다.
          읽어들이는데 성공하면, 이는 원하는 값과 읽히지 못한 값으로된 싱글톤 튜플 리스트를 반환합니다.</div>
        <p>입력한 숫자가 무작위로 생성된 값과 동일한지 확인하여 사용자에게 적절한 메시지를 전달하였습니다. 그런 다음 새로운 난수
          발생기로 <span class="fixed">askForNumber</span>을 재귀적으로 호출하였습니다.</p>
        <p><span class="fixed">main</span>은 단순히 시스템에서 난수 발생기를 얻어 초기 action을 얻기위해
          <span class="fixed">askForNumber</span>를 호출하는 걸로 구성되었습니다.</p>
        <p>여기 프로그램이 동작하는게 나와있습니다!</p>
        <pre name="code" class="plain">$ runhaskell guess_the_number.hs
Which number in the range from 1 to 10 am I thinking of? 4
Sorry, it was 3
Which number in the range from 1 to 10 am I thinking of? 10
You are correct!
Which number in the range from 1 to 10 am I thinking of? 2
Sorry, it was 4
Which number in the range from 1 to 10 am I thinking of? 5
Sorry, it was 10
Which number in the range from 1 to 10 am I thinking of?

</pre>
        <p>다음과 같이 만들 수 도 있습니다:</p>
        <pre name="code" class="haskell:hs">import System.Random
import Control.Monad(when)

main = do
    gen &lt;- getStdGen
    let (randNumber, _) = randomR (1,10) gen :: (Int, StdGen)   
    putStr "Which number in the range from 1 to 10 am I thinking of? "
    numberString &lt;- getLine
    when (not $ null numberString) $ do
        let number = read numberString
        if randNumber == number
            then putStrLn "You are correct!"
            else putStrLn $ "Sorry, it was " ++ show randNumber
        newStdGen
        main
</pre>
        <p>난수 발생기를 취해, 새롭게 갱신된 난수발생기로 재귀적으로 호출하는 함수를 만든게 아니라, 이 모든것을 <span class="fixed">main</span>에
          서 처리했다는 점을 제외하면 이전 버전과 매우 유사합니다. 여기선 추측값이 맞나 틀리나를 사용자에게 알려준 후에, 전역 난수
          발생기를 갱신하여 <span class="fixed">main</span>를 다시 호출하였습니다. 이러한 두 접근법 모두
          유효하나, 저는 처음 것을 선호하는데, <span class="fixed">main</span>이 짧고 함수를 쉽게 재활용할
          수 있기 때문입니다.</p>
        <a name="bytestrings"></a>
        <h2>Bytestrings</h2>
        <img src="http://s3.amazonaws.com/lyah/chainchomp.png" alt="like normal string, only they byte ... what a pedestrian pun this is"
          class="right" height="390" width="306">
        <p>리스트는 훌륭하고 유용한 자료구조입니다. 저희는 지금까지 이를 잘 써왔습니다. 리스트를 다루는 다양한 함수들이 있으며
          Haskell의 laziness로 인해 다른언어에서의 for나 while 루프의 대용으로 리스트를 filtering하거나
          mapping하도록 사용할 수 있으며, 오직 필요할 시에만 평가가 이루어지기에 무한 리스트도(심지어 무한리스트의
          무한리스트도!) 문제가 되지 않습니다. 이것이 바로, 표준 입력이나 파일에서 무언가를 읽을시 스트림을 표현하는데 리스트를
          사용할 수 있는 이유입니다. 필요시에만 접근할 수 있지만, 저희는 파일을 열어 문자열로 읽을 수도 있습니다.</p>
        <p>하지만, 파일을 문자열로 처리하는데 있어 한가지 문제점이 있습니다: 느려지는 경향이 있습니다. 아시다시피 <span class="fixed">String</span>은
          <span class="fixed">[Char]</span>와 같습니다. <span class="fixed">Char</span>는
          몇바이트를 취해 유니코드와 같은 문자를 표현하기에 고정된 크기를 갖지 않습니다. 더욱이, 리스트는 매우 lazy합니다. <span
            class="fixed">[1,2,3,4]</span>와 같은 리스트가 있다면, 진짜로 필요할 때에만 평가가 될 것입니다.
          따라서 이 리스트 전체는 예비 리스트와 갔습니다. <span class="fixed">[1,2,3,4]</span>는&nbsp;
          <span class="fixed">1:2:3:4:[]</span>에 대한 syntax suger라는 것을 명심하시기
          바랍니다. 리스트의 첫번째 원소가 (출력하여)평가되더라도, 나머지 리스트 <span class="fixed">2:3:4:[]</span>는
          여전히 예비리스트로 남아있습니다. 따라서 저희는 리스트를 필요시 다음 원소가 배달되는 예비리스트라 생각할 수 있습니다. '단순
          한 숫자 리스트를&nbsp; 예비리스트처럼 처리하는 것이 세상에서 가장 효율적이지 않을 수 도 있겠다'라고 판단내리기 까지는
          길게 생각할 필요도 없을 것입니다..</p>
        <p>대부분의 경우 이러한 오버헤드가 저희를 괴롭히는건 아니지만, 큰 파일을 읽거나 다룰때 골칫거리로 대두됩니다. 이것이 바로
          하스켈이 <em>bytestrings</em>을 지니고 있는 까닭입니다. Bytestring은 리스트와 비슷하지만, 각
          항목이 1바이트(8비트)의 크기를 갖습니다. 또한 laziness를 다루는 방식 역시 다릅니다.</p>
        <p>Bytestrings은 두가지 종류가 있습니다: strict와 lazy. Strict bytestrings은 <span class="fixed">Data.ByteString</span>에
          있으며 laziness를 철저히 배재합니다. 여기에는 예비란 없습니다; strict bytestring은 배열속 연속된
          바이트들을 표현합니다. 저희는 무한한 strict bytestrings을 가질 수 없습니다. strict bytestring의
          첫번째 바이트를 평가한다면, bytestring 전체가 평가될 것입니다. 긍정적인 면은 (기술 용어로 <i>promise</i>를
          나타내는)thunk가 관여하지 않기에 오버헤드가 적습니다. 부정적인 면은 한번에 메모리에 읽어들이게에 메모리를 빨리 체운다는
          것입니다.</p>
        <p><span class="fixed">Data.ByteString.Lazy</span>에는 또다른 bytestring 변종이
          살고 있습니다. 이 변종은 lazy하지만, lists의 lazy만큼은 아닙니다. 전에 말했던 것처럼, 리스트의 원소처럼
          많은수의 thunk가 있습니다. That's what makes them kind of slow for some
          purposes. Lazy bytestrings은 다른 접근법을 취하였습니다 — 덩어리(chunks) 단위로 저장합니다
          (thunks와 혼동하지 않길 바랍니다!), 각 덩어리는 64K의 크기를 가졌습니다. 따라서 lazy bytestring에
          있는 byte를 평가한다면 (출력하거나 어떠한 일을 함으로써), 처음 64K가 평가될 것입니다. 그런다음, 나머지 덩어리들은
          예비로 남아 있을 것입니다. Lazy bytestrings은 크기가 64K인 strict bytestrings인 리스트와
          비슷합니다. lazy bytestrings으로 파일을 처리한다면, 덩어리 단위로 읽을 것입니다. 이는 상당히 멋진데, 메모리를
          급격하게 많이 사용하지 않으며, 64K는 아마도 여러분의 CPU's L2 캐쉬에 거의 딱 맞을 것이기 때문입니다.<br>
        </p>
        <p><span class="fixed">Data.ByteString.Lazy</span>에 대한 <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html">문
            서</a>를 살펴본다면, 상당수의 함수들이 <span class="fixed">Data.List</span>와 동일한
          이름을 가졌고, 타입 서명만이 <span class="fixed">[a]</span>대신 <span class="fixed">ByteString</span>,
          <span class="fixed">a</span>대신 <span class="fixed">Word8</span>로 다르다는
          점을 발견할 것입니다. 동일한 이름을 가진 함수들은 리스트에 동작한 것과 거의 동일한 일을 행합니다. 이름이 같기에,
          스크립트에서 qualified import를 하여, bytestrings에 대해 동작하도록 GHCI에서 스크립트를
          로드하였습니다. </p>
        <pre name="code" class="haskell:hs">import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString as S
</pre>
        <p><span class="fixed">B</span>는 lazy bytestring 타입들과 함수들을 지닌 반면, <span
            class="fixed">S</span>는 strict한 것을 지녔습니다. 저희는 주로 lazy 버전을 사용할 것입니다.</p>
        <p><span class="function label">pack</span> 함수는 <span class="fixed">pack
            :: [Word8] -&gt; ByteString</span> 타입서명을 지녔습니다. 이는 <span class="fixed">Word8</span>타
          입인 byte 리스트를 취해 <span class="fixed">ByteString</span>을 반환한다는 것을
          의미합니다. lazy한 리스트를 취해 64K에서만 lazy하도록 덜 lazy하게 만든다고 생각하시면 됩니다.</p>
        <p><span class="fixed">Word8</span>타입이 하는 일은 무엇일까요? 흠, 이는 더 적은 0-255 범위를
          갖는다는 점을 제외하면 <span class="fixed">Int</span>와 같습니다. 이는 8비트 숫자를 표현합니다.
          또한 <span class="fixed">Int</span>와 같이, <span class="fixed">Num</span>타
          입클래스에 속합니다. 예를들어, 여러분은 값 <span class="fixed">5</span>가&nbsp; 다양한 수치
          타입으로 행동할 수 있는 다양성을 갖고있다는 것을 알고 있습니다. 저희는 이 값을 <span class="fixed">Word8</span>타
          입으로 취할 수 도 있습니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; B.pack [99,97,110]
Chunk "can" Empty
ghci&gt; B.pack [98..120]
Chunk "bcdefghijklmnopqrstuvwx" Empty
</pre>
        <p>보시다시피, 타입 시스템이 그에 맞는 타입을 선택하도록 만들어 주기에, <span class="fixed">Word8</span>에
          대해 별로 걱정할 필요가 없습니다. <span class="fixed">336</span>와 같이 큰 숫자에 <span class="fixed">Word8</span>을
          이용한다면, <span class="fixed">80</span>은 떨어져 나갈 것입니다.</p>
        <p>저희는 <span class="fixed">ByteString</span>에 유효한 값들만 pack하였으므로, 덩어리
          하나에 꼭 맞게 됩니다. <span class="fixed">Empty</span>는 리스트의 <span class="fixed">[]</span>와
          같습니다.</p>
        <p><span class="label function">unpack</span>은&nbsp; <span class="fixed">pack</span>의
          반대되는 함수입니다. bytestring을 취해 byte 리스트로 변환시킵니다.</p>
        <p><span class="label function">fromChunks</span>는 strict bytestring
          리스트를 취해 lazy bytestring으로 변환시킵니다. <span class="label function">toChunks</span>은
          lazy bytestring을 취해 strict한 리스트로 변환시킵니다.<br>
        </p>
        <pre name="code" class="haskell:hs">ghci&gt; B.fromChunks [S.pack [40,41,42], S.pack [43,44,45], S.pack [46,47,48]]
Chunk "()*" (Chunk "+,-" (Chunk "./0" Empty))
</pre>
        <p>많은수의 자그마한 strict bytestring들을 가졌고,&nbsp; 메모리에 하나의 커다란 strict
          bytestring으로 합치지 않고 효율적으로 처리하길 원한다면 이러한 방식이 좋습니다.</p>
        <p>bytestring의 <span class="fixed">:</span>는 <span class="label function">cons</span>라
          불리며, byte와 bytestring을 취해 byte를 bytestring앞에 놓습니다. 이 또한 lazy이기에,
          bytestring의 첫번째 덩어리가 꽉 차지 않더라도 새로운 덩어리를 만들 것입니다. 이것이 바로, bytestring 앞에
          커다란 byte를 삽입하고자 한다면 strict한 <span class="fixed">cons</span>인, <span
            class="label function">cons'</span>를 사용하는게 좋은 이유입니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; B.cons 85 $ B.pack [80,81,82,84]
Chunk "U" (Chunk "PQRT" Empty)
ghci&gt; B.cons' 85 $ B.pack [80,81,82,84]
Chunk "UPQRT" Empty
ghci&gt; foldr B.cons B.empty [50..60]
Chunk "2" (Chunk "3" (Chunk "4" (Chunk "5" (Chunk "6" (Chunk "7" (Chunk "8" (Chunk "9" (Chunk ":" (Chunk ";" (Chunk "&lt;"
Empty))))))))))
ghci&gt; foldr B.cons' B.empty [50..60]
Chunk "23456789:;&lt;" Empty
</pre>
        <p>보시다시피, <span class="label function">empty</span>는 비어있는 bytestring을
          만듭니다.&nbsp; <span class="fixed">cons</span>와 <span class="fixed">cons'</span>의
          차이점을 아십니까? <span class="fixed">foldr</span>로, 비어있는 bytestring에서 시작하여
          우측에서 숫자 리스트를 넘겨받아 각 숫자를 bytestring의 시작부분에 추가하였습니다. <span class="fixed">cons</span>을
          사용하게 되면 목적에 반하게 바이트마다 chunk가 들어가게 됩니다.</p>
        <p>반면 bytestring 모듈은 <span class="fixed">head</span>, <span class="fixed">tail</span>,
          <span class="fixed">init</span>, <span class="fixed">null</span>, <span
            class="fixed">length</span>, <span class="fixed">map</span>, <span
            class="fixed">reverse</span>, <span class="fixed">foldl</span>, <span
            class="fixed">foldr</span>, <span class="fixed">concat</span>, <span
            class="fixed">takeWhile</span>, <span class="fixed">filter</span>,
          등등을 포함하여 <span class="fixed">Data.List</span>에 있는 것들과 유사한 함수들을 지니고 있을
          뿐만 아니라, 다른 것들도 포함하고 있습니다. </p>
        <p>또한 <span class="fixed">String</span>이 <span class="fixed">ByteString</span>로
          바뀐점을 제외하면, <span class="fixed">System.IO</span>에서 발견할 수 있는 함수들과 동일한
          행동을 하는 동일한 이름의 함수를 갖고 있습니다. 예를들어,<span class="fixed">System.IO</span>에
          있는 <span class="fixed">readFile</span>함수가 <span class="fixed">readFile
            :: FilePath -&gt; IO String</span>타입을 가진 반면, bytestring 모듈의 <span class="label function">readFile</span>은&nbsp;
          <span class="fixed">readFile :: FilePath -&gt; IO ByteString</span>타입을
          가졌습니다. strict bytestrings을 사용하여 파일을 읽고자 한다면, 메모리에 한번에 올려질 것이므로 주의하시기
          바랍니다! lazy bytestrings으로 한다면, 적당한 덩어리로 읽을 것입니다.</p>
        <p>명령 라인 인자로 두 파일 이름을 받아 첫번째 파일을 두번째 파일로 복사하는 간단한 프로그램을 만들어 봅시다. <span
            class="fixed">System.Directory</span>가 이미 <span class="fixed">copyFile</span>를
          가졌지만, 저희는 저희만의 파일 복사 함수와 프로그램을 만들 것입니다.</p>
        <pre name="code" class="haskell:hs">import System.Environment
import qualified Data.ByteString.Lazy as B

main = do
    (fileName1:fileName2:_) &lt;- getArgs
    copyFile fileName1 fileName2

copyFile :: FilePath -&gt; FilePath -&gt; IO ()
copyFile source dest = do
    contents &lt;- B.readFile source
    B.writeFile dest contents
</pre>
        <p>저희는 두개의 <span class="fixed">FilePath</span>를 취해 (<span class="fixed">FilePath</span>는
          단순히 <span class="fixed">String</span>와 동의어란 것을 기억하시기 바랍니다)&nbsp;
          bytestring을 이용하여 하나의 파일을 다른 파일로 복사하는 I/O action을 반환하는 함수를 만들었습니다. <span
            class="fixed">main</span>함수에서, 저희는 단순히 인자를 취해, 어떠한 일을 수행하는 I/O
          action을 호출하였습니다.</p>
        <pre name="code" class="plain">$ runhaskell bytestringcopy.hs something.txt ../../something.txt
</pre>
        <p>bytestrings을 사용하지 않는 프로그램도 이와 비슷할 수 도 있지만, <span class="fixed">readFile</span>과
          <span class="fixed">writeFile</span>대신 <span class="fixed">B.readFile</span>와
          <span class="fixed">B.writeFile</span>를 사용한다는 점이 다릅니다. 대부분의 경우, 필요한
          것들을 imports를 하고 qualified 모듈 이름들을 함수 앞에 놓음으로써, 평범한 문자열을 이용하는 프로그램을
          bytestring을 이용하는 프로그램으로 바꿀 수 있습니다. 종종, 문자열에 동작하도록 만든 함수들을 bytestring에
          동작하도록 변환시켜야 하지만, 이 역시 어렵진 않습니다.</p>
        <p>데이터를 문자열로 읽어들이는 프로그램에서 더 낳은 성능이 필요한다면, bytestrings을 줘본다면 적은 노력으로도
          만족할만한 성능을 얻을 수 있을 것입니다 저는 보통 평범한 문자열을 이용하여 프로그램을 작성한 다음, 성능이 만족할만하지
          않으면 bytestring을 사용하도록 바꿉니다.</p>
        <a name="exceptions"></a>
        <h2>예외</h2>
        <img src="http://s3.amazonaws.com/lyah/timber.png" class="left" alt="timberr!!!!"
          height="394" width="308">
        <p>모든 언어는 프로시져, 함수, 예외를 다루는 코드를 갖고있습니다. 이는 어쩔수 없는 현실입니다. 댜양한 언어들이 다양한
          방식으로 에러를 처리합니다. C에서는 함수가 평범한 값으로 취급할 수 없는 값을 반환하는 것을 나타내기 위해 보통&nbsp;
          ( <span class="fixed">-1</span>이나 널 포인터와 같은) 이상한 반환값을 사용하기도 합니다. 반면,
          Java와 C#에선 예외를 이용하여 실패를 다룹니다. 예외가 발생하면, 제어 흐름은 치우는 작업을 정의한 코드로 넘어가서
          예외를 되던지게되어 또 다른 예외 처리 코드가 어떠한 작업을 떠맏을 수 있게됩니다.</p>
        <p>하스켈은 매우 훌륭한 타입 시스템입니다. 대수적 자료구조는 <span class="fixed">Maybe</span>나 <span
            class="fixed">Either</span>와 같은 타입을 허용하며, 결과를 표현하기 위해 이러한 타입의 값을 이용할
          수 있습니다. C에서는 실패시 <span class="fixed">-1</span>를 반환하는것이 관습처럼 굳어졌습니다.
          이는 오직 인간에게만 특별한 의미를 지닙니다. 만약 주의하지 않은다면, 이러한 비정상적인 값을 다른 평범한 것처럼 다루게되
          크나큰 혼란을 야기할 것입니다. 하스켈의 타입시스템은 이러한 측면에서 좀더 튼튼한 안전망을 제공해줍니다. 함수 <span class="fixed">a
            -&gt; Maybe b</span>은 <span class="fixed">Just</span>로 감싸진&nbsp; <span
            class="fixed">b</span>를 생성하거나 <span class="fixed">Nothing</span>을
          반환한 다는 것을 명확히 나타내고 있습니다. <span class="fixed">a -&gt; Maybe b</span>
          타입은 단순한 <span class="fixed">a -&gt; b</span>타입과 다를 뿐만아니라&nbsp; 만일 이 두
          함수를 돌려쓴다면, 컴파일러는 불만을 토로할 것입니다.</p>
        <p>잘못된 계산을 대비하기 위한 표현력있는 타입을 가졌음에도 불구하고, I/O contexts에서는 그게 이치에 맞기에 하스켈은
          역시 예외를 지원합니다. 불안한 외부세계랑 작업하는 많은 일들이 잘못될 수 있습니다. 예를들어, 파일을 열때 분기가 잘못될 수
          있습니다. 파일이 잠겨있거나, 아에 없거나, 하드디스트나 무언가가 존재하지 않을지도 모릅니다. 따라서 이와 같은 에러가
          발생했을때 에러를 다룰 수 있는 곳으로 갈 수 있다면 좋을 것입니다.</p>
        <p>따라서 I/O 코드는 (즉, 불순한 코드는) 예외를 던질 수 있습다. 이는 이치에 맞습니다. 하지만 순수한 코드는 어떨까요?
          흠, 이 역시 예외를 던질 수 있습니다. <span class="fixed">div</span>와 <span class="fixed">head</span>함
          수에 대해 생각해 보시기 바랍니다. 이 둘은 각각 <span class="fixed">(Integral a) =&gt; a
            -&gt; a -&gt; a</span> 과 <span class="fixed">[a] -&gt; a</span>타입으로
          지니고 있습니다. 반환 값이 <span class="fixed">Maybe</span>나 <span class="fixed">Either</span>이
          아니므로 이 둘 모두 실패할 수 있습니다! 0으로 나누려 한다면 <span class="fixed">div</span>는
          광분할 것이며 <span class="fixed">head</span>에 비어있는 리스트를 넘겨준다면 짜증낼 것입니다.</p>
        <pre name="code" class="haskell:hs">ghci&gt; 4 `div` 0
*** Exception: divide by zero
ghci&gt; head []
*** Exception: Prelude.head: empty list
</pre> <img src="http://s3.amazonaws.com/lyah/police.png" alt="Stop right there, criminal scum! Nobody breaks the law on my watch! Now pay your fine or it's off to jail."
          class="left" height="328" width="241">
        <p>순수한 코드는 예외를 던질 수 있지만, 예외는 I/O 코드에서만(<span class="fixed">main</span>에
          들어가는 <i>do</i> 블록에 있는 경우) 잡을 수 있습니다 . 이는 저희가 순수한 코드에서 어떠한 것이 평가되는 시점을
          모르기 때문이며, I/O 코드가 실행 순서가 잘 정의된 반면 순수한 코드는 그렇지 않을 뿐더러 lazy하기 때문입니다.</p>
        <p>전에, 저희는 저희 프로그램의 I/O 부분에 관해서 어떻게 가능한 적은 시간을 소비할 것인가에 대해 예기를 나눴습니다. 저희
          프로그램의 로직은 거의 대부분 순수한 함수에 의존하고 있는데, 결과가 오직 함수가 호출되는 인자에 기반하기 때문입니다. 순수한
          함수를 다룰 때에는, 함수가 어떠한 일도 할 수 없기에 반환하는 값만 신경쓰면 됩니다. 이는 저희의 삶을 보다 쉽게 만들어
          줍니다. (파일을 여는것과 같은) I/O로된 로직이 필요할 지라도, 가급적 최소화가 될 것입니다. 순수한 함수는 기본적으로
          lazy합니다. :FIXME 이는 언제 평가되는지 Pure functions are lazy by default, which
          means that we don't know when they will be evaluated and that it
          really shouldn't matter. 하지만, 일단 순수한 함수가 예외를 던지면 However, once pure
          functions start throwing exceptions, it matters when they are
          evaluated. That's why we can only catch exceptions thrown from pure
          functions in the I/O part of our code. And that's bad, because we want
          to keep the I/O part as small as possible. However, if we don't catch
          them in the I/O part of our code, our program crashes. The solution?
          Don't mix exceptions and pure code. Take advantage of Haskell's
          powerful type system and use types like <span class="fixed">Either</span>
          and <span class="fixed">Maybe</span> to represent results that may
          have failed.</p>
        <p>That's why we'll just be looking at how to use I/O exceptions for
          now. I/O exception은 <span class="fixed">main</span>의 일부인 I/O action에서
          외부 세계랑 소통하면서 무언가 잘못 돌아갈때 발생할 수 있는 예외입니다. 예를들자면, 파일을 열ㅇwe can try
          opening a file and then it turns out that the file has been deleted or
          something. 명령 라인 인자로 들어온 이름을 받아 파일을 열어, 얼마나 많은 라인을 가지고 있는비 보여주는 프로그램을
          살펴보도록 하겠습니다.<br>
        </p>
        <pre name="code" class="haskell:hs">import System.Environment
import System.IO

main = do (fileName:_) &lt;- getArgs
          contents &lt;- readFile fileName
          putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"
</pre>
        <p>매우 단순한 프로그램입니다. <span class="fixed">getArgs</span> I/O action을 수행하고
          생성된&nbsp; 리스트의 첫번째 문자열을 <span class="fixed">fileName</span>에
          bind하였습니다. 그런 다음 파일의 내용을 <span class="fixed">contents</span>라 하였습니다.
          마지막으로, 그 내용을 리스트로 얻기 위해&nbsp; <span class="fixed">lines</span>를 적용하고
          리스트의 길이를 얻어&nbsp; <span class="fixed">show</span>로 넘겨 수를 문자열로 표현했습니다.
          예상대로 동작하지만, 존재하지 않는 파일 이름을 넘겨준다면 어떻게 될까요?</p>
        <pre name="code" class="plain">$ runhaskell linecount.hs i_dont_exist.txt
linecount.hs: i_dont_exist.txt: openFile: does not exist (No such file or directory)
</pre>
        <p>아하, 저희는 GHC에서 파일이 존재하지 않는다는 에러를 얻었습니다. 저희 프로그램은 멈췄습니다. 파일이 존재하지 않는 경우
          좀더 깔끔한 메시지를 출력하고자 한다면 어떻할까요? <span class="fixed">System.Directory</span>의
          <span class="label function">doesFileExist</span> 함수를 이용하여 파일을 열기 전에
          파일이 존재하는지 검사하는 방법이 있을 것입니다.</p>
        <pre name="code" class="haskell:hs">import System.Environment
import System.IO
import System.Directory

main = do (fileName:_) &lt;- getArgs
          fileExists &lt;- doesFileExist fileName
          if fileExists
              then do contents &lt;- readFile fileName
                      putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"
              else do putStrLn "The file doesn't exist!"
</pre>
        <p> <span class="fixed">doesFileExist</span>가 <span class="fixed">doesFileExist
            :: FilePath -&gt; IO Bool</span>을 타입을 갖기에 <span class="fixed">fileExists
            &lt;- doesFileExist fileName</span>을 하였으며, 이는 파일이 존재하는지 부울 값을 결과로 갖는
          I/O action을 반환한 다는 것을 의미합니다. 따라서 저희는 <i>if</i> 표현식에서 <span class="fixed">doesFileExist</span>을
          직접 사용할 수는 없습니다.</p>
        <p>또 다른 해결책은 예외를 사용하는 것입니다. 이러한 상황에서 예외를 사용하는 것은 상당히 괜찮아 보입니다. 파일이 존재하지
          않는 것은 I/O에서 발생한 예외이므로, 이를 I/O 에서 잡는 것은 꽤 괜찮은 방법입니다.</p>
        <p>To deal with this by using exceptions 예외를 이용하여 이를 처리하기 위해선,&nbsp; <span
            class="fixed">System.IO.Error</span>의 <span class="label function">catch</span>
          함수를 살펴봐야 합니다. 이의 타입은 <span class="fixed">catch :: IO a -&gt; (IOError
            -&gt; IO a) -&gt; IO a</span>입니다. 이는 두 인자를 취합니다. 하나는 I/O action입니다.
          예를들자면 파일을 열려고 하는 I/O action이 될 수 있습니다. 두번째는 핸들러라 불리는 것입니다. 첫번째 I/O
          action이 If the first I/O action passed to <span class="fixed">catch</span>
          throws an I/O exception, that exception gets passed to the handler,
          which then decides what to do. 따라서 최종 결과는 첫번째 인자와 같거나 So the final
          result is an I/O action that will either act the same as the first
          parameter or it will do what the handler tells it if the first I/O
          action throws an exception.</p>
        <img src="http://s3.amazonaws.com/lyah/puppy.png" alt="non sequitor" class="right"
          height="240" width="334">
        <p> <span class="fixed">catch</span>함수는 Java나 Python과 같은 언어에서의 <i>try-catch</i>
          블록과 유사합니다. 첫번째 인자는&nbsp; The first parameter is the thing to try, kind
          of like the stuff in the <i>try</i> block in other, . The second
          parameter is the handler that takes an exception, just like most <i>catch</i>
          blocks take exceptions that you can then examine to see what happened.
          The handler is invoked if an exception is thrown.</p>
        <p>핸들러는 I/O exception이 발생했다는 것을 알려주는 <span class="fixed">IOError</span>타
          입 값을 취합니다. It also carries information regarding the type of the
          exception that was thrown. How this type is implemented depends on the
          implementation of the language itself, which means that we can't
          inspect values of the type <span class="fixed">IOError</span> by
          pattern matching against them, just like we can't pattern match
          against values of type <span class="fixed">IO <i>something</i></span>.
          We can use a bunch of useful predicates to find out stuff about values
          of type <span class="fixed">IOError</span> as we'll learn in a
          second.</p>
        <p>그러면, 새로운 친구 <span class="fixed">catch</span>를 사용해 봅시다!</p>
        <pre name="code" class="haskell:hs">import System.Environment
import System.IO
import System.IO.Error

main = toTry `catch` handler
            
toTry :: IO ()
toTry = do (fileName:_) &lt;- getArgs
           contents &lt;- readFile fileName
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"

handler :: IOError -&gt; IO ()
handler e = putStrLn "Whoops, had some trouble!"
</pre>
        <p>First of all, you'll see that put backticks around it so that we can
          use it as an infix function, because it takes two parameters. Using it
          as an infix function makes it more readable. So <span class="fixed">toTry
            `catch` handler</span> is the same as <span class="fixed">catch
            toTry handler</span>, which fits well with its type. <span class="fixed">toTry</span>
          is the I/O action that we try to carry out and <span class="fixed">handler</span>
          is the function that takes an <span class="fixed">IOError</span> and
          returns an action to be carried out in case of an exception.</p>
        <p>Let's give this a go:</p>
        <pre name="code" class="plain">$ runhaskell count_lines.hs i_exist.txt
The file has 3 lines!

$ runhaskell count_lines.hs i_dont_exist.txt
Whoops, had some trouble!
</pre>
        <p>In the handler, we didn't check to see what kind of <span class="fixed">IOError</span>
          we got. We just say <span class="fixed">"Whoops, had some trouble!"</span>
          for any kind of error. Just catching all types of exceptions in one
          handler is bad practice in Haskell just like it is in most other
          languages. What if some other exception happens that we don't want to
          catch, like us interrupting the program or something? That's why we're
          going to do the same thing that's usually done in other languages as
          well: we'll check to see what kind of exception we got. If it's the
          kind of exception we're waiting to catch, we do our stuff. If it's
          not, we throw that exception back into the wild. Let's modify our
          program to catch only the exceptions caused by a file not existing.</p>
        <pre name="code" class="haskell:hs">import System.Environment
import System.IO
import System.IO.Error

main = toTry `catch` handler
            
toTry :: IO ()
toTry = do (fileName:_) &lt;- getArgs
           contents &lt;- readFile fileName
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"

handler :: IOError -&gt; IO ()
handler e
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"
    | otherwise = ioError e
</pre>
        <p>Everything stays the same except the handler, which we modified to
          only catch a certain group of I/O exceptions. Here we used two new
          functions from <span class="fixed">System.IO.Error</span> — <span class="label function">isDoesNotExistError</span>
          and <span class="label function">ioError</span>. <span class="fixed">isDoesNotExistError</span>
          is a predicate over <span class="fixed">IOError</span>s, which means
          that it's a function that takes an <span class="fixed">IOError</span>
          and returns a <span class="fixed">True</span> or <span class="fixed">False</span>,
          meaning it has a type of <span class="fixed">isDoesNotExistError ::
            IOError -&gt; Bool</span>. We use it on the exception that gets
          passed to our handler to see if it's an error caused by a file not
          existing. We use <a href="syntax-in-functions#guards-guards">guard</a>
          syntax here, but we could have also used an <i>if else</i>. If it's
          not caused by a file not existing, we re-throw the exception that was
          passed by the handler with the <span class="fixed">ioError</span>
          function. It has a type of <span class="fixed">ioError :: IOException
            -&gt; IO a</span>, so it takes an <span class="fixed">IOError</span>
          and produces an I/O action that will throw it. The I/O action has a
          type of <span class="fixed">IO a</span>, because it never actually
          yields a result, so it can act as <span class="fixed">IO <i>anything</i></span>.</p>
        <p>So the exception thrown in the <span class="fixed">toTry</span> I/O
          action that we glued together with a <i>do</i> block isn't caused by
          a file existing, <span class="fixed">toTry `catch` handler</span>
          will catch that and then re-throw it. Pretty cool, huh?</p>
        <p>There are several predicates that act on <span class="fixed">IOError</span>
          and if a guard doesn't evaluate to <span class="fixed">True</span>,
          evaluation falls through to the next guard. The predicates that act on
          <span class="fixed">IOError</span> are:</p>
        <ul>
          <li><span class="function label">isAlreadyExistsError</span></li>
          <li><span class="function label">isDoesNotExistError</span></li>
          <li><span class="function label">isAlreadyInUseError</span></li>
          <li><span class="function label">isFullError</span></li>
          <li><span class="function label">isEOFError</span></li>
          <li><span class="function label">isIllegalOperation</span></li>
          <li><span class="function label">isPermissionError</span></li>
          <li><span class="function label">isUserError</span></li>
        </ul>
        <p>Most of these are pretty self-explanatory. <span class="fixed">isUserError</span>
          evaluates to <span class="fixed">True</span> when we use the function
          <span class="label function">userError</span> to make the exception,
          which is used for making exceptions from our code and equipping them
          with a string. For instance, you can do <span class="fixed">ioError $
            userError "remote computer unplugged!"</span>, although It's
          prefered you use types like <span class="fixed">Either</span> and <span
            class="fixed">Maybe</span> to express possible failure instead of
          throwing exceptions yourself with <span class="fixed">userError</span>.</p>
        <p>So you could have a handler that looks something like this:</p>
        <pre name="code" class="haskell:hs">handler :: IOError -&gt; IO ()
handler e
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"
    | isFullError e = freeSomeSpace
    | isIllegalOperation e = notifyCops
    | otherwise = ioError e
</pre>
        <p>Where <span class="fixed">notifyCops</span> and <span class="fixed">freeSomeSpace</span>
          are some I/O actions that you define. Be sure to re-throw exceptions
          if they don't match any of your criteria, otherwise you're causing
          your program to fail silently in some cases where it shouldn't.</p>
        <p><span class="fixed">System.IO.Error</span> also exports functions
          that enable us to ask our exceptions for some attributes, like what
          the handle of the file that caused the error is, or what the filename
          is. These start with <span class="fixed">ioe</span> and you can see a
          <a href="http://www.haskell.org/ghc/docs/6.10.1/html/libraries/base/System-IO-Error.html#3">full
            list of them</a> in the documentation. Say we want to print the
          filename that caused our error. We can't print the <span class="fixed">fileName</span>
          that we got from <span class="fixed">getArgs</span>, because only the
          <span class="fixed">IOError</span> is passed to the handler and the
          handler doesn't know about anything else. A function depends only on
          the parameters it was called with. That's why we can use the <span class="label function">ioeGetFileName</span>
          function, which has a type of <span class="fixed">ioeGetFileName ::
            IOError -&gt; Maybe FilePath</span>. It takes an <span class="fixed">IOError</span>
          as a parameter and maybe returns a <span class="fixed">FilePath</span>
          (which is just a type synonym for <span class="fixed">String</span>,
          remember, so it's kind of the same thing). Basically, what it does is
          it extracts the file path from the <span class="fixed">IOError</span>,
          if it can. Let's modify our program to print out the file path that's
          responsible for the exception occurring. </p>
        <pre name="code" class="haskell:hs">import System.Environment   
import System.IO   
import System.IO.Error   
  
main = toTry `catch` handler   
               
toTry :: IO ()   
toTry = do (fileName:_) &lt;- getArgs   
           contents &lt;- readFile fileName   
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"   
  
handler :: IOError -&gt; IO ()   
handler e   
    | isDoesNotExistError e = 
        case ioeGetFileName e of Just path -&gt; putStrLn $ "Whoops! File does not exist at: " ++ path
                                 Nothing -&gt; putStrLn "Whoops! File does not exist at unknown location!"
    | otherwise = ioError e   
</pre>
        <p>In the guard where <span class="fixed">isDoesNotExistError</span> is
          <span class="fixed">True</span>, we used a <i>case</i> expression to
          call <span class="fixed">ioeGetFileName</span> with <span class="fixed">e</span>
          and then pattern match against the <span class="fixed">Maybe</span>
          value that it returned. Using <i>case</i> expressions is commonly
          used when you want to pattern match against something without bringing
          in a new function.</p>
        <p>You don't have to use one handler to <span class="fixed">catch</span>
          exceptions in your whole I/O part. You can just cover certain parts of
          your I/O code with <span class="fixed">catch</span> or you can cover
          several of them with <span class="fixed">catch</span> and use
          different handlers for them, like so:</p>
        <pre name="code" class="haskell:hs">main = do toTry `catch` handler1
          thenTryThis `catch` handler2
          launchRockets
</pre>
        <p>여기서, <span class="fixed">toTry</span>는 <span class="fixed">handler1</span>을,
          <span class="fixed">thenTryThis</span>는 <span class="fixed">handler2</span>를
          handler로 이용합니다. <span class="fixed">launchRockets</span>는 isn't a
          parameter to <span class="fixed">catch</span>의 매개변수가 아니므로, so
          whichever exceptions it might throw will likely crash our program,
          unless <span class="fixed">launchRockets</span> uses <span class="fixed">catch</span>
          internally to handle its own exceptions. Of course <span class="fixed">toTry</span>,
          <span class="fixed">thenTryThis</span> and <span class="fixed">launchRockets</span>
          are I/O actions that have been glued together using <i>do</i> syntax
          and hypothetically defined somewhere else. This is kind of similar to
          <i>try-catch</i> blocks of other languages, where you can surround
          your whole program in a single <i>try-catch</i> or you can use a more
          fine-grained approach and use different ones in different parts of
          your code to control what kind of error handling happens where.</p>
        <p>여러분은 이제 어떻게 I/O exception을 처리하는지를 배웠습니다! 순수한 코드에서 예외를 던지고 처리하는 것은
          Throwing exceptions from pure code and dealing with them hasn't been
          covered here, mainly because, like we said, Haskell은 더 낳은 방법 에러를
          나타내는&nbsp; offers much better ways to indicate errors than reverting
          to I/O to catch them. Even when glueing together I/O actions that
          might fail, I prefer to have their type be something like <span class="fixed">IO
            (Either a b)</span>, meaning that they're normal I/O actions but the
          result that they yield when performed is of type <span class="fixed">Either
            a b</span>, meaning it's either <span class="fixed">Left a</span>
          or <span class="fixed">Right b</span>.</p>
        <div class="footdiv">
          <ul>
            <li style="text-align:left"> <a href="making-our-own-types-and-typeclasses"
                class="prevlink">Making Our Own Types and Typeclasses</a> </li>
            <li style="text-align:center"> <a href="chapters">목 차<br>
              </a> </li>
            <li style="text-align:right"> <a href="functionally-solving-problems"
                class="nxtlink">Functionally Solving Problems</a> </li>
          </ul>
        </div>
      </div>
      <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
      <script type="text/javascript" src="shBrushHaskell.js"></script>
      <script type="text/javascript" src="shBrushPlain.js"></script>
      <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script> </div>
    <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script> </body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>Learn You a Haskell for Great Good! - Modules</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <base href="http://netpyoung.github.com/learn_you_a_haskell_for_great_good/">
    <style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style><link rel="shortcut icon" href="favicon.png" type="image/png">
    <link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
    <link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
  </head>
  <body class="introcontent">
    <div class="bgwrapper">
      <div id="content">
        <div class="footdiv" style="margin-bottom: 25px;">
          <ul>
            <li style="text-align: left;"> <a href="higher-order-functions"
                class="prevlink">Higher Order Functions</a> </li>
            <li style="text-align: center;"> <a href="chapters">목 차</a><br>
            </li>
            <li style="text-align: right;"> <a href="making-our-own-types-and-typeclasses"
                class="nxtlink">Making Our Own Types and Typeclasses</a>
            </li>
          </ul>
        </div>
        <h1>모듈</h1>
        <a name="loading-modules"></a>
        <h2>모듈 불러오기</h2>
        <img src="http://s3.amazonaws.com/lyah/modules.png" alt="modules"
          class="right" height="162" width="230">
        <p>하스켈 모듈은 함수, 타입, 타입클래스의 집합입니다. 하스켈 프로그램은 모듈의 집합이며, main모듈이 다른
          모듈을 불러와서 그곳에 정의된 함수를 이용하여 무언가를 수행합니다. 코드를 여러 모듈로 나누는 것에는 상당한
          이점이 있습니다. 모듈이 충분히 제네릭(generic)하다면, 여기서 추출된 함수들은 다양한 프로그램에서 사용될
          수 있습니다. 여러분의 코드가 다른 모듈에 너무 의존하지 않는 독립적인 모듈로 나눠진다면(느슨한 결합이라고도
          합니다), 후에 그것을 다시 사용할 수 있습니다. 목적에 맞게 여러 부분으로써 나눔으로써, 관리하기 편한 코드를
          작성할 수 있습니다.</p>
        <p>하스켈의 표준 라이브러리는 모듈로 나누어졌으며, 각각은 공용 목적에 관계된 함수와 타입을 포함합니다. 여기에는
          리스트를 다루는 모듈, 다중 처리(concurrent programming)을 위한 모듈, 복소수(complex
          numbers)를 다루기 위한 모듈 등등이 있습니다. 지금 까지 저희가 다룬 함수, 타입, 타입클래스 모두
          기본적으로 import된&nbsp; <span class="fixed">Prelude</span>의 한
          부분입니다. 먼저, 모듈을 import하는 방법을 살펴보겠습니다.</p>
        <p>하스켈에서 모듈을 import하기 위한 문법은 <span class="fixed">import
            &lt;module name&gt;</span>입니다. 이는 함수를 정의하기 전에 행해져야만 하며, 따라서
          import는 보통 파일의 상단에서 행해집니다. 물론, 하나의 스크립트에서 여러 모듈을 import할 수
          있습니다. 단지 여러 줄에 걸쳐 각 import문을 넣으면 됩니다. 리스트를 다루는 유용한 함수들을 지닌 <span
            class="fixed">Data.List</span>모듈을 import한다음, 추출된 함수를 이용하여
          리스트에 고유한 원소들이 얼마만큼 있는지 알려주는 함수를 만들어 봅시다.</p>
        <pre name="code" class="haskell:hs">import Data.List

numUniques :: (Eq a) =&gt; [a] -&gt; Int
numUniques = length . nub
</pre>
        <p><span class="fixed">import Data.List</span>를 하면, <span class="fixed">Data.List</span>에
          서 추출된 모든 함수들이 전역 이름공간에서 이용가능하며, 이는 스크립트 어딘가에도 이를 호출할 수 있다는 것을
          의미합니다.&nbsp; <span class="fixed">Data.List</span>에 정의된 <span
            class="fixed">nub</span>함수는 리스트를 받아 중복된 요소들을 없에 버립니다.&nbsp;
          <span class="fixed">length . nub</span>으로 <span class="fixed">length</span>와
          <span class="fixed">nub</span>을 합침으로써, <span class="fixed">\xs


            -&gt; length (nub xs)</span>와 동일한 함수를 만들어 냈습니다.</p>
        <p>또한 GHCI를 이용시, 모듈의 함수들을 전역 이름공간에 넣을 수 있습니다. GHCI에서 <span class="fixed">Data.List</span>에
          서 추출된 함수들을 호출하고자 한다면, 이렇게 하면 됩니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; :m + Data.List
</pre>
        <p> <span class="fixed">:m +</span> 을 여러번 수행하여 GHCI에서 여러 모듈들을
          불러올 수는 없고, 한번에 여러 모듈을 불러와야만 합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; :m + Data.List Data.Map Data.Set
</pre>
        <p>그러나, 이미 모듈을 import한 스크립트를 불러왔다면, 이에 접근하기 위해 <span class="fixed">:m







            +</span>을 사용할 필요가 없습니다.</p>
        <p>모듈에서 2개의 함수만 필요하다면, 선택적으로 그 함수들을 import 할 수 있습니다.&nbsp; <span
            class="fixed">Data.List</span>에서 <span class="fixed">nub</span>,
          <span class="fixed">sort</span>함수만 import하려면, 이렇게 하시면 됩니다:</p>
        <pre name="code" class="haskell:hs">import Data.List (nub, sort)
</pre>
        <p>모듈에서 선택된 것을 제외한 모든 함수들을 import할 수 도 있습니다. 이는 동일한 이름의 함수를 지닌
          모듈을 import할때 유용합니다. 이미 <span class="fixed">nub</span>란 함수를
          정의하였고, <span class="fixed">Data.List</span>에서 <span class="fixed">nub</span>함
          수를 제외한 모든 함수들을 import한다고 가정해 봅시다: </p>
        <pre name="code" class="haskell:hs">import Data.List hiding (nub)
</pre>
        <p>이름 충돌을 처리하는 또 다른 방법으로는 qualified import를 하는 것입니다.&nbsp; 키로 값을
          살펴볼 수 있는 자료구조를 지원하는 <span class="fixed">Data.Map</span>모듈
          은&nbsp; <span class="fixed">filter</span>나 <span class="fixed">null</span>처
          럼 <span class="fixed">Prelude</span>와 동일한 이름의 함수를
          제공합니다.&nbsp; <span class="fixed">Data.Map</span>을
          import하고&nbsp; <span class="fixed">filter</span>를 호출하면, 하스켈은
          어떤 함수를 이용해야 하는지를 알 수 없게 됩니다. 여기 이 문제의 해결책이 나와 있습니다:</p>
        <pre name="code" class="haskell:hs">import qualified Data.Map
</pre>
        <p><span class="fixed">filter</span>는 저희가 익숙한 <span class="fixed">filter</span>를
          가리키지만,&nbsp; <span class="fixed">Data.Map</span>의 <span class="fixed">filter</span>함
          수를 참조하고자 한다면,&nbsp; <span class="fixed">Data.Map.filter</span>라
          해야합니다. 하지만, <span class="fixed">Data.Map</span>의 함수 앞에 매번 <span
            class="fixed">Data.Map</span>를 입력하는 것은 지루한 일입니다. qualified
          import로 이름을 짧게 지을 수 있습니다:</p>
        <pre name="code" class="haskell:hs">import qualified Data.Map as M
</pre>
        <p>이제,&nbsp; <span class="fixed">M.filter</span>을 이용하여 <span class="fixed">Data.Map</span>의
          <span class="fixed">filter</span>함수를 참조할 수 있습니다.</p>
        <p> 표준 라이브러리에 있는 모듈이 어떤것인지 살펴보기 위해 <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/">이
            참고 문서</a> 를 이용하시기 바랍니다. 새로운 하스켈 지식을 얻기위한 최선의 방법은 표준 라이브러리
          레퍼런스를 클릭하여, 모듈과 함수들을 살펴보는 것입니다. 또한 각 모듈의 소스 코드를 확인할 수 있습니다. 몇몇
          모듈의 소스 코드를 읽는 것은 하스켈을 배우고 체우는데 있어 매우 좋은 방법입니다.</p>
        <p>함수를 검색하거나, 위치한 장소를 찾고자 한다면, <a href="http://haskell.org/hoogle">Hoogle</a>
          을 이용하시기 바랍니다. 이것은 실로 놀랄만한 하스켈 검색 엔진이며,&nbsp; 이름, 모듈, 심지어 타입
          서명으로 검색할 수 있습니다.</p>
        <a name="data-list"></a>
        <h2>Data.List</h2>
        <p><span class="fixed">Data.List</span>모듈은 보이는 것처럼 리스트에 관한 것입니다.
          이는 리스트를 다루는데 있어 매우 유용한 함수들을 제공해 줍니다. 저희는 이미 <span class="fixed">map</span>과
          <span class="fixed">filter</span>와 같은 몇몇 함수들을 만나 보았는데,
          편의상&nbsp; <span class="fixed">Prelude</span>모듈이&nbsp; <span
            class="fixed">Data.List</span>에서 함수 몇개를 가져오기 때문입니다. <span class="fixed">Prelude</span>가
          이미 <span class="fixed">Data.List</span>에서 가저온 이름을 제외하면 어떠한
          이름도 충돌하지 않기에, qualified import 통해 <span class="fixed">Data.List</span>를
          import해서는 안됩니다. 이제 저희가 이전에 보지 못했던 함수들을 살펴봅시다.</p>
        <p><span class="label function">intersperse</span>는 원소와 리스트를 받아,
          리스트의 각 요소들 사이마다 받은 원소를 껴놓습니다. 여기 실례가 있습니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; intersperse '.' "MONKEY"
"M.O.N.K.E.Y"
ghci&gt; intersperse 0 [1,2,3,4,5,6]
[1,0,2,0,3,0,4,0,5,0,6]
</pre>
        <p><span class="label function">intercalate</span>는 리스트와 리스트의
          리스트를 받습니다. 그런 다음 리스트의 리스트 사이에 리스트를 껴놓아서 반듣한 결과를 내놓습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; intercalate " " ["hey","there","guys"]
"hey there guys"
ghci&gt; intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]]
[1,2,3,0,0,0,4,5,6,0,0,0,7,8,9]
</pre>
        <p><span class="label function">transpose</span>는 리스트의 리스트를
          전치(transpose)합니다. 리스트의 리스트를 2차원 행렬로 본다면, 행은 열이, 열은 행이될 것입니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; transpose [[1,2,3],[4,5,6],[7,8,9]]
[[1,4,7],[2,5,8],[3,6,9]]
ghci&gt; transpose ["hey","there","guys"]
["htg","ehu","yey","rs","e"]
</pre>
        <p>다항식 <span style="font-style: italic;"></span><i>3x<sup>2</sup>
            + 5x + 9</i>, <i>10x<sup>3</sup> + 9</i>, <i>8x<sup>3</sup>
            + 5x<sup>2</sup> + x - 1</i>을 가졌고 이를 서로 더한다 해봅시다. 하스켈로 리스트 <span
            class="fixed">[0,3,5,9]</span>, <span class="fixed">[10,0,0,9]</span>,
          <span class="fixed">[8,5,1,-1]</span>로 나타낼 수 있습니다. 이제, 다음처럼 합칠
          수 있습니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
[18,8,6,17]
</pre>
        <p>이 3개의 리스트를 전치(transpose)하면서, 3차항을 첫번째 줄에 2차항을 두번째 줄에 등등
          넣었습니다. 다음으로 <span class="fixed">sum</span>을 map하여 원하는 결과를
          얻었습니다.</p>
        <img src="http://s3.amazonaws.com/lyah/legolists.png" alt="shopping lists"
          class="left" height="212" width="230">
        <p><span class="label function">foldl'</span>와 <span class="label function">foldl1'</span>는
          lazy(게으른)가 아닌 stict(엄격한)버전 입니다. 매우 큰 리스트에 lazy fold를 사용한다면, 스텍
          오버플로우 에러가 날 것입니다. 범인은 실제론 fold가 일어나는 동안 축적되는 값이 갱신되지 않는 fold의
          lazy한 환경입니다. 실제로 발생하는 일은 누산기 비슷한것이 '결과를 요청할때 계산이 시작된다는
          것(thunk라고도 합니다)'을 약속하는 것입니다. 누산이 될때마다, 이러한 thunk들은 스택을 넘치게 할
          것입니다. strict fold는 게으른 벌레(lazy bugger)가 아니며, 스택을 무언가(thunk)로
          채워넣는 대신 중간 값을 계산합니다. 그러므로, lazy fold하는 동안에 스택오버플로우 에러를 만나게되면,
          stict버전으로 바꿔보시기 바랍니다.</p>
        <p><span class="label function">concat</span>은 리스트의 리스트를 원소 리스트로
          펴줍니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; concat ["foo","bar","car"]
"foobarcar"
ghci&gt; concat [[3,4,5],[2,3,4],[2,1,1]]
[3,4,5,2,3,4,2,1,1]
</pre>
        <p>이는 단지 중첩 레벨을 하나 제거할 뿐입니다. 따라서 리스트의 리스트의 리스트인 <span class="fixed">[[[2,3],[3,4,5],[2]],[[2,3],[3,4]]]</span>
          를 완전히 펴려면, concat을 두번 해야 합니다.</p>
        <p><span class="label function">concatMap</span>이 하는 일은 리스트에 함수를
          map시키고나서, <span class="fixed">concat</span>하는 것과 같습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; concatMap (replicate 4) [1..3]
[1,1,1,1,2,2,2,2,3,3,3,3]
</pre>
        <p><span class="label function">and</span>는 부울 값을 지닌 리스트를 받아
          리스트의 모든 값이&nbsp; <span class="fixed">True</span>경우,&nbsp; <span
            class="fixed">True</span>를 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; and $ map (&gt;4) [5,6,7,8]
True
ghci&gt; and $ map (==4) [4,4,4,3,4]
False
</pre>
        <p><span class="label function">or</span>는 리스트의 어떠한 값이라도&nbsp; <span
            class="fixed">True</span>인 경우 <span class="fixed">True</span>를
          반환한다는 점을 제외하면 <span class="fixed">and</span>와 비슷합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; or $ map (==4) [2,3,4,5,6,1]
True
ghci&gt; or $ map (&gt;4) [1,2,3]
False
</pre>
        <p><span class="label function">any</span>와 <span class="label function">all</span>은
          각각 서술자(predicate)를 받아 리스트의 어떤 혹은 모든 원소들이 술부를 만족하는지 확인합니다. 보통
          리스트를 map한 다음 <span class="fixed">and</span>나 <span class="fixed">or</span>을
          하는 대용으로, 이 두 함수가 사용됩니다.<br>
        </p>
        <pre name="code" class="haskell:ghci">ghci&gt; any (==4) [2,3,5,6,1,4]
True
ghci&gt; all (&gt;4) [6,9,10]
True
ghci&gt; all (`elem` ['A'..'Z']) "HEYGUYSwhatsup"
False
ghci&gt; any (`elem` ['A'..'Z']) "HEYGUYSwhatsup"
True
</pre>
        <p><span class="label function">iterate</span>는 함수와 시작값을 받습니다.
          이는 시작값에 함수를 적용한 다음, 그 결과에 함수를 적용을 반복합니다. 반환하는 모든 결과값은 무한 리스트의
          형태를 띄게됩니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; take 10 $ iterate (*2) 1
[1,2,4,8,16,32,64,128,256,512]
ghci&gt; take 3 $ iterate (++ "haha") "haha"
["haha","hahahaha","hahahahahaha"]
</pre>
        <p><span class="label function">splitAt</span>은 숫자와 리스트를 받습니다.
          그런 다음, 숫자만큼 리스트를 자르어, 튜플로 두 리스트를 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; splitAt 3 "heyman"
("hey","man")
ghci&gt; splitAt 100 "heyman"
("heyman","")
ghci&gt; splitAt (-3) "heyman"
("","heyman")
ghci&gt; let (a,b) = splitAt 3 "foobar" in b ++ a
"barfoo"
</pre>
        <p><span class="label function">takeWhile</span>는 작고 매우 유용한 함수
          입니다. predicate를 만족하는 동안 리스트에서 원소를 취하다가, 만족하지 못하게 되면, 잘라냅니다. 이는
          매우 유용합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; takeWhile (&gt;3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]
[6,5,4]
ghci&gt; takeWhile (/=' ') "This is a sentence"
"This"
</pre>
        <p>10,000보다 작은 수의 세제곱의 합을 원한다고 가정해 봅시다. 무한 리스트에서의 걸러내는 작업은 결코
          끝나지 않기에,&nbsp; <span class="fixed">(^3)</span>을 <span class="fixed">[1..]</span>에
          map시킨 후, filter적용하여 합을 구할 순 없습니다. 여러분이 여기서 모든 원소들이 오름차순이란걸 알
          지라도, 하스켈은 그렇지 않습니다. 이것이 바로 왜 다음과 같이 해야만 되는지에 대한 이유입니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; sum $ takeWhile (&lt;10000) $ map (^3) [1..]
53361
</pre>
        <p><span class="fixed">(^3)</span>을 무한 리스트에 적용한후, 10,000을 넘어가는
          원소를 만나면, 리스트를 끊습니다. 이제 저희는 쉽게 합을 구할 수 있습니다.</p>
        <p>유사한 <span class="label function">dropWhile</span>는
          predicate가 참인 동안에만 원소들을 내칩니다. 술부(predicate)가&nbsp; <span class="fixed">False</span>이
          면, 리스트의 나머지를 반환합니다. 굉장히 유용하며 사랑스런 함수가 아닐 수가 없습니다!</p>
        <pre name="code" class="haskell:ghci">ghci&gt; dropWhile (/=' ') "This is a sentence"
" is a sentence"
ghci&gt; dropWhile (&lt;3) [1,2,2,2,3,4,5,4,3,2,1]
[3,4,5,4,3,2,1]
</pre>
        <p>그날의 주식 현황을 표현하는 리스트를 가졌다고 가정해봅시다. 리스트는 주식 값, 년도, 월, 날짜로 구성된
          튜플입니다. 이제 주식값이 언제 처음으로 1000달러를 넘는지 확인해봅시다!</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let stock = [(994.4,2008,9,1),(995.2,2008,9,2),(999.2,2008,9,3),(1001.4,2008,9,4),(998.3,2008,9,5)]
ghci&gt; head (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)
(1001.4,2008,9,4)
</pre>
        <p><span class="label function">span</span>은 <span class="fixed">takeWhile</span>와
          같은 종류지만, 리스트 쌍을 반환합니다. 첫번째 리스트는 <span class="fixed">takeWhile</span>에
          서 나온 것을 모두 포함합니다. 두번째 리스트는 떨어져 나온 부분을 포함하고 있습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let (fw, rest) = span (/=' ') "This is a sentence" in "First word:" ++ fw ++ ", the rest:" ++ rest
"First word: This, the rest: is a sentence"
</pre>
        <p><span class="fixed">span</span>이 predicate가 참인 동안
          포함하지만,&nbsp; <span class="label function">break</span>는
          predicate가 참이면 멈춥니다.&nbsp; <span class="fixed">break p</span>가
          하는 일은 <span class="fixed">span (not . p)</span>와 동일합니다. </p>
        <pre name="code" class="haskell:ghci">ghci&gt; break (==4) [1,2,3,4,5,6,7]
([1,2,3],[4,5,6,7])
ghci&gt; span (/=4) [1,2,3,4,5,6,7]
([1,2,3],[4,5,6,7])
</pre>
        <p><span class="fixed">break</span>를 사용할 시에는 결과의 두번째 리스트
          predicate를 만족하는 원소로 시작할 것입니다.</p>
        <p><span class="label function">sort</span>는 단순히 리스트를 정렬합니다.
          리스트의 원소의 타입은 <span class="fixed">Ord</span>타입클래스에 속해야 하는데,
          순서를 갖지 않으면 정렬될 수 없기 때문입니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; sort [8,5,3,2,1,6,4,2]
[1,2,2,3,4,5,6,8]
ghci&gt; sort "This will be sorted soon"
"    Tbdeehiillnooorssstw"
</pre>
        <p><span class="label function">group</span>은 리스트를 받아, 동일한 인접한
          원소을 하위 리스트로 묶습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]
</pre>
        <p>리스트를 group하기 전에 정렬하였다면, 리스트의 각 원소들이 얼마나 있는지 확인할 수 있을 것입니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; map (\l@(x:xs) -&gt; (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]
</pre>
        <p><span class="label function">inits</span>과 <span class="label function">tails</span>은
          <span class="fixed">init</span>와 <span class="fixed">tail</span>과
          비슷하지만, 남아있는게 없을때까지 리스트에 재귀적으로 적용합니다. 살펴봅시다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; inits "w00t"
["","w","w0","w00","w00t"]
ghci&gt; tails "w00t"
["w00t","00t","0t","t",""]
ghci&gt; let w = "w00t" in zip (inits w) (tails w)
[("","w00t"),("w","00t"),("w0","0t"),("w00","t"),("w00t","")]
</pre>
        <p>fold를 이용하여&nbsp; 하위 리스트로 리스트를 검색하는 구현해 봅시다.</p>
        <pre name="code" class="haskell:hs">search :: (Eq a) =&gt; [a] -&gt; [a] -&gt; Bool
search needle haystack = 
    let nlen = length needle
    in  foldl (\acc x -&gt; if take nlen x == needle then True else acc) False (tails haystack)
</pre>
        <p>우선 검색할 리스트에 <span class="fixed">tails</span> 을 호출합니다. 그리고나서
          저희가 찾고자 하는 걸로 시작하는지 각 tail마다 확인합니다.</p>
        <p>여기서, 저희는 <span class="label function">isInfixOf</span>처럼
          행동하는 함수를 만들었습니다. <span class="fixed">isInfixOf</span>는 하위
          리스트로 리스트를 검색하며, 찾고자 하는 하위 리스트가 대상 리스트에 있으면 <span class="fixed">True</span>를
          반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; "cat" `isInfixOf` "im a cat burglar"
True
ghci&gt; "Cat" `isInfixOf` "im a cat burglar"
False
ghci&gt; "cats" `isInfixOf` "im a cat burglar"
False
</pre>
        <p><span class="label function">isPrefixOf</span>와 <span class="label function">isSuffixOf</span>는
          각각 하위리스트로 리스트의 시작과 끝을 검색합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; "hey" `isPrefixOf` "hey there!"
True
ghci&gt; "hey" `isPrefixOf` "oh hey there!"
False
ghci&gt; "there!" `isSuffixOf` "oh hey there!"
True
ghci&gt; "there!" `isSuffixOf` "oh hey there"
False
</pre>
        <p><span class="label function">elem</span>과 <span class="label function">notElem</span>은
          원소가 리스트 안에 있는지 검사합니다.</p>
        <p><span class="label function">partition</span>는 리스트와
          predicate를 취해, 리스트 쌍을 반환합니다. 결과의 첫번째 리스트는 predicate를 만족하는 모든
          원소들을 포함하고 있으며, 두번째는 만족하지 않는 것들을 포함합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; partition (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"
("BOBMORGAN","sidneyeddy")
ghci&gt; partition (&gt;3) [1,3,5,6,3,2,1,0,3,7]
([5,6,7],[1,3,3,2,1,0,3])
</pre>
        <p><span class="fixed">span</span> 과 <span class="fixed">break</span>와
          어떠한 점이 다른지 이해하는 것이 중요합니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; span (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"
("BOB","sidneyMORGANeddy")
</pre>
        <p><span class="fixed">span</span>과&nbsp; <span class="fixed">break</span>가
          predicate를 만족하거나 만족하지 못하는 원소를 만나면 멈추는 반면, <span class="fixed">partition</span>는
          리스트 전체를 훝어 predicate에 따라 나눕니다.</p>
        <p><span class="label function">find</span>는 predicate와 리스트를 취해,
          predicate를 만족하는 첫번째 요소를 반환하지만,&nbsp; <span class="fixed">Maybe</span>값
          으로 그 요소를 감싸서 반환합니다. 다음장에서 대수적 자료구조에 대해 깊게 다룰 것이지만, 지금 저희가 알아야
          할 것은 다음과 같습니다: ' <span class="fixed">Maybe</span>는&nbsp; <span
            class="fixed">Just something</span>이나 <span class="fixed">Nothing</span>이
          될 수 있다'. 리스트가 비어있는 리스트가 되거나 무언가를 담은 리스트가 될 수 있는 것처럼, <span class="fixed">Maybe</span>값
          은 단일 요소이거나 아무런 요소도 아닐 수 있습니다. 그리고 정수 리스트의 타입을 <span class="fixed">[Int]</span>라
          하는것 처럼, 정수에 대한 타입은 <span class="fixed">Maybe Int</span>가 됩니다.
          어찌됐던간에, <span class="fixed">find</span>함수를 돌려 봅시다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; find (&gt;4) [1,2,3,4,5,6]
Just 5
ghci&gt; find (&gt;9) [1,2,3,4,5,6]
Nothing
ghci&gt; :t find
find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a
</pre>
        <p><span class="fixed">find</span>의 타입을 주목하시기 바랍니다. 이의 결과는 <span
            class="fixed">Maybe a</span>입니다. <span class="fixed">[a]</span>를
          타입으로 갖는 리스트가 하나 혹은 여러원소를 포함하거나, 아무런 원소도 포함하지 않을 수 있는 것과 달리, <span
            class="fixed">Maybe</span>타입의 값은 하나의 원소를 포함하거나, 아무런 원소도 포함하지
          않습니다.</p>
        <p>주식이 처음으로 $1000를 넘어선 날을 찾을 때를 떠올려 보시기 바랍니다. <span class="fixed">head


            (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)</span>
          라 하였습니다.&nbsp; <span class="fixed">head</span>가 실제론 안전하지 않다는
          것을 기억하시기 바랍니다. $1000를 넘는 주식이 없다면 어떤일이 발생할까요?&nbsp; <span class="fixed">dropWhile</span>은
          비어있는 리스트를 반환할 것이며, 빈 리스트의 head를 얻으려 한다면 에러를 결과로 얻을 것입니다.
          하지만,&nbsp; <span class="fixed">find (\(val,y,m,d) -&gt; val
            &gt; 1000) stock</span>라고 재작성하면, 비교적 안전해 질 것입니다. 주식이 $1000을
          넘지 않는다면(어떠한 요소도 predicate를 만족하지 않는다면),&nbsp; <span class="fixed">Nothing</span>을
          얻을 것입니다. 반면, 리스트에 유효한 값이 있다면, <span class="fixed">Just
            (1001.4,2008,9,4)</span>라는 값을 얻게될 것입니다. </p>
        <p><span class="label function">elemIndex</span>는&nbsp; <span class="fixed">elem</span>와
          비슷하나, 부울값을 반환하지 않고, 찾는 원소의 위치를 반환합니다. 리스트내에 원소가 없으면,&nbsp; <span
            class="fixed">Nothing</span>을 반환합니다. </p>
        <pre name="code" class="haskell:ghci">ghci&gt; :t elemIndex
elemIndex :: (Eq a) =&gt; a -&gt; [a] -&gt; Maybe Int
ghci&gt; 4 `elemIndex` [1,2,3,4,5,6]
Just 3
ghci&gt; 10 `elemIndex` [1,2,3,4,5,6]
Nothing
</pre>
        <p><span class="label function">elemIndices</span>은 <span class="fixed">elemIndex</span>와
          같으나, 찾고자 하는 원소가 여러번 나타나는 위치 리스트를 반환합니다. 리스트를 이용하여 위치를
          표현하기에,&nbsp; <span class="fixed">Maybe</span>타입이 필요없는데, 실패는 <span
            class="fixed">Nothing</span>와 매우 유사한 빈 리스트로 표현할 수 있기 때문입니다.<br>
        </p>
        <pre name="code" class="haskell:ghci">ghci&gt; ' ' `elemIndices` "Where are the spaces?"
[5,9,13]
</pre>
        <p><span class="label function">findIndex</span>는 find와 같으나,
          predicate를 만족하는 처음 원소만 아마(maybe) 반환할 것입니다. <span class="label function">findIndices</span>는&nbsp;

          리스트에서 predicate를 만족하는 원소들의 위치를 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; findIndex (==4) [5,3,2,1,6,4]
Just 5
ghci&gt; findIndex (==7) [5,3,2,1,6,4]
Nothing
ghci&gt; findIndices (`elem` ['A'..'Z']) "Where Are The Caps?"
[0,6,10,14]
</pre>
        <p>저희는 이미 <span class="fixed">zip</span>와 <span class="fixed">zipWith</span>를
          다루었습니다. 이들은 리스트 2개를 튜플이나 인자를 두개 받는 함수(binary function)로 엮습니다.
          그러면 3개의 리스트를 서로 엮으려면 어떻게 할까요? 아니면, 3개의 리스트를 3개의 인자를 받는 함수로
          엮으려면 어떻게 할까요? 이러한 것을 위해&nbsp; <span class="label function">zip3</span>,
          <span class="label function">zip4</span>, 등등 과 <span class="label function">zipWith3</span>,
          <span class="label function">zipWith4</span>, 등등을 가지고 있습니다.
          이러한 변종들은 7까지 있습니다. 이것이 꼼수(hack)처럼 보여도, 8개의 리스트를 서로 엮을 기회는 많이
          없을 터이니 문제 없을 것입니다. 리스트를 무한히 엮을 수 있는 획기적인 방법도 있으나,&nbsp; 지금
          다루기에는 조금 이른감이 있습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; zipWith3 (\x y z -&gt; x + y + z) [1,2,3] [4,5,2,2] [2,2,3]
[7,9,8]
ghci&gt; zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]
[(2,2,5,2),(3,2,5,2),(3,2,3,2)]
</pre>
        <p>다른 평범한 엮는 작업처럼, 리스트들은 적당한 크기로 엮어지게 됩니다.</p>
        <p><span class="label function">lines</span>은 파일이나 입력을 다룰때 유용한
          함수입니다. 이는 문자열을 취해 라인 단위로 분리된 리스트를 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; lines "first line\nsecond line\nthird line"
["first line","second line","third line"]
</pre>
        <p><span class="fixed">'\n'</span>은 유닉스의 개행문자입니다. 역슬러쉬는 하스켈에서
          문자열과 문자간에 특별한 의미를 지니고 있습니다.</p>
        <p><span class="label function">unlines</span>은&nbsp; <span class="fixed">lines</span>과
          반대되는 함수입니다. 이는 문자열 리스트를 받아 <span class="fixed">'\n'</span>로
          서로를 연결합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; unlines ["first line", "second line", "third line"]
"first line\nsecond line\nthird line\n"
</pre>
        <p><span class="label function">words</span>와 <span class="label function">unwords</span>는
          텍스트의 라인을 단어 단위로 나누거나, 단어 리스트를 문자열로 연결합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; words "hey these are the words in this sentence"
["hey","these","are","the","words","in","this","sentence"]
ghci&gt; words "hey these           are    the words in this\nsentence"
["hey","these","are","the","words","in","this","sentence"]
ghci&gt; unwords ["hey","there","mate"]
"hey there mate"
</pre>
        <p>전에 제가&nbsp; <span class="label function">nub</span>을
          언급하였습니다. 이는 리스트를 받아 중복된 원소들을 제거하여, 눈꽃처럼 고유한 원소구성된 리스트를 반환합니다!
          이 함수는 이상한 이름을 지녔습니다. "nub"는 작은 덩어리 혹은 무언가의 필수적인 부분을 의미합니다. 제
          생각에는, 함수의 이름은 구어체 대신 실제 사용하는 단어를 사용해야 한다고 생각합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; nub [1,2,3,4,3,2,1,2,3,4,3,2,1]
[1,2,3,4]
ghci&gt; nub "Lots of words and stuff"
"Lots fwrdanu"
</pre>
        <p><span class="label function">delete</span>는 원소와 리스트를 취해 그
          리스트에서 처음 만난 원소를 지웁니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; delete 'h' "hey there ghang!"
"ey there ghang!"
ghci&gt; delete 'h' . delete 'h' $ "hey there ghang!"
"ey tere ghang!"
ghci&gt; delete 'h' . delete 'h' . delete 'h' $ "hey there ghang!"
"ey tere gang!"
</pre>
        <p><span class="label function">\\</span>는 리스트 차집합(list
          difference) 함수입니다. 우측 리스트에서 좌측에 있는 요소들을 제거합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; [1..10] \\ [2,5,9]
[1,3,4,6,7,8,10]
ghci&gt; "Im a big baby" \\ "big"
"Im a  baby"
</pre>
        <p><span class="fixed">[1..10] \\ [2,5,9]</span>는&nbsp; <span class="fixed">delete

            2 . delete 5 . delete 9 $ [1..10]</span>와 같습니다.</p>
        <p><span class="label function">union</span> 또한 집합 관한 함수입니다. 이는
          두 리스트의 교집합(union)을 반환합니다. 이는 두번째 리스트의 모든 원소를 훝어본 다음 첫번째에 없는
          것들을 추가합니다. 두번째 리스트에서 중복된 부분은 사라지니 주의하시기 바랍니다!</p>
        <pre name="code" class="haskell:ghci">ghci&gt; "hey man" `union` "man what's up"
"hey manwt'sup"
ghci&gt; [1..7] `union` [5..10]
[1,2,3,4,5,6,7,8,9,10]
</pre>
        <p><span class="label function">intersect</span>는 교칩합(set
          intersection)과 같습니다. 두 리스트에서 공통된 원소들만 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; [1..7] `intersect` [5..10]
[5,6,7]
</pre>
        <p><span class="label function">insert</span>는 :TODO원소와 정렬 가능한
          리스트를 받아, 원소보다 같거나 작은 마지막 위치에 원소를 집어넣습니다. 다시말해,&nbsp; <span class="fixed">insert</span>는
          will start at the beginning of the list and then keep going
          until it finds an element that's equal to or greater than the
          element that we're inserting and it will insert it just before
          the element.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; insert 4 [3,5,1,2,8,2]
[3,4,5,1,2,8,2]
ghci&gt; insert 4 [1,3,4,4,1]
[1,3,4,4,4,1]
</pre>
        <p>The <span class="fixed">4</span> is inserted right after the
          <span class="fixed">3</span> and before the <span class="fixed">5</span>
          in the first example and in between the <span class="fixed">3</span>
          and <span class="fixed">4</span> in the second example.</p>
        If we use <span class="fixed">insert</span> to insert into a
        sorted list, the resulting list will be kept sorted.
        <p></p>
        <pre name="code" class="haskell:ghci">ghci&gt; insert 4 [1,2,3,5,6,7]
[1,2,3,4,5,6,7]
ghci&gt; insert 'g' $ ['a'..'f'] ++ ['h'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci&gt; insert 3 [1,2,4,3,2,1]
[1,2,3,4,3,2,1]
</pre>
        <p>What <span class="fixed">length</span>, <span class="fixed">take</span>,
          <span class="fixed">drop</span>, <span class="fixed">splitAt</span>,
          <span class="fixed">!!</span> and <span class="fixed">replicate</span>
          have in common is that they take an <span class="fixed">Int</span>
          as one of their parameters (or return an <span class="fixed">Int</span>),







          even though they could be more generic and usable if they just
          took any type that's part of the <span class="fixed">Integral</span>
          or <span class="fixed">Num</span> typeclasses (depending on
          the functions). They do that for historical reasons. However,
          fixing that would probably break a lot of existing code.
          That's why <span class="fixed">Data.List</span> has their
          more generic equivalents, named <span class="label function">genericLength</span>,
          <span class="label function">genericTake</span>, <span class="label function">genericDrop</span>,
          <span class="label function">genericSplitAt</span>, <span class="label function">genericIndex</span>
          and <span class="label function">genericReplicate</span>. For
          instance, <span class="fixed">length</span> has a type
          signature of <span class="fixed">length :: [a] -&gt; Int</span>.
          If we try to get the average of a list of numbers by doing <span
            class="fixed">let xs = [1..6] in sum xs / length xs</span>,
          we get a type error, because you can't use <span class="fixed">/</span>
          with an <span class="fixed">Int</span>. <span class="fixed">genericLength</span>,
          on the other hand, has a type signature of <span class="fixed">genericLength







            :: (Num a) =&gt; [b] -&gt; a</span>. Because a <span class="fixed">Num</span>
          can act like a floating point number, getting the average by
          doing <span class="fixed">let xs = [1..6] in sum xs /
            genericLength xs</span> works out just fine.</p>
        <p>The <span class="fixed">nub</span>, <span class="fixed">delete</span>,
          <span class="fixed">union</span>, <span class="fixed">intersect</span>
          and <span class="fixed">group</span> functions all have their
          more general counterparts called <span class="label function">nubBy</span>,
          <span class="label function">deleteBy</span>, <span class="label function">unionBy</span>,
          <span class="label function">intersectBy</span> and <span class="label function">groupBy</span>.
          The difference between them is that the first set of functions
          use <span class="fixed">==</span> to test for equality,
          whereas the <i>By</i> ones also take an equality function and
          then compare them by using that equality function. <span class="fixed">group</span>
          is the same as <span class="fixed">groupBy (==)</span>. </p>
        <p>For instance, say we have a list that describes the value of
          a function for every second. We want to segment it into
          sublists based on when the value was below zero and when it
          went above. If we just did a normal <span class="fixed">group</span>,
          it would just group the equal adjacent values together. But
          what we want is to group them by whether they are negative or
          not. That's where <span class="fixed">groupBy</span> comes
          in! The equality function supplied to the <i>By</i> functions
          should take two elements of the same type and return <span class="fixed">True</span>
          if it considers them equal by its standards.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3]
ghci&gt; groupBy (\x y -&gt; (x &gt; 0) == (y &gt; 0)) values
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
</pre>
        <p>From this, we clearly see which sections are positive and
          which are negative. The equality function supplied takes two
          elements and then returns <span class="fixed">True</span>
          only if they're both negative or if they're both positive.
          This equality function can also be written as <span class="fixed">\x







            y -&gt; (x &gt; 0) &amp;&amp; (y &gt; 0) || (x &lt;= 0)
            &amp;&amp; (y &lt;= 0)</span>, although I think the first
          way is more readable. An even clearer way to write equality
          functions for the <i>By</i> functions is if you import the <span
            class="label function">on</span> function from <span class="fixed">Data.Function</span>.
          <span class="fixed">on</span> is defined like this: </p>
        <pre name="code" class="haskell:ghci">on :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
f `on` g = \x y -&gt; f (g x) (g y)
</pre>
        <p>So doing <span class="fixed">(==) `on` (&gt; 0)</span>
          returns an equality function that looks like <span class="fixed">\x







            y -&gt; (x &gt; 0) == (y &gt; 0)</span>. <span class="fixed">on</span>
          is used a lot with the <i>By</i> functions because with it,
          we can do: </p>
        <pre name="code" class="haskell:ghci">ghci&gt; groupBy ((==) `on` (&gt; 0)) values
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
</pre>
        <p>Very readable indeed! You can read it out loud: Group this by
          equality on whether the elements are greater than zero.</p>
        <p>Similarly, the <span class="fixed">sort</span>, <span class="fixed">insert</span>,
          <span class="fixed">maximum</span> and <span class="fixed">minimum</span>
          also have their more general equivalents. Functions like <span
            class="fixed">groupBy</span> take a function that determines
          when two elements are equal. <span class="label function">sortBy</span>,
          <span class="label function">insertBy</span>, <span class="label function">maximumBy</span>
          and <span class="label function">minimumBy</span> take a
          function that determine if one element is greater, smaller or
          equal to the other. The type signature of <span class="fixed">sortBy</span>
          is <span class="fixed">sortBy :: (a -&gt; a -&gt; Ordering)
            -&gt; [a] -&gt; [a]</span>. If you remember from before, the
          <span class="fixed">Ordering</span> type can have a value of <span
            class="fixed">LT</span>, <span class="fixed">EQ</span> or <span
            class="fixed">GT</span>. <span class="fixed">sort</span> is
          the equivalent of <span class="fixed">sortBy compare</span>,
          because compare just takes two elements whose type is in the <span
            class="fixed">Ord</span> typeclass and returns their
          ordering relationship.</p>
        <p>Lists can be compared, but when they are, they are compared
          lexicographically. What if we have a list of lists and we want
          to sort it not based on the inner lists' contents but on their
          lengths? Well, as you've probably guessed, we'll use the <span
            class="fixed">sortBy</span> function.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]]
ghci&gt; sortBy (compare `on` length) xs
[[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]
</pre>
        <p>Awesome! <span class="fixed">compare `on` length</span> ...
          man, that reads almost like real English! If you're not sure
          how exactly the <span class="fixed">on</span> works here, <span
            class="fixed">compare `on` length</span> is the equivalent
          of <span class="fixed">\x y -&gt; length x `compare` length y</span>.
          When you're dealing with <i>By</i> functions that take an
          equality function, you usually do <span class="fixed">(==)
            `on` something</span> and when you're dealing with <i>By</i>
          functions that take an ordering function, you usually do <span
            class="fixed">compare `on` something</span>.</p>
        <a name="data-char"></a>
        <h2>Data.Char</h2>
        <img src="http://s3.amazonaws.com/lyah/legochar.png" alt="lego char"
          class="right" height="323" width="230">
        <p><span class="fixed">Data.Char</span>모듈은 이 이름이 시사하는 바처럼, 문자를
          다루는 함수를 제공합니다. 이는 또한 문자 리스트인 문자열을 걸러내고 map할때 유용합니다.</p>
        <p><span class="fixed">Data.Char</span>는 문자를 받아 어떠한 가정이 참인지 거짓인지
          알려주는, 문자에 대한 predicate 분기를 위한 함수들을 제공합니다. 여기 무엇이 있는지 나와있습니다:</p>
        <p><span class="label function">isControl</span>는 문자가 제어문자인지
          확인합니다.</p>
        <p><span class="label function">isSpace</span>는 문자가 공백문자인지
          확인합니다. 이는 띄어쓰기(space), 탭(tab), 줄바꿈(newline) 등등을 포함합니다.</p>
        <p><span class="label function">isLower</span>는 문자가 소문자인지 확인합니다.
        </p>
        <p><span class="label function">isUpper</span>는 문자가 대문자인지 확인합니다.</p>
        <p><span class="label function">isAlpha</span>는 문자가 영문자인지 확인합니다.</p>
        <p><span class="label function">isAlphaNum</span>는 문자가 영문자 혹은
          숫자인지를 확인합니다.</p>
        <p><span class="label function">isPrint</span>는 문자의 출력가능 여부를
          확인합니다. 예를들어, 제어문자는 출력하지 못합니다.</p>
        <p><span class="label function">isDigit</span>는 문자가 10진수인지
          확인합니다.</p>
        <p><span class="label function">isOctDigit</span>는 문자가 8진수인지
          확인합니다.</p>
        <p><span class="label function">isHexDigit</span>는 문자가 16진수인지
          확인합니다.</p>
        <p><span class="label function">isLetter</span>는 문자가 영문자인지
          확인합니다.</p>
        <p><span class="label function">isMark</span>는 유니코드 마크 문자인지
          확인합니다. Those are characters that combine with preceding
          letters to form latters with accents. Use this if you are
          French.</p>
        <p><span class="label function">isNumber</span>는 문자가 숫자인지 확인합니다.</p>
        <p><span class="label function">isPunctuation</span>는 문자가
          구둣점(punctuation)인지 확인합니다.</p>
        <p><span class="label function">isSymbol</span>는 문자가 수학적 심볼인지
          통화(currency) 심볼인지 확인합니다.</p>
        <p><span class="label function">isSeparator</span>는 유니코드 공백과
          구분자를 확인합니다.</p>
        <p><span class="label function">isAscii</span>은 문자가 유니코드 문자 모음 중
          처음 128 문자에 들어가는지 확인합니다.</p>
        <p><span class="label function">isLatin1</span>은 문자가 유니코드 문자 모음
          중 처음 256 문자에 들어가는지 확인합니다.</p>
        <p><span class="label function">isAsciiUpper</span>는 문자가
          ASCII이면서 대문자인지 확인합니다.</p>
        <p><span class="label function">isAsciiLower</span>는 문자가
          ASCII이면서 소문자인지 확인합니다.</p>
        <p>여기 나온 모든 predicate는 <span class="fixed">Char -&gt; Bool</span>
          타입 서명을 지니고 있습니다. Most of the time you'll use this to filter
          out strings or something like that. For instance, let's say
          we're making a program that takes a username and the username
          can only be comprised of alphanumeric characters. We can use
          the <span class="fixed">Data.List</span> function <span class="fixed">all</span>
          in combination with the <span class="fixed">Data.Char</span>
          predicates to determine if the username is alright.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; all isAlphaNum "bobby283"
True
ghci&gt; all isAlphaNum "eddy the fish!"
False
</pre>
        <p>헐. In case you don't remember, <span class="fixed">all</span>
          takes a predicate and a list and returns <span class="fixed">True</span>
          only if that predicate holds for every element in the list.</p>
        <p>또한 <span class="fixed">Data.List</span>함수인 <span class="fixed">words</span>를
          모방하기 위해 <span class="fixed">isSpace</span>를 사용할 수 도 있습니다. </p>
        <pre name="code" class="haskell:ghci">ghci&gt; words "hey guys its me"
["hey","guys","its","me"]
ghci&gt; groupBy ((==) `on` isSpace) "hey guys its me"
["hey"," ","guys"," ","its"," ","me"]
ghci&gt;
</pre>
        <p>흠, well, it kind of does what <span class="fixed">words</span>
          does but we're left with elements of only spaces. Hmm,
          whatever shall we do? I know, let's filter that sucker.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"
["hey","guys","its","me"]
</pre>
        <p>Ah.</p>
        <p>The <span class="fixed">Data.Char</span> also exports a
          datatype that's kind of like <span class="fixed">Ordering</span>.
          The <span class="fixed">Ordering</span> type can have a value
          of <span class="fixed">LT</span>, <span class="fixed">EQ</span>
          or <span class="fixed">GT</span>. It's a sort of enumeration.
          It describes a few possible results that can arise from
          comparing two elements. The <span class="fixed">GeneralCategory</span>
          type is also an enumeration. It presents us with a few
          possible categories that a character can fall into. The main
          function for getting the general category of a character is <span
            class="fixed">generalCategory</span>. It has a type of <span
            class="fixed">generalCategory :: Char -&gt; GeneralCategory</span>.
          There are about 31 categories so we won't list them all here,
          but let's play around with the function.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; generalCategory ' '
Space
ghci&gt; generalCategory 'A'
UppercaseLetter
ghci&gt; generalCategory 'a'
LowercaseLetter
ghci&gt; generalCategory '.'
OtherPunctuation
ghci&gt; generalCategory '9'
DecimalNumber
ghci&gt; map generalCategory " \t\nA9?|"
[Space,Control,Control,UppercaseLetter,DecimalNumber,OtherPunctuation,MathSymbol]
</pre>
        <p>Since the <span class="fixed">GeneralCategory</span> type is
          part of the <span class="fixed">Eq</span> typeclass, we can
          also test for stuff like <span class="fixed">generalCategory
            c == Space</span>.</p>
        <p><span class="label function">toUpper</span>는 문자를 대순자로 변환시킵니다.
          공백이나 숫자 같은 것은 바뀌지 않습니다.</p>
        <p><span class="label function">toLower</span>는 문자를 소문자로 변환시킵니다.</p>
        <p><span class="label function">toTitle</span>는 문자 converts a
          character to title-case. For most characters, title-case is
          the same as upper-case.</p>
        <p><span class="label function">digitToInt</span>는 문자를&nbsp; <span
            class="fixed">Int</span>로 변환시킵니다. 성공하기 위해선, 문자가&nbsp; <span
            class="fixed">'0'..'9'</span>, <span class="fixed">'a'..'f'</span>,
          <span class="fixed">'A'..'F'</span> 범위 안에 있어야 합니다.<br>
        </p>
        <pre name="code" class="haskell:ghci">ghci&gt; map digitToInt "34538"
[3,4,5,3,8]
ghci&gt; map digitToInt "FF85AB"
[15,15,8,5,10,11]
</pre>
        <p><span class="label function">intToDigit</span>는&nbsp; <span
            class="fixed">digitToInt</span>에 반대되는 함수입니다. 이는 <span class="fixed">0..15</span>
          범위안의 <span class="fixed">Int</span>를 받아, 소문자로 변환시킵니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; intToDigit 15
'f'
ghci&gt; intToDigit 5
'5'
</pre>
        <p>&nbsp;<span class="label function">ord</span>와 <span class="fixed">chr</span>함
          수는 문자를 대응하는 숫자로, 숫자를 대응하는 문자로 바꾸어줍니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; ord 'a'
97
ghci&gt; chr 97
'a'
ghci&gt; map ord "abcdefgh"
[97,98,99,100,101,102,103,104]
</pre>
        <p>두 문자간의 <span class="fixed">ord</span>값의 차이는, 유니코드 표에서의 두
          문자간의 거리와 같습니다.<br>
        </p>
        <p>시저 암호는 알파벳의 각 문자를 지정한 숫자만큼 옮김으로써 메시지를 부호화하는 원시적인 방법입니다. 저희는
          알파벳 문자에 한정짓지 않는 시저 암호를 쉽게 구현할 수 있습니다.</p>
        <pre name="code" class="haskell:hs">encode :: Int -&gt; String -&gt; String
encode shift msg =
    let ords = map ord msg
        shifted = map (+ shift) ords
    in  map chr shifted
</pre>
        <p>여기서, 저희는 우선 문자열을 숫자 리스트로 변환시켰습니다. 그런 다음 숫자 리스트를 문자로 돌려놓기 전에,
          각 숫자마다 옮겨질 양을 더합니다. 여러분이 composition 을 좋아한다면, 함수 본체를 <span class="fixed">map







            (chr . (+ shift) . ord) msg</span>로 작성할 지도 모르겠습니다. 메시지를 부호화
          시켜봅시다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; encode 3 "Heeeeey"
"Khhhhh|"
ghci&gt; encode 4 "Heeeeey"
"Liiiii}"
ghci&gt; encode 1 "abcd"
"bcde"
ghci&gt; encode 5 "Marry Christmas! Ho ho ho!"
"Rfww~%Hmwnxyrfx&amp;%Mt%mt%mt&amp;"
</pre>
        <p>올바르게 부호화가 되었습니다. 메시지를 해석하는 작업은 처음 위치한 곳으로 숫자를 옮기는 것입니다.</p>
        <pre name="code" class="haskell:hs">decode :: Int -&gt; String -&gt; String
decode shift msg = encode (negate shift) msg
</pre>
        <pre name="code" class="haskell:ghci">ghci&gt; encode 3 "Im a little teapot"
"Lp#d#olwwoh#whdsrw"
ghci&gt; decode 3 "Lp#d#olwwoh#whdsrw"
"Im a little teapot"
ghci&gt; decode 5 . encode 5 $ "This is a sentence"
"This is a sentence"
</pre> <a name="data-map"></a>
        <h2>Data.Map</h2>
        <p>Association lists (also called dictionaries) are lists that
          are used to store key-value pairs where ordering doesn't
          matter. For instance, we might use an association list to
          store phone numbers, where phone numbers would be the values
          and people's names would be the keys. We don't care in which
          order they're stored, we just want to get the right phone
          number for the right person.</p>
        <p>The most obvious way to represent association lists in
          Haskell would be by having a list of pairs. The first
          component in the pair would be the key, the second component
          the value. Here's an example of an association list with phone
          numbers:</p>
        <pre name="code" class="haskell:hs">phoneBook = 
    [("betty","555-2938")
    ,("bonnie","452-2928")
    ,("patsy","493-2928")
    ,("lucille","205-2928")
    ,("wendy","939-8282")
    ,("penny","853-2492")
    ]
</pre>
        <p>Despite this seemingly odd indentation, this is just a list
          of pairs of strings. The most common task when dealing with
          association lists is looking up some value by key. Let's make
          a function that looks up some value given a key.</p>
        <pre name="code" class="haskell:hs">findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; v
findKey key xs = snd . head . filter (\(k,v) -&gt; key == k) $ xs
</pre>
        <p>Pretty simple. The function that takes a key and a list,
          filters the list so that only matching keys remain, gets the
          first key-value that matches and returns the value. But what
          happens if the key we're looking for isn't in the association
          list? Hmm. Here, if a key isn't in the association list, we'll
          end up trying to get the head of an empty list, which throws a
          runtime error. However, we should avoid making our programs so
          easy to crash, so let's use the <span class="fixed">Maybe</span>
          data type. If we don't find the key, we'll return a <span class="fixed">Nothing</span>.
          If we find it, we'll return <span class="fixed">Just
            something</span>, where something is the value corresponding
          to that key.</p>
        <pre name="code" class="haskell:hs">findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v
findKey key [] = Nothing
findKey key ((k,v):xs) = if key == k
                            then Just v
                            else findKey key xs
</pre>
        <p>Look at the type declaration. It takes a key that can be
          equated, an association list and then it maybe produces a
          value. Sounds about right.</p>
        <p>This is a textbook recursive function that operates on a
          list. Edge case, splitting a list into a head and a tail,
          recursive calls, they're all there. This is the classic fold
          pattern, so let's see how this would be implemented as a fold.</p>
        <pre name="code" class="haskell:hs">findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v
findKey key = foldr (\(k,v) acc -&gt; if key == k then Just v else acc) Nothing
</pre>
        <div class="hintbox"><em>Note:</em> It's usually better to use
          folds for this standard list recursion pattern instead of
          explicitly writing the recursion because they're easier to
          read and identify. Everyone knows it's a fold when they see
          the <span class="fixed">foldr</span> call, but it takes some
          more thinking to read explicit recursion.</div>
        <pre name="code" class="haskell:ghci">ghci&gt; findKey "penny" phoneBook
Just "853-2492"
ghci&gt; findKey "betty" phoneBook
Just "555-2938"
ghci&gt; findKey "wilma" phoneBook
Nothing
</pre> <img src="http://s3.amazonaws.com/lyah/legomap.png" alt="legomap"
          class="left" height="240" width="214">
        <p>Works like a charm! If we have the girl's phone number, we <span
            class="fixed">Just</span> get the number, otherwise we get <span
            class="fixed">Nothing</span>.</p>
        <p>We just implemented the <span class="fixed">lookup</span>
          function from <span class="fixed">Data.List</span>. If we
          want to find the corresponding value to a key, we have to
          traverse all the elements of the list until we find it. The <span
            class="fixed">Data.Map</span> module offers association
          lists that are much faster (because they're internally
          implemented with trees) and also it provides a lot of utility
          functions. From now on, we'll say we're working with maps
          instead of association lists.</p>
        <p>Because <span class="fixed">Data.Map</span> exports
          functions that clash with the <span class="fixed">Prelude</span>
          and <span class="fixed">Data.List</span> ones, we'll do a
          qualified import. </p>
        <pre name="code" class="haskell:hs">import qualified Data.Map as Map
</pre>
        <p>Put this import statement into a script and then load the
          script via GHCI.</p>
        <p>Let's go ahead and see what <span class="fixed">Data.Map</span>
          has in store for us! Here's the basic rundown of its
          functions.</p>
        <p>The <span class="label function">fromList</span> function
          takes an association list (in the form of a list) and returns
          a map with the same associations.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]
fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]
ghci&gt; Map.fromList [(1,2),(3,4),(3,2),(5,5)]
fromList [(1,2),(3,2),(5,5)]
</pre>
        <p>If there are duplicate keys in the original association list,
          the duplicates are just discarded. This is the type signature
          of <span class="fixed">fromList</span></p>
        <pre name="code" class="haskell:hs">Map.fromList :: (Ord k) =&gt; [(k, v)] -&gt; Map.Map k v
</pre>
        <p>It says that it takes a list of pairs of type <span class="fixed">k</span>
          and <span class="fixed">v</span> and returns a map that maps
          from keys of type <span class="fixed">k</span> to type <span
            class="fixed">v</span>. Notice that when we were doing
          association lists with normal lists, the keys only had to be
          equatable (their type belonging to the <span class="fixed">Eq</span>
          typeclass) but now they have to be orderable. That's an
          essential constraint in the <span class="fixed">Data.Map</span>
          module. It needs the keys to be orderable so it can arrange
          them in a tree.</p>
        <p>You should always use <span class="fixed">Data.Map</span>
          for key-value associations unless you have keys that aren't
          part of the <span class="fixed">Ord</span> typeclass.</p>
        <p><span class="label function">empty</span> represents an empty
          map. It takes no arguments, it just returns an empty map.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.empty
fromList []
</pre>
        <p><span class="label function">insert</span> takes a key, a
          value and a map and returns a new map that's just like the old
          one, only with the key and value inserted.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.empty
fromList []
ghci&gt; Map.insert 3 100 Map.empty
fromList [(3,100)]
ghci&gt; Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty))
fromList [(3,100),(4,200),(5,600)]
ghci&gt; Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty
fromList [(3,100),(4,200),(5,600)]
</pre>
        <p>We can implement our own <span class="fixed">fromList</span>
          by using the empty map, <span class="fixed">insert</span> and
          a fold. Watch:</p>
        <pre name="code" class="haskell:ghci">fromList' :: (Ord k) =&gt; [(k,v)] -&gt; Map.Map k v
fromList' = foldr (\(k,v) acc -&gt; Map.insert k v acc) Map.empty
</pre>
        <p>It's a pretty straightforward fold. We start of with an empty
          map and we fold it up from the right, inserting the key value
          pairs into the accumulator as we go along.</p>
        <p><span class="label function">null</span> 은 맵이 비어있는지 확인합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.null Map.empty
True
ghci&gt; Map.null $ Map.fromList [(2,3),(5,5)]
False
</pre>
        <p><span class="label function">size</span> 는 맵의 사이즈를 알려줍니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.size Map.empty
0
ghci&gt; Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]
5
</pre>
        <p><span class="label function">singleton</span> 은 키와 값을 받아 오직
          하나의맵을 만듭니다.takes a key and a value and creates a map that has
          exactly one mapping.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.singleton 3 9
fromList [(3,9)]
ghci&gt; Map.insert 5 9 $ Map.singleton 3 9
fromList [(3,9),(5,9)]
</pre>
        <p><span class="label function">lookup</span> works like the <span
            class="fixed">Data.List</span> <span class="fixed">lookup</span>,
          only it operates on maps. It returns <span class="fixed">Just
            something</span> if it finds something for the key and <span
            class="fixed">Nothing</span> if it doesn't.</p>
        <p><span class="label function">member</span> is a predicate
          takes a key and a map and reports whether the key is in the
          map or not.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)]
True
ghci&gt; Map.member 3 $ Map.fromList [(2,5),(4,5)]
False
</pre>
        <p><span class="label function">map</span> 과 <span class="label function">filter</span>
          는 work much like their list equivalents.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.map (*100) $ Map.fromList [(1,1),(2,4),(3,9)]
fromList [(1,100),(2,400),(3,900)]
ghci&gt; Map.filter isUpper $ Map.fromList [(1,'a'),(2,'A'),(3,'b'),(4,'B')]
fromList [(2,'A'),(4,'B')]
</pre>
        <p><span class="label function">toList</span> 는 <span class="fixed">fromList</span>의
          반대입니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.toList . Map.insert 9 2 $ Map.singleton 4 3
[(4,3),(9,2)]
</pre>
        <p><span class="label function">keys</span> and <span class="label function">elems</span>
          return lists of keys and values respectively. <span class="fixed">keys</span>
          is the equivalent of <span class="fixed">map fst . Map.toList</span>
          and <span class="fixed">elems</span> is the equivalent of <span
            class="fixed">map snd . Map.toList</span>.</p>
        <p><span class="label function">fromListWith</span> is a cool
          little function. It acts like <span class="fixed">fromList</span>,
          only it doesn't discard duplicate keys but it uses a function
          supplied to it to decide what to do with them. Let's say that
          a girl can have several numbers and we have an association
          list set up like this.</p>
        <pre name="code" class="haskell:hs">phoneBook = 
    [("betty","555-2938")
    ,("betty","342-2492")
    ,("bonnie","452-2928")
    ,("patsy","493-2928")
    ,("patsy","943-2929")
    ,("patsy","827-9162")
    ,("lucille","205-2928")
    ,("wendy","939-8282")
    ,("penny","853-2492")
    ,("penny","555-2111")
    ]
</pre>
        <p>Now if we just use <span class="fixed">fromList</span> to
          put that into a map, we'll lose a few numbers! So here's what
          we'll do:</p>
        <pre name="code" class="haskell:hs">phoneBookToMap :: (Ord k) =&gt; [(k, String)] -&gt; Map.Map k String
phoneBookToMap xs = Map.fromListWith (\number1 number2 -&gt; number1 ++ ", " ++ number2) xs
</pre>
        <pre name="code" class="haskell:hs">ghci&gt; Map.lookup "patsy" $ phoneBookToMap phoneBook
"827-9162, 943-2929, 493-2928"
ghci&gt; Map.lookup "wendy" $ phoneBookToMap phoneBook
"939-8282"
ghci&gt; Map.lookup "betty" $ phoneBookToMap phoneBook
"342-2492, 555-2938"
</pre>
        <p>If a duplicate key is found, the function we pass is used to
          combine the values of those keys into some other value. We
          could also first make all the values in the association list
          singleton lists and then we can use <span class="fixed">++</span>
          to combine the numbers.</p>
        <pre name="code" class="haskell:hs">phoneBookToMap :: (Ord k) =&gt; [(k, a)] -&gt; Map.Map k [a]
phoneBookToMap xs = Map.fromListWith (++) $ map (\(k,v) -&gt; (k,[v])) xs
</pre>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.lookup "patsy" $ phoneBookToMap phoneBook
["827-9162","943-2929","493-2928"]
</pre>
        <p>Pretty neat! Another use case is if we're making a map from
          an association list of numbers and when a duplicate key is
          found, we want the biggest value for the key to be kept.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,100),(3,29),(4,22)]
</pre>
        <p>Or we could choose to add together values on the same keys.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,108),(3,62),(4,37)]
</pre>
        <p><span class="label function">insertWith</span> is to <span class="fixed">insert</span>
          what <span class="fixed">fromListWith</span> is to <span class="fixed">fromList</span>.
          It inserts a key-value pair into a map, but if that map
          already contains the key, it uses the function passed to it to
          determine what to do.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)]
fromList [(3,104),(5,103),(6,339)]
</pre>
        <p>These were just a few functions from <span class="fixed">Data.Map</span>.
          You can see a complete list of functions in the <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3Aassocs">documentation</a>.</p>
        <a name="data-set"></a>
        <h2>Data.Set</h2>
        <img src="http://s3.amazonaws.com/lyah/legosets.png" alt="legosets"
          class="right" height="236" width="150">
        <p>The <span class="fixed">Data.Set</span> module offers us,
          well, sets. Like sets from mathematics. Sets are kind of like
          a cross between lists and maps. All the elements in a set are
          unique. And because they're internally implemented with trees
          (much like maps in <span class="fixed">Data.Map</span>),
          they're ordered. Checking for membership, inserting, deleting,
          etc. is much faster than doing the same thing with lists. The
          most common operation when dealing with sets are inserting
          into a set, checking for membership and converting a set to a
          list.</p>
        <p>Because the names in <span class="fixed">Data.Set</span>
          clash with a lot of <span class="fixed">Prelude</span> and <span
            class="fixed">Data.List</span> names, we do a qualified
          import.</p>
        <p>Put this import statement in a script:</p>
        <pre name="code" class="haskell:ghci">import qualified Data.Set as Set
</pre>
        <p>And then load the script via GHCI.</p>
        <p>Let's say we have two pieces of text. We want to find out
          which characters were used in both of them.</p>
        <pre name="code" class="haskell:ghci">text1 = "I just had an anime dream. Anime... Reality... Are they so different?"
text2 = "The old man left his garbage can out and now his trash is all over my lawn!"
</pre>
        <p> The <span class="label function">fromList</span> function
          works much like you would expect. It takes a list and converts
          it into a set.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let set1 = Set.fromList text1
ghci&gt; let set2 = Set.fromList text2
ghci&gt; set1
fromList " .?AIRadefhijlmnorstuy"
ghci&gt; set2
fromList " !Tabcdefghilmnorstuvwy"
</pre>
        <p>As you can see, the items are ordered and each element is
          unique. Now let's use the <span class="label function">intersection</span>
          function to see which elements they both share.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.intersection set1 set2
fromList " adefhilmnorstuy"
</pre>
        <p>We can use the <span class="label function">difference</span>
          function to see which letters are in the first set but aren't
          in the second one and vice versa.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.difference set1 set2
fromList ".?AIRj"
ghci&gt; Set.difference set2 set1
fromList "!Tbcgvw"
</pre>
        <p>Or we can see all the unique letters used in both sentences
          by using <span class="label function">union</span>.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.union set1 set2
fromList " !.?AIRTabcdefghijlmnorstuvwy"
</pre>
        <p>The <span class="label function">null</span>, <span class="label function">size</span>,
          <span class="label function">member</span>, <span class="label function">empty</span>,
          <span class="label function">singleton</span>, <span class="label function">insert</span>
          and <span class="label function">delete</span> functions all
          work like you'd expect them to.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.null Set.empty
True
ghci&gt; Set.null $ Set.fromList [3,4,5,5,4,3]
False
ghci&gt; Set.size $ Set.fromList [3,4,5,3,4,5]
3
ghci&gt; Set.singleton 9
fromList [9]
ghci&gt; Set.insert 4 $ Set.fromList [9,3,8,1]
fromList [1,3,4,8,9]
ghci&gt; Set.insert 8 $ Set.fromList [5..10]
fromList [5,6,7,8,9,10]
ghci&gt; Set.delete 4 $ Set.fromList [3,4,5,4,3,4,5]
fromList [3,5]
</pre>
        <p>We can also check for subsets or proper subset. Set A is a
          subset of set B if B contains all the elements that A does.
          Set A is a proper subset of set B if B contains all the
          elements that A does but has more elements.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.fromList [2,3,4] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
True
ghci&gt; Set.fromList [1,2,3,4,5] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
True
ghci&gt; Set.fromList [1,2,3,4,5] `Set.isProperSubsetOf` Set.fromList [1,2,3,4,5]
False
ghci&gt; Set.fromList [2,3,4,8] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
False
</pre>
        <p>We can also <span class="label function">map</span> over
          sets and <span class="label function">filter</span> them.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.filter odd $ Set.fromList [3,4,5,6,7,2,3,4]
fromList [3,5,7]
ghci&gt; Set.map (+1) $ Set.fromList [3,4,5,6,7,2,3,4]
fromList [3,4,5,6,7,8]
</pre>
        <p>Sets are often used to weed a list of duplicates from a list
          by first making it into a set with <span class="fixed">fromList</span>
          and then converting it back to a list with <span class="label function">toList</span>.
          The <span class="fixed">Data.List</span> function <span class="fixed">nub</span>
          already does that, but weeding out duplicates for large lists
          is much faster if you cram them into a set and then convert
          them back to a list than using <span class="fixed">nub</span>.
          But using <span class="fixed">nub</span> only requires the
          type of the list's elements to be part of the <span class="fixed">Eq</span>
          typeclass, whereas if you want to cram elements into a set,
          the type of the list has to be in <span class="fixed">Ord</span>.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let setNub xs = Set.toList $ Set.fromList xs
ghci&gt; setNub "HEY WHATS CRACKALACKIN"
" ACEHIKLNRSTWY"
ghci&gt; nub "HEY WHATS CRACKALACKIN"
"HEY WATSCRKLIN"
</pre>
        <p><span class="fixed">setNub</span> is generally faster than <span
            class="fixed">nub</span> on big lists but as you can see, <span
            class="fixed">nub</span> preserves the ordering of the
          list's elements, while <span class="fixed">setNub</span> does
          not.</p>
        <a name="making-our-own-modules"></a>
        <h2>Making our own modules</h2>
        <img src="http://s3.amazonaws.com/lyah/making_modules.png" alt="making modules"
          class="right" height="224" width="345">
        <p>지금까지 저희는 멋진 모듈들을 살펴보았습니다. 하지만 어떻게 저희만의 모듈을 만들까요? 대부분의 프로그래밍
          언어에서, 코드를 여러 파일로 나눈 것처럼, 하스켈도 그러합니다. 프로그램을 만들 시, 유사한 목적을 지니는
          함수와 타입을 하나의 모듈로 모아 넣는 것이 좋은 습관입니다. 이러한 방법으로, 다른 프로그램에서 모듈을
          import함으로써 쉽게 함수들을 재사용할 수 있습니다.</p>
        <p>모듈이 기하학적 물체의 면적과 부피를 계산하는 함수를 제공하도록 만들어 봄으로써, 어떻게 모듈을 만드는지 살펴
          봅시다. 우선 <span class="fixed">Geometry.hs</span> 파일을 만듭니다.</p>
        <p>모듈은 함수를 제공한다고 하였습니다. 이는 모듈을 import하면, 모듈이 제공하는 함수를 사용할 수 있다는
          것을 의미합니다. 이는 내무적으로 호출할 함수들을 정의할수 있으며, 사용자는 export된 것만 이용할 수
          있습니다.<br>
        </p>
        <p>모듈의 시작부분에는, 모듈 이름을 명시합니다. <span class="fixed">Geometry.hs</span>
          파일을 가졁다면, 모듈 이름은 <span class="fixed">Geometry</span> 여야 합니다.
          그런 다음, export할 함수들을 명시하고 나서, 함수를 작성할 수 있습니다. we'll start with
          this.</p>
        <pre name="code" class="haskell:ghci">module Geometry
( sphereVolume
, sphereArea
, cubeVolume
, cubeArea
, cuboidArea
, cuboidVolume
) where
</pre>
        <p>보시다시피, 구(sphere), 정육면체(cube), 직육면체(cuboid)의 부피와 면적을 구할 것입니다.
          이제 함수를 정의해 봅시다:</p>
        <pre name="code" class="haskell:ghci">module Geometry
( sphereVolume
, sphereArea
, cubeVolume
, cubeArea
, cuboidArea
, cuboidVolume
) where

sphereVolume :: Float -&gt; Float
sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)

sphereArea :: Float -&gt; Float
sphereArea radius = 4 * pi * (radius ^ 2)

cubeVolume :: Float -&gt; Float
cubeVolume side = cuboidVolume side side side

cubeArea :: Float -&gt; Float
cubeArea side = cuboidArea side side side

cuboidVolume :: Float -&gt; Float -&gt; Float -&gt; Float
cuboidVolume a b c = rectangleArea a b * c

cuboidArea :: Float -&gt; Float -&gt; Float -&gt; Float
cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

rectangleArea :: Float -&gt; Float -&gt; Float
rectangleArea a b = a * b
</pre>
        <p>Pretty standard geometry right here. There are a few things
          to take note of though. Because a cube is only a special case
          of a cuboid, we defined its area and volume by treating it as
          a cuboid whose sides are all of the same length. We also
          defined a helper function called <span class="fixed">rectangleArea</span>,
          which calculates a rectangle's area based on the lenghts of
          its sides. It's rather trivial because it's just
          multiplication. Notice that we used it in our functions in the
          module (namely <span class="fixed">cuboidArea</span> and <span
            class="fixed">cuboidVolume</span>) but we didn't export it!
          Because we want our module to just present functions for
          dealing with three dimensional objects, we used <span class="fixed">rectangleArea</span>
          but we didn't export it.</p>
        <p>When making a module, we usually export only those functions
          that act as a sort of interface to our module so that the
          implementation is hidden. If someone is using our <span class="fixed">Geometry</span>
          module, they don't have to concern themselves with functions
          that we don't export. We can decide to change those functions
          completely or delete them in a newer version (we could delete
          <span class="fixed">rectangleArea</span> and just use <span class="fixed">*</span>
          instead) and no one will mind because we weren't exporting
          them in the first place.</p>
        <p>To use our module, we just do:</p>
        <pre name="code" class="haskell:ghci">import Geometry
</pre>
        <p><span class="fixed">Geometry.hs</span> has to be in the same
          folder that the program that's importing it is in, though.</p>
        <p>Modules can also be given a hierarchical structures. Each
          module can have a number of sub-modules and they can have
          sub-modules of their own. Let's section these functions off so
          that <span class="fixed">Geometry</span> is a module that has
          three sub-modules, one for each type of object.</p>
        <p>First, we'll make a folder called <span class="fixed">Geometry</span>.
          Mind the capital G. In it, we'll place three files: <span class="fixed">Sphere.hs</span>,
          <span class="fixed">Cuboid.hs</span>, and <span class="fixed">Cube.hs</span>.
          Here's what the files will contain:</p>
        <p><span class="fixed">Sphere.hs</span></p>
        <pre name="code" class="haskell:ghci">module Geometry.Sphere
( volume
, area
) where

volume :: Float -&gt; Float
volume radius = (4.0 / 3.0) * pi * (radius ^ 3)

area :: Float -&gt; Float
area radius = 4 * pi * (radius ^ 2)
</pre>
        <p><span class="fixed">Cuboid.hs</span></p>
        <pre name="code" class="haskell:ghci">module Geometry.Cuboid
( volume
, area
) where

volume :: Float -&gt; Float -&gt; Float -&gt; Float
volume a b c = rectangleArea a b * c

area :: Float -&gt; Float -&gt; Float -&gt; Float
area a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

rectangleArea :: Float -&gt; Float -&gt; Float
rectangleArea a b = a * b
</pre>
        <p><span class="fixed">Cube.hs</span></p>
        <pre name="code" class="haskell:ghci">module Geometry.Cube
( volume
, area
) where

import qualified Geometry.Cuboid as Cuboid

volume :: Float -&gt; Float
volume side = Cuboid.volume side side side

area :: Float -&gt; Float
area side = Cuboid.area side side side
</pre>
        <p>Alright! So first is <span class="fixed">Geometry.Sphere</span>.
          Notice how we placed it in a folder called <span class="fixed">Geometry</span>
          and then defined the module name as <span class="fixed">Geometry.Sphere</span>.
          We did the same for the cuboid. Also notice how in all three
          sub-modules, we defined functions with the same names. We can
          do this because they're separate modules. We want to use
          functions from <span class="fixed">Geometry.Cuboid</span> in
          <span class="fixed">Geometry.Cube</span> but we can't just
          straight up do <span class="fixed">import Geometry.Cuboid</span>
          because it exports functions with the same names as <span class="fixed">Geometry.Cube</span>.
          That's why we do a qualified import and all is well.</p>
        <p>So now if we're in a file that's on the same level as the <span
            class="fixed">Geometry</span> folder, we can do, say:</p>
        <pre name="code" class="haskell:ghci">import Geometry.Sphere
</pre>
        <p>And then we can call <span class="fixed">area</span> and <span
            class="fixed">volume</span> and they'll give us the area and
          volume for a sphere. And if we want to juggle two or more of
          these modules, we have to do qualified imports because they
          export functions with the same names. So we just do something
          like:</p>
        <pre name="code" class="haskell:ghci">import qualified Geometry.Sphere as Sphere
import qualified Geometry.Cuboid as Cuboid
import qualified Geometry.Cube as Cube
</pre>
        <p>And then we can call <span class="fixed">Sphere.area</span>,
          <span class="fixed">Sphere.volume</span>, <span class="fixed">Cuboid.area</span>,
          etc. and each will calculate the area or volume for their
          corresponding object.</p>
        <p>The next time you find yourself writing a file that's really
          big and has a lot of functions, try to see which functions
          serve some common purpose and then see if you can put them in
          their own module. You'll be able to just import your module
          the next time you're writing a program that requires some of
          the same functionality.</p>
        <div class="footdiv">
          <ul>
            <li style="text-align: left;"> <a href="higher-order-functions"
                class="prevlink">Higher Order Functions</a> </li>
            <li style="text-align: center;"> <a href="chapters">목 차</a><br>
            </li>
            <li style="text-align: right;"> <a href="making-our-own-types-and-typeclasses"
                class="nxtlink">Making Our Own Types and Typeclasses</a>
            </li>
          </ul>
        </div>
      </div>
      <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
      <script type="text/javascript" src="shBrushHaskell.js"></script>
      <script type="text/javascript" src="shBrushPlain.js"></script>
      <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script> </div>
    <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script> </body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>Learn You a Haskell for Great Good! - Modules</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <base href="http://netpyoung.github.com/learn_you_a_haskell_for_great_good/">
    <style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style><link rel="shortcut icon" href="favicon.png" type="image/png">
    <link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
    <link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
  </head>
  <body class="introcontent">
    <div class="bgwrapper">
      <div id="content">
        <div class="footdiv" style="margin-bottom: 25px;">
          <ul>
            <li style="text-align: left;"> <a href="higher-order-functions"
                class="prevlink">Higher Order Functions</a> </li>
            <li style="text-align: center;"> <a href="chapters">목 차</a><br>
            </li>
            <li style="text-align: right;"> <a href="making-our-own-types-and-typeclasses"
                class="nxtlink">Making Our Own Types and Typeclasses</a>
            </li>
          </ul>
        </div>
        <h1>모듈</h1>
        <a name="loading-modules"></a>
        <h2>모듈 불러오기</h2>
        <img src="http://s3.amazonaws.com/lyah/modules.png" alt="modules"
          class="right" height="162" width="230">
        <p>하스켈 모듈은 함수, 타입, 타입클래스의 집합입니다. 하스켈 프로그램은 모듈의 집합이며, 주(main)모듈이
          다른 모듈을 불러와서 그곳에 정의된 함수를 이용하여 무언가를 수행합니다. 코드를 여러 모듈로 나누는 것에는
          상당한 이점이 있습니다. 모듈이 충분히 generic하다면, 여기서 추출된 함수들은 여러 프로그램에서 사용할 수
          있습니다. 코드가 다른 모듈에 너무 의존하지 않는 독립적인 모듈로 나눠진다면(느슨한 결합이라고도 합니다), 후에
          다시 이용할 수 있습니다. 목적에 맞게 여러 부분으로써 나눔으로써, 관리하기 편한 코드를 작성할 수 있게됩니다.</p>
        <p>하스켈의 표준 라이브러리는 여러 모듈로 나누어졌으며, 각각은 공용 목적에 관계된 함수와 타입을 포함합니다.
          여기에는 리스트를 다루는 모듈, 다중 처리(concurrent programming)을 위한 모듈,
          복소수(complex numbers)를 다루기 위한 모듈 등등이 있습니다. 지금까지 저희가 다룬 함수, 타입,
          타입클래스 모두 기본적으로 import된 <span class="fixed">Prelude</span>의 한
          부분입니다. 먼저, 모듈을 import하는 방법을 살펴보겠습니다.</p>
        <p>하스켈에서 모듈을 import하는 문법으로는 <span class="fixed">import
            &lt;module name&gt;</span>입니다. 이는 함수 정의 전에 행해져야만 하며, 따라서
          import는 보통 파일의 상단에서 행해집니다. 물론, 하나의 스크립트에서 여러 모듈을 import할 수
          있습니다. 단지 여러 줄에 걸쳐 각 import문을 넣으면 됩니다. 리스트를 다루는 유용한 함수들을 지닌 <span
            class="fixed">Data.List</span>모듈을 import한다음, 불러온 함수를 이용하여
          리스트에 고유한 원소들이 얼마만큼 있는지 알려주는 함수를 만들어 봅시다.</p>
        <pre name="code" class="haskell:hs">import Data.List

numUniques :: (Eq a) =&gt; [a] -&gt; Int
numUniques = length . nub
</pre>
        <p><span class="fixed">import Data.List</span>를 하면, 전역 이름공간에서 <span
            class="fixed">Data.List</span>에서 불러온 모든 함수들을 이용할 수 있게되어,
          스크립트 어디에서나 호출할 수 있게됩니다. <span class="fixed">Data.List</span>에
          정의된 <span class="fixed">nub</span>함수는 리스트를 받아 중복된 요소들을 없애
          버립니다.&nbsp; <span class="fixed">length . nub</span>으로 <span
            class="fixed">length</span>와 <span class="fixed">nub</span>을
          합침으로써, <span class="fixed">\xs -&gt; length (nub xs)</span>와
          동일한 함수를 만들어 냈습니다.</p>
        <p>또한 GHCI를 이용시, 모듈의 함수들을 전역 이름공간에 넣을 수 있습니다. GHCI에서 <span class="fixed">Data.List</span>에
          서 추출된 함수들을 호출하고자 한다면, 이렇게 하면 됩니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; :m + Data.List
</pre>
        <p>여러 모듈들을 불러오기 위해 GHCI에서 여러번 <span class="fixed">:m +</span>을
          수행해서는 안되며, 한번에 불러와야만 합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; :m + Data.List Data.Map Data.Set
</pre>
        <p>이미 모듈을 import한 스크립트를 불러왔다면, 이에 접근하기 위해 <span class="fixed">:m




















            +</span>을 사용할 필요가 없습니다.</p>
        <p>모듈에서 2개의 함수만 필요하다면, 선택적으로 import 할 수 있습니다.&nbsp; <span class="fixed">Data.List</span>에
          서 <span class="fixed">nub</span>, <span class="fixed">sort</span>함
          수만 import하려면, 이렇게 하시면 됩니다:</p>
        <pre name="code" class="haskell:hs">import Data.List (nub, sort)
</pre>
        <p>모듈에서 선택된 것을 제외한 모든 함수들을 import할 수 도 있습니다. 이는 동일한 이름의 함수를 지닌
          모듈을 import할때 유용합니다. 이미 <span class="fixed">nub</span>란 함수를
          정의하였고, <span class="fixed">Data.List</span>에서 <span class="fixed">nub</span>함
          수를 제외한 모든 함수들을 import한다고 가정해 봅시다: </p>
        <pre name="code" class="haskell:hs">import Data.List hiding (nub)
</pre>
        <p>이름 충돌을 처리하는 또 다른 방법으로는 qualified import를 하는 것입니다.&nbsp; 키로 값을
          살펴볼 수 있는 자료구조를 지원하는 <span class="fixed">Data.Map</span>모듈
          은&nbsp; <span class="fixed">filter</span>나 <span class="fixed">null</span>처
          럼 <span class="fixed">Prelude</span>와 동일한 이름의 함수를
          제공합니다.&nbsp; <span class="fixed">Data.Map</span>을 import하고 <span
            class="fixed">filter</span>를 호출하면, 하스켈은 어떤 함수를 이용해야 하는지를 알 수
          없게 됩니다. 여기 이 문제의 해결책이 나와 있습니다:</p>
        <pre name="code" class="haskell:hs">import qualified Data.Map
</pre>
        <p><span class="fixed">filter</span>는 저희가 익숙한 <span class="fixed">filter</span>를
          가리키지만, 만약 <span class="fixed">Data.Map</span>의 <span class="fixed">filter</span>함
          수를 참조하고자 한다면,&nbsp; <span class="fixed">Data.Map.filter</span>라
          해야합니다. 하지만, <span class="fixed">Data.Map</span>의 함수 앞에 매번 <span
            class="fixed">Data.Map</span>를 입력하는 것은 지루한 일입니다. qualified
          import로 이름을 짧게 지을 수 있습니다:</p>
        <pre name="code" class="haskell:hs">import qualified Data.Map as M
</pre>
        <p>이제, <span class="fixed">M.filter</span>을 이용하여 <span class="fixed">Data.Map</span>의
          <span class="fixed">filter</span>함수를 참조할 수 있습니다.</p>
        <p> <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/">이
            참고문서</a>를 이용하여 표준 라이브러리에 어떠한 모듈이 있는지 살펴보시기 바랍니다. 새로운 하스켈 지식을
          얻기위한 최선의 방법은 표준 라이브러리 레퍼런스를 클릭하여, 모듈과 함수들을 살펴보는 것입니다. 또한 각 모듈의
          소스 코드를 확인하는 것도 있습니다. 여러 모듈의 소스코드를 읽는 것은 하스켈을 배우고 체움에 있어 매우 좋은
          방법입니다.</p>
        <p>함수를 검색하거나, 위치한 장소를 찾고자 한다면, <a href="http://haskell.org/hoogle">Hoogle</a>을
          이용하시기 바랍니다. 이는 실로 놀랄만한 하스켈 검색 엔진이며,&nbsp; 이름, 모듈, 심지어 타입 서명으로도
          검색할 수 있습니다.</p>
        <a name="data-list"></a>
        <h2>Data.List</h2>
        <p><span class="fixed">Data.List</span>모듈은 보시는 바처럼 리스트에 관한 것입니다.
          이는 리스트를 다루는데 있어 매우 유용한 함수들을 제공해 줍니다. 저희는 이미 <span class="fixed">map</span>과
          <span class="fixed">filter</span>와 같은 몇몇 함수들을 만나 보았는데,
          편의상&nbsp; <span class="fixed">Prelude</span>모듈이&nbsp; <span
            class="fixed">Data.List</span>에서 함수 몇개를 가져오기 때문입니다. <span class="fixed">Prelude</span>가
          이미 <span class="fixed">Data.List</span>에서 가저온 이름을 제외하면 어떠한
          이름도 충돌하지 않기에, qualified import 통해 <span class="fixed">Data.List</span>를
          import해서는 안됩니다. 이제 저희가 이전에 보지 못했던 함수들을 살펴봅시다.</p>
        <p><span class="label function">intersperse</span>는 원소와 리스트를 받아,
          리스트의 각 요소들 사이마다 받은 원소를 껴놓습니다. 여기 실례가 있습니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; intersperse '.' "MONKEY"
"M.O.N.K.E.Y"
ghci&gt; intersperse 0 [1,2,3,4,5,6]
[1,0,2,0,3,0,4,0,5,0,6]
</pre>
        <p><span class="label function">intercalate</span>는 리스트와 리스트의
          리스트를 받습니다. 그런 다음 리스트의 리스트 사이에 리스트를 껴놓아서 반듣한 결과를 내놓습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; intercalate " " ["hey","there","guys"]
"hey there guys"
ghci&gt; intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]]
[1,2,3,0,0,0,4,5,6,0,0,0,7,8,9]
</pre>
        <p><span class="label function">transpose</span>는 리스트의 리스트를
          전치(transpose)합니다. 리스트의 리스트를 2차원 행렬로 본다면, 행은 열, 열은 행이될 것입니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; transpose [[1,2,3],[4,5,6],[7,8,9]]
[[1,4,7],[2,5,8],[3,6,9]]
ghci&gt; transpose ["hey","there","guys"]
["htg","ehu","yey","rs","e"]
</pre>
        <p>다항식 <span style="font-style: italic;"></span><i>3x<sup>2</sup>
            + 5x + 9</i>, <i>10x<sup>3</sup> + 9</i>, <i>8x<sup>3</sup>
            + 5x<sup>2</sup> + x - 1</i>를 서로 더한다 해봅시다. 하스켈로 리스트 <span class="fixed">[0,3,5,9]</span>,
          <span class="fixed">[10,0,0,9]</span>, <span class="fixed">[8,5,1,-1]</span>로
          나타낼 수 있습니다. 이제, 다음처럼 합칠 수 있습니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
[18,8,6,17]
</pre>
        <p>이 3개의 리스트를 전치(transpose)하면서, 3차항을 첫번째 줄에 2차항을 두번째 줄에 ... 등등
          넣었습니다. 다음으로 <span class="fixed">sum</span>을 map하여 원하는 결과를
          얻었습니다.</p>
        <img src="http://s3.amazonaws.com/lyah/legolists.png" alt="shopping lists"
          class="left" height="212" width="230">
        <p><span class="label function">foldl'</span>와 <span class="label function">foldl1'</span>는
          lazy(게으른)가 아닌 stict(엄격한)버전 입니다. 매우 큰 리스트에 lazy fold를 사용한다면, 스텍
          오버플로우 에러가 날 것입니다. 범인은 실제론 fold가 일어나는 동안 축적되는 값이 갱신되지 않는 fold의
          lazy한 환경입니다. 실제로 발생하는 일은 누산기 비슷한것이 '결과를 요청할때 계산이 시작된다는
          것(thunk라고도 합니다)'을 약속하는 것입니다. 누산이 될때마다, 이러한 thunk들은 스택을 넘치게 할
          것입니다. strict fold는 게으른 벌레(lazy bugger)가 아니며, 스택을 무언가(thunk)로
          채워넣는 대신 중간 값을 계산합니다. 그러므로, lazy fold하는 동안에 스택오버플로우 에러를 만나게되면,
          stict버전으로 바꿔보시기 바랍니다.</p>
        <p><span class="label function">concat</span>은 리스트의 리스트를 원소 리스트로
          펴줍니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; concat ["foo","bar","car"]
"foobarcar"
ghci&gt; concat [[3,4,5],[2,3,4],[2,1,1]]
[3,4,5,2,3,4,2,1,1]
</pre>
        <p>이는 단지 중첩 레벨을 한단계 낮출 뿐입니다. 따라서 리스트의 리스트의 리스트인 <span class="fixed">[[[2,3],[3,4,5],[2]],[[2,3],[3,4]]]</span>
          를 완전히 펴려면, concat을 두번 해야 합니다.</p>
        <p><span class="label function">concatMap</span>이 하는 일은 리스트에 함수를
          map하고나서, <span class="fixed">concat</span>하는 것과 같습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; concatMap (replicate 4) [1..3]
[1,1,1,1,2,2,2,2,3,3,3,3]
</pre>
        <p><span class="label function">and</span>는 부울 값을 지닌 리스트를 받아
          리스트의 모든 값이 <span class="fixed">True</span>경우,&nbsp; <span class="fixed">True</span>를
          반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; and $ map (&gt;4) [5,6,7,8]
True
ghci&gt; and $ map (==4) [4,4,4,3,4]
False
</pre>
        <p><span class="label function">or</span>는 <span class="fixed">and</span>와
          비슷하지만, 리스트 중 <span class="fixed">True</span>인 값이 하나라도 있는 경우,
          <span class="fixed">True</span>를 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; or $ map (==4) [2,3,4,5,6,1]
True
ghci&gt; or $ map (&gt;4) [1,2,3]
False
</pre>
        <p><span class="label function">any</span>와 <span class="label function">all</span>
          각각 predicate를 받아 리스트의 어떤 혹은 모든 원소들이 술부를 만족하는지 확인합니다. 보통 리스트를
          map한 다음 <span class="fixed">and</span>나 <span class="fixed">or</span>을
          하는 대용으로, 이 두 함수가 사용됩니다.<br>
        </p>
        <pre name="code" class="haskell:ghci">ghci&gt; any (==4) [2,3,5,6,1,4]
True
ghci&gt; all (&gt;4) [6,9,10]
True
ghci&gt; all (`elem` ['A'..'Z']) "HEYGUYSwhatsup"
False
ghci&gt; any (`elem` ['A'..'Z']) "HEYGUYSwhatsup"
True
</pre>
        <p><span class="label function">iterate</span>는 함수와 시작값을 받습니다.
          이는 시작값에 함수를 적용한 다음, 그 결과에 함수를 적용시키는 것을 반복합니다. 반환하는 결과값은 모두 무한
          리스트의 형태를 띄게됩니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; take 10 $ iterate (*2) 1
[1,2,4,8,16,32,64,128,256,512]
ghci&gt; take 3 $ iterate (++ "haha") "haha"
["haha","hahahaha","hahahahahaha"]
</pre>
        <p><span class="label function">splitAt</span>은 숫자와 리스트를 받습니다.
          그런 다음, 숫자만큼 리스트를 자르어, 두 리스트를 튜플로 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; splitAt 3 "heyman"
("hey","man")
ghci&gt; splitAt 100 "heyman"
("heyman","")
ghci&gt; splitAt (-3) "heyman"
("","heyman")
ghci&gt; let (a,b) = splitAt 3 "foobar" in b ++ a
"barfoo"
</pre>
        <p><span class="label function">takeWhile</span>는 작고 매우 유용한 함수
          입니다. predicate를 만족하는 동안 리스트에서 원소를 취하다가, 만족하지 않으면, 잘라냅니다. 이는 매우
          유용합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; takeWhile (&gt;3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]
[6,5,4]
ghci&gt; takeWhile (/=' ') "This is a sentence"
"This"
</pre>
        <p>10,000보다 작은 수의 세제곱의 합을 원한다고 가정해 봅시다. 무한 리스트에서의 걸러내는 작업은 결코
          끝나지 않기에,&nbsp; <span class="fixed">(^3)</span>을 <span class="fixed">[1..]</span>에
          map시킨 후, filter적용하여 합을 구할 순 없습니다. 여러분이 여기서 모든 원소들이 오름차순이란걸
          알더라도, 하스켈은 그렇지 않습니다. 이것이 바로 왜 다음과 같이 해야만 되는지에 대한 이유입니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; sum $ takeWhile (&lt;10000) $ map (^3) [1..]
53361
</pre>
        <p><span class="fixed">(^3)</span>을 무한 리스트에 적용한후, 10,000을 넘어가는
          원소를 만나면, 리스트를 끊습니다. 이제 저희는 쉽게 합을 구할 수 있습니다.</p>
        <p>유사한 <span class="label function">dropWhile</span>는
          predicate가 참인 동안에만 원소들을 내칩니다. 술부(predicate)가 <span class="fixed">False</span>이
          면, 리스트의 나머지를 반환합니다. 굉장히 유용하며 사랑스런 함수가 아닐 수 없습니다!</p>
        <pre name="code" class="haskell:ghci">ghci&gt; dropWhile (/=' ') "This is a sentence"
" is a sentence"
ghci&gt; dropWhile (&lt;3) [1,2,2,2,3,4,5,4,3,2,1]
[3,4,5,4,3,2,1]
</pre>
        <p>그날의 주식 현황을 표현하는 리스트를 가졌다고 가정해봅시다. 리스트는 주식 값, 년도, 월, 날짜로 구성된
          튜플들로 만들어졌습니다. 이제 주식값이 언제 처음으로 1000달러를 넘는지 확인해봅시다!</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let stock = [(994.4,2008,9,1),(995.2,2008,9,2),(999.2,2008,9,3),(1001.4,2008,9,4),(998.3,2008,9,5)]
ghci&gt; head (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)
(1001.4,2008,9,4)
</pre>
        <p><span class="label function">span</span>은 <span class="fixed">takeWhile</span>와
          같은 부류이지만, 리스트 쌍을 반환합니다. 첫번째 리스트는 <span class="fixed">takeWhile</span>에
          서 나온 것을 모두 포함합니다. 두번째 리스트는 떨어져 나온 부분만을 포함합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let (fw, rest) = span (/=' ') "This is a sentence" in "First word:" ++ fw ++ ", the rest:" ++ rest
"First word: This, the rest: is a sentence"
</pre>
        <p><span class="fixed">span</span>은 predicate가 참인 동안 포함하지만, <span
            class="label function">break</span>는 predicate가 참이면 멈춥니다. <span
            class="fixed">break p</span>가 하는 일은 <span class="fixed">span



            (not . p)</span>와 동일합니다. </p>
        <pre name="code" class="haskell:ghci">ghci&gt; break (==4) [1,2,3,4,5,6,7]
([1,2,3],[4,5,6,7])
ghci&gt; span (/=4) [1,2,3,4,5,6,7]
([1,2,3],[4,5,6,7])
</pre>
        <p><span class="fixed">break</span>를 사용할 시에는, 결과의 두번째 리스트는
          predicate를 만족하는 원소로 시작할 것입니다.</p>
        <p><span class="label function">sort</span>는 단순히 리스트를 정렬합니다. 순서를
          갖지 않으면 정렬할 수 없기에, 리스트의 원소의 타입은 <span class="fixed">Ord</span>타
          입클래스에 속해야 합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; sort [8,5,3,2,1,6,4,2]
[1,2,2,3,4,5,6,8]
ghci&gt; sort "This will be sorted soon"
"    Tbdeehiillnooorssstw"
</pre>
        <p><span class="label function">group</span>은 리스트를 받아, 인접한 동일한
          원소들을 하위 리스트로 묶습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]
</pre>
        <p>리스트를 group하기 전에 정렬한다면, 리스트의 각 원소들이 얼마나 있는지 확인할 수 있을 것입니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; map (\l@(x:xs) -&gt; (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]
</pre>
        <p><span class="label function">inits</span>과 <span class="label function">tails</span>은
          <span class="fixed">init</span>와 <span class="fixed">tail</span>과
          비슷하지만, 남아있는게 없을때까지 리스트에 재귀적으로 적용합니다. 살펴봅시다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; inits "w00t"
["","w","w0","w00","w00t"]
ghci&gt; tails "w00t"
["w00t","00t","0t","t",""]
ghci&gt; let w = "w00t" in zip (inits w) (tails w)
[("","w00t"),("w","00t"),("w0","0t"),("w00","t"),("w00t","")]
</pre>
        <p>fold를 이용하여 하위 리스트로 리스트를 검색하는 것을 구현해 봅시다.</p>
        <pre name="code" class="haskell:hs">search :: (Eq a) =&gt; [a] -&gt; [a] -&gt; Bool
search needle haystack = 
    let nlen = length needle
    in  foldl (\acc x -&gt; if take nlen x == needle then True else acc) False (tails haystack)
</pre>
        <p>우선 검색할 리스트에 <span class="fixed">tails</span>을 호출합니다. 그리고나서 각
          tail마다 저희가 찾고자 하는 걸로 시작하는지 확인합니다.</p>
        <p>여기서, 저희는 <span class="label function">isInfixOf</span>와 비슷한
          함수를 만들었습니다. <span class="fixed">isInfixOf</span>는 하위 리스트로
          리스트를 검색하며, 찾고자 하는 하위 리스트가 대상 리스트에 있으면 <span class="fixed">True</span>를
          반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; "cat" `isInfixOf` "im a cat burglar"
True
ghci&gt; "Cat" `isInfixOf` "im a cat burglar"
False
ghci&gt; "cats" `isInfixOf` "im a cat burglar"
False
</pre>
        <p><span class="label function">isPrefixOf</span>와 <span class="label function">isSuffixOf</span>는
          각각 하위리스트로 리스트의 시작과 끝을 검색합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; "hey" `isPrefixOf` "hey there!"
True
ghci&gt; "hey" `isPrefixOf` "oh hey there!"
False
ghci&gt; "there!" `isSuffixOf` "oh hey there!"
True
ghci&gt; "there!" `isSuffixOf` "oh hey there"
False
</pre>
        <p><span class="label function">elem</span>과 <span class="label function">notElem</span>은
          원소가 리스트 안에 있는지 검사합니다.</p>
        <p><span class="label function">partition</span>는 리스트와
          predicate를 취해, 리스트 쌍을 반환합니다. 결과의 첫번째 리스트는 predicate를 만족하는 모든
          원소들을 포함하고 있으며, 두번째는 만족하지 않는 것들을 포함하고 있습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; partition (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"
("BOBMORGAN","sidneyeddy")
ghci&gt; partition (&gt;3) [1,3,5,6,3,2,1,0,3,7]
([5,6,7],[1,3,3,2,1,0,3])
</pre>
        <p><span class="fixed">span</span>과 <span class="fixed">break</span>의
          차이점을 이해하는 것이 중요합니다:<br>
        </p>
        <pre name="code" class="haskell:ghci">ghci&gt; span (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"
("BOB","sidneyMORGANeddy")
</pre>
        <p><span class="fixed">span</span>과&nbsp; <span class="fixed">break</span>이
          predicate를 만족하거나 만족하지 못하는 원소를 만나면 멈추는 반면, <span class="fixed">partition</span>는
          리스트 전체를 훝어 predicate에 따라 나눕니다.</p>
        <p><span class="label function">find</span>는 predicate와 리스트를 취해,
          predicate를 만족하는 첫번째 요소를 <span class="fixed">Maybe</span>값으로
          감싸 반환합니다. 다음 장에서 대수적 자료구조에 대해 깊게 다룰 것이지만, 지금 저희가 알아야 할 것은 다음과
          같습니다: ' <span class="fixed">Maybe</span>는&nbsp; <span class="fixed">Just
            something</span>이나 <span class="fixed">Nothing</span>이 될 수
          있다'. 리스트는 비어있는 리스트가 되거나 무언가를 담은 리스트가 될 수 있는 것처럼, <span class="fixed">Maybe</span>값
          은 단일 요소이거나 아무런 요소도 아닐 수 있습니다. 그리고 정수 리스트의 타입을 <span class="fixed">[Int]</span>라
          하는것 처럼, 정수에 대한 타입은 <span class="fixed">Maybe Int</span>가 됩니다.
          어찌됐던간에, <span class="fixed">find</span>함수를 돌려 봅시다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; find (&gt;4) [1,2,3,4,5,6]
Just 5
ghci&gt; find (&gt;9) [1,2,3,4,5,6]
Nothing
ghci&gt; :t find
find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a
</pre>
        <p><span class="fixed">find</span>의 타입을 주목하시기 바랍니다. 이의 결과는 <span
            class="fixed">Maybe a</span>입니다. <span class="fixed">[a]</span>를
          타입으로 갖는 리스트가 하나 혹은 여러원소를 포함하거나, 아무런 원소도 포함하지 않을 수 있는 것과 달리, <span
            class="fixed">Maybe</span>타입의 값은 하나의 원소를 포함하거나, 아무런 원소도 포함하지
          않을 수 있습니다.</p>
        <p>주식이 처음으로 $1000를 넘어선 날을 찾을 때를 떠올려 보시기 바랍니다. <span class="fixed">head















            (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)</span>라
          하였습니다. <span class="fixed">head</span>가 실제론 안전하지 않다는 점을 기억하시기
          바랍니다. $1000를 넘는 주식이 없다면 어떤일이 발생할까요?&nbsp; <span class="fixed">dropWhile</span>은
          비어있는 리스트를 반환할 것이며, 빈 리스트의 head를 얻으려 한다면 에러를 결과로 얻을 것입니다.
          하지만,&nbsp; <span class="fixed">find (\(val,y,m,d) -&gt; val
            &gt; 1000) stock</span>라고 재작성한다면, 비교적 안전할 것입니다. 주식이 $1000을
          넘지 않는다면(어떠한 요소도 predicate를 만족하지 않는다면),&nbsp; <span class="fixed">Nothing</span>을
          얻을 것입니다. 반면, 리스트에 유효한 값이 있다면, <span class="fixed">Just
            (1001.4,2008,9,4)</span>라는 값을 얻게될 것입니다. </p>
        <p><span class="label function">elemIndex</span>는 <span class="fixed">elem</span>와
          비슷하나, 부울값을 반환하지 않고, 찾는 원소의 위치를 반환합니다. 리스트내에 원소가 없으면,&nbsp; <span
            class="fixed">Nothing</span>을 반환합니다. </p>
        <pre name="code" class="haskell:ghci">ghci&gt; :t elemIndex
elemIndex :: (Eq a) =&gt; a -&gt; [a] -&gt; Maybe Int
ghci&gt; 4 `elemIndex` [1,2,3,4,5,6]
Just 3
ghci&gt; 10 `elemIndex` [1,2,3,4,5,6]
Nothing
</pre>
        <p><span class="label function">elemIndices</span>은 <span class="fixed">elemIndex</span>와
          같으나, 찾고자 하는 원소가 여러번 나타나는 위치 리스트를 반환합니다. 리스트를 이용하여 위치를 표현하기에, <span
            class="fixed">Maybe</span>타입이 필요없는데, 실패는 <span class="fixed">Nothing</span>와
          매우 유사한 빈 리스트로 표현할 수 있기 때문입니다.<br>
        </p>
        <pre name="code" class="haskell:ghci">ghci&gt; ' ' `elemIndices` "Where are the spaces?"
[5,9,13]
</pre>
        <p><span class="label function">findIndex</span>는 find와 같으나,
          predicate를 만족하는 처음 원소만 아마(maybe) 반환할 것입니다. <span class="label function">findIndices</span>는
          리스트에서 predicate를 만족하는 원소들의 위치를 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; findIndex (==4) [5,3,2,1,6,4]
Just 5
ghci&gt; findIndex (==7) [5,3,2,1,6,4]
Nothing
ghci&gt; findIndices (`elem` ['A'..'Z']) "Where Are The Caps?"
[0,6,10,14]
</pre>
        <p>저희는 이미 <span class="fixed">zip</span>와 <span class="fixed">zipWith</span>를
          다루었습니다. 이들은 2개의 리스트를, 튜플이나 인자를 두개 받는 함수(binary function)로
          엮습니다. 그러면 3개의 리스트를 서로 엮으려면 어떻게 할까요? 아니면, 3개의 리스트를 3개의 인자를 받는
          함수로 엮으려면 어떻게 할까요? 이러한 것들을 위해 <span class="label function">zip3</span>,
          <span class="label function">zip4</span>, <span class="label function">zipWith3</span>,
          <span class="label function">zipWith4</span>, 등등이 있습니다. 이러한
          변종들은 7까지 있습니다. 꼼수(hack)처럼 보이더라도, 8개의 리스트를 서로 엮을 기회는 많이 없을 터이니
          문제없을 것입니다. 리스트를 무한히 엮을 수 있는 획기적인 방법도 있으나, 지금 다루기에는 조금 이른감이
          있습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; zipWith3 (\x y z -&gt; x + y + z) [1,2,3] [4,5,2,2] [2,2,3]
[7,9,8]
ghci&gt; zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]
[(2,2,5,2),(3,2,5,2),(3,2,3,2)]
</pre>
        <p>다른 평범한 엮는 작업처럼, 리스트들은 적당한 크기로 엮어지게 됩니다.</p>
        <p><span class="label function">lines</span>은 파일이나 입력을 다룰때 유용한
          함수입니다. 이는 문자열을 취해 줄 단위로 나누어 리스트로 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; lines "first line\nsecond line\nthird line"
["first line","second line","third line"]
</pre>
        <p><span class="fixed">'\n'</span>은 유닉스의 개행문자입니다. 역슬러쉬는 하스켈에서
          문자열과 문자간에 특별한 의미를 지니고 있습니다.</p>
        <p><span class="label function">unlines</span>은 <span class="fixed">lines</span>과
          반대되는 함수입니다. 이는 문자열 리스트를 받아 <span class="fixed">'\n'</span>로
          서로를 연결합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; unlines ["first line", "second line", "third line"]
"first line\nsecond line\nthird line\n"
</pre>
        <p><span class="label function">words</span>와 <span class="label function">unwords</span>는
          텍스트 라인을 단어 단위로 나누거나, 단어 리스트를 문자열로 연결합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; words "hey these are the words in this sentence"
["hey","these","are","the","words","in","this","sentence"]
ghci&gt; words "hey these           are    the words in this\nsentence"
["hey","these","are","the","words","in","this","sentence"]
ghci&gt; unwords ["hey","there","mate"]
"hey there mate"
</pre>
        <p>전에 제가 <span class="label function">nub</span>을 언급하였습니다. 이는
          리스트를 받아 중복된 원소들을 제거하여, (눈꽃처럼) 고유한 원소구성된 리스트를 반환합니다! 이 함수는 이상한
          이름을 지녔습니다. "nub"는 작은 덩어리나 무언가의 필수적인 부분을 의미합니다. 제 개인적인 생각으론,
          함수의 이름은 구어체 대신 실제 사용하는 단어를 사용해야 한다고 생각합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; nub [1,2,3,4,3,2,1,2,3,4,3,2,1]
[1,2,3,4]
ghci&gt; nub "Lots of words and stuff"
"Lots fwrdanu"
</pre>
        <p><span class="label function">delete</span>는 원소와 리스트를 취해 그
          리스트에서 처음 만난 원소를 지웁니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; delete 'h' "hey there ghang!"
"ey there ghang!"
ghci&gt; delete 'h' . delete 'h' $ "hey there ghang!"
"ey tere ghang!"
ghci&gt; delete 'h' . delete 'h' . delete 'h' $ "hey there ghang!"
"ey tere gang!"
</pre>
        <p><span class="label function">\\</span>는 리스트 차집합(list
          difference)함수입니다. 우측 리스트에서 좌측에 있는 요소들을 제거합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; [1..10] \\ [2,5,9]
[1,3,4,6,7,8,10]
ghci&gt; "Im a big baby" \\ "big"
"Im a  baby"
</pre>
        <p><span class="fixed">[1..10] \\ [2,5,9]</span>는&nbsp; <span class="fixed">delete














            2 . delete 5 . delete 9 $ [1..10]</span>와 같습니다.</p>
        <p><span class="label function">union</span> 또한 집합 관한 함수입니다. 이는
          두 리스트의 합집합(union)을 반환합니다. 이는 두번째 리스트의 모든 원소를 훝어본 다음 첫번째에 없는
          것들을 추가합니다. 두번째 리스트에서 중복된 부분은 사라지니 주의하시기 바랍니다!</p>
        <pre name="code" class="haskell:ghci">ghci&gt; "hey man" `union` "man what's up"
"hey manwt'sup"
ghci&gt; [1..7] `union` [5..10]
[1,2,3,4,5,6,7,8,9,10]
</pre>
        <p><span class="label function">intersect</span>는 교칩합(set
          intersection)과 같습니다. 두 리스트에서 공통된 원소들만 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; [1..7] `intersect` [5..10]
[5,6,7]
</pre>
        <p><span class="label function">insert</span>는 원소와 정렬 가능한 리스트를
          받아, 원소보다 같거나 작은 마지막 위치에 원소를 집어넣습니다. 다시말해, <span class="fixed">insert</span>는
          리스트의 시작부분에서 시작하여, 넣고자 하는 원소보다 같거나 큰 원소를 만나면, 그 원소 앞에 넣고자 하는
          원소를 삽입합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; insert 4 [3,5,1,2,8,2]
[3,4,5,1,2,8,2]
ghci&gt; insert 4 [1,3,4,4,1]
[1,3,4,4,4,1]
</pre>
        <p> <span class="fixed">4</span>는, 첫번째 예제에서 <span class="fixed">3</span>다
          음 <span class="fixed">5</span>이전에 추가되며, 두번째 예제에선 <span class="fixed">3</span>과
          <span class="fixed">4</span>사이에 추가됩니다.</p>
        정렬된 리스트에 <span class="fixed">insert</span>를 사용한다면, 결과는 정렬된 상태를
        유지할 것입니다.
        <p></p>
        <pre name="code" class="haskell:ghci">ghci&gt; insert 4 [1,2,3,5,6,7]
[1,2,3,4,5,6,7]
ghci&gt; insert 'g' $ ['a'..'f'] ++ ['h'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci&gt; insert 3 [1,2,4,3,2,1]
[1,2,3,4,3,2,1]
</pre>
        <p><span class="fixed">length</span>, <span class="fixed">take</span>,
          <span class="fixed">drop</span>, <span class="fixed">splitAt</span>,
          <span class="fixed">!!</span><span style="font-weight: bold;">,&nbsp;












          </span><span class="fixed">replicate</span>의 공통점은, <span class="fixed">Integral</span>나
          <span class="fixed">Num</span>타입클래스에 속한 타입이라면 더욱 generic하고 유용할
          수 있음에도 불구하고, (<span class="fixed">Int</span>를 반환하거나) <span class="fixed">Int</span>를
          인자로 취한다는 것입니다. 역사적인 이유 때문이기도 합니다. 하지만, 이걸 고치는 날에는기존에 존재하는 많은
          코드들이 제대로 동작하지 않을 것입니다. 이것이 왜 <span class="fixed">Data.List</span>가
          비슷하지만, 더욱 제네릭(generic)한&nbsp; <span class="label function">genericLength</span>,
          <span class="label function">genericTake</span>, <span class="label function">genericDrop</span>,
          <span class="label function">genericSplitAt</span>, <span class="label function">genericIndex</span>,
          <span class="label function">genericReplicate</span>라는 이름을
          갖는지에 대한 이유입니다. 예를들어, <span class="fixed">length</span>는&nbsp;
          <span class="fixed">length :: [a] -&gt; Int</span>타입 서명을
          지녔습니다. 숫자 리스트의 평균을 구하고자 <span class="fixed">let xs = [1..6]
            in sum xs / length xs</span>라 한다면,&nbsp; <span class="fixed">Int</span>에
          <span class="fixed">/</span>을 사용할 수 없기에 에러를 얻을 것입니다. 반면 <span
            class="fixed">genericLength</span>는 <span class="fixed">genericLength




















            :: (Num a) =&gt; [b] -&gt; a</span> 타입 서명을 지녔습니다. <span class="fixed">Num</span>은
          부동소숫점 숫자처럼 행동할 수 있기에, <span class="fixed">let xs = [1..6] in
            sum xs / genericLength xs</span>로 평균을 구하는 것은 제대로 동작할 것입니다.</p>
        <p><span class="fixed">nub</span>, <span class="fixed">delete</span>,
          <span class="fixed">union</span>, <span class="fixed">intersect</span>,
          <span class="fixed">group</span>함수들은&nbsp; 모두 <span class="label function">nubBy</span>,
          <span class="label function">deleteBy</span>, <span class="label function">unionBy</span>,
          <span class="label function">intersectBy</span>, <span class="label function">groupBy</span>라
          불리는 더욱 general한 대응체가 있습니다. 차이점은 첫번째 함수들은 같음을 확인하기 위해 <span class="fixed">==</span>를
          이용하지만, <i>By</i>가 붙은 쪽은 비교(equality)함수를 받아, 그 함수를 이용하여 비교를
          합니다. <span class="fixed">group</span>은 <span class="fixed">groupBy



            (==)</span>와 같습니다 </p>
        <p>예를들어, 매 초마다의 함수의 값을 서술한 리스트를 가지고 있다고 가정해 봅시다. 저희는 이 리스트를 0보다
          작은것과 큰것으로 구성된 하위 리스트로 쪼개길 원합니다. <span class="fixed">group</span>으
          로 한다면, 서로 같은 값만을 묶을 것입니다. 하지만 저희가 원하는 것은 음수 여부에 따라 묶는 것입니다. <span
            class="fixed">groupBy</span>가 와야할 곳이 바로 여깁니다! <i>By</i>함수에
          제공된 equality함수는 동일한 타입의 두 원소를 취해, 기준에 따라 동일하다고 판단되면 <span class="fixed">True</span>를
          반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3]
ghci&gt; groupBy (\x y -&gt; (x &gt; 0) == (y &gt; 0)) values
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
</pre>
        <p>여기서 어느 부분이 양수인지, 음수인지 명확히 알 수 있습니다. 제공된 equality함수는 두 원소를 받아,
          둘다 음수이거나 양수일 때 <span class="fixed">True</span>를 반환합니다. 첫번째
          방법이 더욱 읽기 쉽다고 생각하지만, 앞선 equality함수는&nbsp; <span class="fixed">\x




















            y -&gt; (x &gt; 0) &amp;&amp; (y &gt; 0) || (x &lt;= 0)
            &amp;&amp; (y &lt;= 0)</span>로도 작성할 수 있습니다. <i>By</i>함수의
          equality함수를 작성하기 위한 더 나은 방법으로는 <span class="fixed">Data.Function</span>의
          <span class="label function">on</span>을 import하는 것입니다. <span
            class="fixed">on</span>는 다음과 같이 정의되었습니다: </p>
        <pre name="code" class="haskell:ghci">on :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
f `on` g = \x y -&gt; f (g x) (g y)
</pre>
        <p>따라서 <span class="fixed">(==) `on` (&gt; 0)</span>은&nbsp; <span
            class="fixed">\x y -&gt; (x &gt; 0) == (y &gt; 0)</span>와 같은
          equality함수를 반환합니다. <span class="fixed">on</span>은 <i>By</i>함
          수에 많이 사용되는데, 이를 이용하여 다음처럼 처리할 수 있기 때문입니다: </p>
        <pre name="code" class="haskell:ghci">ghci&gt; groupBy ((==) `on` (&gt; 0)) values
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
</pre>
        <p>눈에 정말 잘 들어옵니다! 이를 다음처럼 크게 읽을 수 있습니다: 0보다 같거나 큰 원소를 묶어라.</p>
        <p>유사하게, <span class="fixed">sort</span>, <span class="fixed">insert</span>,
          <span class="fixed">maximum</span>, <span class="fixed">minimum</span>
          또한 더욱 general한 대응체가 있습니다. 이들 함수는 <span class="fixed">groupBy</span>과
          같이 두 원소가 동일한지 판별하는 함수를 취합니다. <span class="label function">sortBy</span>,
          <span class="label function">insertBy</span>, <span class="label function">maximumBy</span>,
          <span class="label function">minimumBy</span>은 어느 한 원소가 다른 것보다
          큰지, 작은지, 혹은 같은지를 판별하는 함수를 취합니다. <span class="fixed">sortBy</span>의
          타입서명은<span class="fixed">sortBy :: (a -&gt; a -&gt; Ordering)
            -&gt; [a] -&gt; [a]</span>입니다. 전에 배운 것을 기억하신다면,&nbsp; <span
            class="fixed">Ordering</span>타입은 <span class="fixed">LT</span>,
          <span class="fixed">EQ</span>, <span class="fixed">GT</span>의
          값을 가질 수 있었습니다. <span class="fixed">sort</span>는 <span class="fixed">Ord</span>타
          입클래스의 타입인 두 원소를 취해 둘 사이의 순서관계를 반환하기 때문에 <span class="fixed">sortBy



            compare</span>와 동일합니다.</p>
        <p>리스트는 사전 편차 상으로 비교됩니다. 만약 리스트의 리스트를 가지고 있고, 내부 리스트의 내용이 아닌 길이를
          기준으로 정렬하고자 한다면 어떻게 할까요? 음, 여러분이 예상하시는 것처럼, <span class="fixed">sortBy</span>함
          수를 사용할 수 있을 것입니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]]
ghci&gt; sortBy (compare `on` length) xs
[[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]
</pre>
        <p>이럴수가! <span class="fixed">compare `on` length</span> ... 이건
          실제 영어처럼 읽을 수 있습니다! 여기서 <span class="fixed">on</span>이 행하는 일을
          모르시는 분들을 위해, 부연설명을 하자면, <span class="fixed">compare `on`
            length</span>은 <span class="fixed">\x y -&gt; length x
            `compare` length y</span>과 동일합니다. 비교(equality)함수를 취하는 <i>By</i>함
          수를 다룰때에는, <span class="fixed">(==) `on` something</span>을
          하시고, 순서(ordering)함수를 취하는 <i>By</i>함수를 다룰 때에는, <span class="fixed">compare



            `on` something</span>를 하시기 바랍니다.</p>
        <a name="data-char"></a>
        <h2>Data.Char</h2>
        <img src="http://s3.amazonaws.com/lyah/legochar.png" alt="lego char"
          class="right" height="323" width="230">
        <p><span class="fixed">Data.Char</span>모듈은 이 이름이 시사하는 바처럼, 문자를
          다루는 함수를 제공합니다. 이 또한 문자 리스트인 문자열을 걸러내고 map할때 유용합니다.</p>
        <p><span class="fixed">Data.Char</span>는 문자를 받아 어떠한 가정이 참인지 거짓인지
          알려주는, 문자에 대한 predicate 분기 함수들을 제공합니다. 여기 어떠한 것이 있는지 나와있습니다:</p>
        <p><span class="label function">isControl</span>는 문자가 제어문자인지
          확인합니다.</p>
        <p><span class="label function">isSpace</span>는 문자가 공백문자인지
          확인합니다. 이는 띄어쓰기(space), 탭(tab), 줄바꿈(newline) 등등을 포함합니다.</p>
        <p><span class="label function">isLower</span>는 문자가 소문자인지 확인합니다.
        </p>
        <p><span class="label function">isUpper</span>는 문자가 대문자인지 확인합니다.</p>
        <p><span class="label function">isAlpha</span>는 문자가 영문자인지 확인합니다.</p>
        <p><span class="label function">isAlphaNum</span>는 문자가 영문자 혹은
          숫자인지를 확인합니다.</p>
        <p><span class="label function">isPrint</span>는 문자의 출력가능 여부를
          확인합니다. 예를들어, 제어문자는 출력하지 못합니다.</p>
        <p><span class="label function">isDigit</span>는 문자가 10진수인지
          확인합니다.</p>
        <p><span class="label function">isOctDigit</span>는 문자가 8진수인지
          확인합니다.</p>
        <p><span class="label function">isHexDigit</span>는 문자가 16진수인지
          확인합니다.</p>
        <p><span class="label function">isLetter</span>는 문자가 영문자인지
          확인합니다.</p>
        <p><span class="label function">isMark</span>는 유니코드 마크 문자인지
          확인합니다. 이는 형태 문자와 강세가 결합된 문자입니다. 프랑스어라면 이걸 이용하시기 바랍니다.</p>
        <p><span class="label function">isNumber</span>는 문자가 숫자인지 확인합니다.</p>
        <p><span class="label function">isPunctuation</span>는 문자가
          구둣점(punctuation)인지 확인합니다.</p>
        <p><span class="label function">isSymbol</span>는 문자가 수학적 심볼인지
          통화(currency) 심볼인지 확인합니다.</p>
        <p><span class="label function">isSeparator</span>는 유니코드 공백과
          구분자를 확인합니다.</p>
        <p><span class="label function">isAscii</span>은 문자가 유니코드 문자 모음 중
          처음 128 문자에 들어가는지 확인합니다.</p>
        <p><span class="label function">isLatin1</span>은 문자가 유니코드 문자 모음
          중 처음 256 문자에 들어가는지 확인합니다.</p>
        <p><span class="label function">isAsciiUpper</span>는 문자가
          ASCII이면서 대문자인지 확인합니다.</p>
        <p><span class="label function">isAsciiLower</span>는 문자가
          ASCII이면서 소문자인지 확인합니다.</p>
        <p>여기 나온 모든 predicate들은 <span class="fixed">Char -&gt; Bool</span>
          타입서명을 지니고 있습니다. 대부분 문자열 비슷한 것을 걸러내기 위해 사용할 것입니다. 예를들어, 알파벳
          문자로만 구성된 사용자 이름을 입력받는 프로그램을 만든다고 가정해봅시다. 사용자 이름이 올바른지 판단하기 위해,
          <span class="fixed">Data.List</span>의 <span class="fixed">all</span>함
          수를 <span class="fixed">Data.Char</span>의 predicate들과 조합하여 사용할
          수 있을 것입니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; all isAlphaNum "bobby283"
True
ghci&gt; all isAlphaNum "eddy the fish!"
False
</pre>
        <p>멋집니다. <span class="fixed">all</span>은 predicate와 리스트를 취해,
          리스트의 모든 원소들이 predicate를 만족할 때에만 <span class="fixed">True</span>를
          반환한다는 것을 잊지 마시기 바랍니다.</p>
        <p>또한 <span class="fixed">Data.List</span>함수인 <span class="fixed">words</span>를
          모방하기 위해 <span class="fixed">isSpace</span>를 사용할 수 도 있습니다. </p>
        <pre name="code" class="haskell:ghci">ghci&gt; words "hey guys its me"
["hey","guys","its","me"]
ghci&gt; groupBy ((==) `on` isSpace) "hey guys its me"
["hey"," ","guys"," ","its"," ","me"]
ghci&gt;
</pre>
        <p>흠, <span class="fixed">words</span>가 한 일과 비슷하나, 여전히 공백이 남아
          있습니다. 흠, 어떻게 해야 할까요? 제가 아는 방법으로, 한번 이것들을 걸러내 보겠습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"
["hey","guys","its","me"]
</pre>
        <p>예~.</p>
        <p><span class="fixed">Data.Char</span> 또한 <span class="fixed">Ordering</span>과
          비슷한 자료구조를 제공합니다. <span class="fixed">Ordering</span>타입은 <span
            class="fixed">LT</span>, <span class="fixed">EQ</span>, <span
            class="fixed">GT</span>의 값을 가질 수 있습니다. 이는 열거형입니다. 이는 두 원소를
          비교할때 발생할 수 있는 몇몇 가능성에 대해 기술합니다. <span class="fixed">GeneralCategory</span>타
          입 또한 열거형입니다. 문자는 여러가지 분류로 나눌 수 있습니다. 문자가 속한 곳을 알기 위한 함수로는 <span
            class="fixed">generalCategory</span>가 있습니다. 이는&nbsp; <span
            class="fixed">generalCategory :: Char -&gt; GeneralCategory</span>타
          입을 지녔습니다. 31가지로 분류할 수 있으나, 여기선 모두 다루지 않고, 맛만 보도록 하겠습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; generalCategory ' '
Space
ghci&gt; generalCategory 'A'
UppercaseLetter
ghci&gt; generalCategory 'a'
LowercaseLetter
ghci&gt; generalCategory '.'
OtherPunctuation
ghci&gt; generalCategory '9'
DecimalNumber
ghci&gt; map generalCategory " \t\nA9?|"
[Space,Control,Control,UppercaseLetter,DecimalNumber,OtherPunctuation,MathSymbol]
</pre>
        <p><span class="fixed">GeneralCategory</span>타입이 <span class="fixed">Eq</span>타
          입클래스의 일부분임으로, <span class="fixed">generalCategory c == Space</span>와
          유사한 것들을 검사할 수 있습니다.</p>
        <p><span class="label function">toUpper</span>는 문자를 대순자로 변환시킵니다.
          공백이나 숫자 같은 것은 바뀌지 않습니다.</p>
        <p><span class="label function">toLower</span>는 문자를 소문자로 변환시킵니다.</p>
        <p><span class="label function">toTitle</span>는 문자를 title-case로
          변환시킵니다. 대부분의 문자에서, title-case는 대문자와 같습니다.</p>
        <p><span class="label function">digitToInt</span>는 문자를&nbsp; <span
            class="fixed">Int</span>로 변환시킵니다. 성공하기 위해선, 문자가&nbsp; <span
            class="fixed">'0'..'9'</span>, <span class="fixed">'a'..'f'</span>,
          <span class="fixed">'A'..'F'</span> 범위 안에 있어야 합니다.<br>
        </p>
        <pre name="code" class="haskell:ghci">ghci&gt; map digitToInt "34538"
[3,4,5,3,8]
ghci&gt; map digitToInt "FF85AB"
[15,15,8,5,10,11]
</pre>
        <p><span class="label function">intToDigit</span>는&nbsp; <span
            class="fixed">digitToInt</span>에 반대되는 함수입니다. 이는 <span class="fixed">0..15</span>
          범위안의 <span class="fixed">Int</span>를 받아, 소문자로 변환시킵니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; intToDigit 15
'f'
ghci&gt; intToDigit 5
'5'
</pre>
        <p>&nbsp;<span class="label function">ord</span>와 <span class="fixed">chr</span>함
          수는 문자를 대응하는 숫자로, 숫자를 대응하는 문자로 바꾸어줍니다:</p>
        <pre name="code" class="haskell:ghci">ghci&gt; ord 'a'
97
ghci&gt; chr 97
'a'
ghci&gt; map ord "abcdefgh"
[97,98,99,100,101,102,103,104]
</pre>
        <p>두 문자간의 <span class="fixed">ord</span>값의 차이는, 유니코드 표에서의 두
          문자간의 거리와 같습니다.<br>
        </p>
        <p>시저 암호는 알파벳의 각 문자를 지정한 숫자만큼 옮김으로써 메시지를 부호화하는 원시적인 방법입니다. 저희는
          알파벳 문자에 한정짓지 않는 시저 암호를 쉽게 구현할 수 있습니다.</p>
        <pre name="code" class="haskell:hs">encode :: Int -&gt; String -&gt; String
encode shift msg =
    let ords = map ord msg
        shifted = map (+ shift) ords
    in  map chr shifted
</pre>
        <p>여기서, 저희는 우선 문자열을 숫자 리스트로 변환시켰습니다. 그런 다음 숫자 리스트를 문자로 돌려놓기 전에,
          각 숫자마다 옮겨질 양을 더합니다. 여러분이 composition을 좋아한다면, 함수 본체를 <span class="fixed">map




















            (chr . (+ shift) . ord) msg</span>로 작성할 지도 모르겠습니다. 메시지를 부호화
          시켜봅시다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; encode 3 "Heeeeey"
"Khhhhh|"
ghci&gt; encode 4 "Heeeeey"
"Liiiii}"
ghci&gt; encode 1 "abcd"
"bcde"
ghci&gt; encode 5 "Marry Christmas! Ho ho ho!"
"Rfww~%Hmwnxyrfx&amp;%Mt%mt%mt&amp;"
</pre>
        <p>올바르게 부호화가 되었습니다. 메시지를 해석하는 작업은 숫자를 처음 위치한 곳으로 옮기는 것입니다.</p>
        <pre name="code" class="haskell:hs">decode :: Int -&gt; String -&gt; String
decode shift msg = encode (negate shift) msg
</pre>
        <pre name="code" class="haskell:ghci">ghci&gt; encode 3 "Im a little teapot"
"Lp#d#olwwoh#whdsrw"
ghci&gt; decode 3 "Lp#d#olwwoh#whdsrw"
"Im a little teapot"
ghci&gt; decode 5 . encode 5 $ "This is a sentence"
"This is a sentence"
</pre> <a name="data-map"></a>
        <h2>Data.Map</h2>
        <p>연관리스트(Association list)(혹은 사전(dictionaries)이라 불리는)는 순서에 상관없이
          키-값 쌍을 저장하는데 사용되는 리스트입니다. 예를들어,&nbsp;전화번호를 저장하는데 사람의 이름을 키로
          전화번호는 값으로 하는 연관리스트를 사용한다고 합시다. 저장되는 순서에 상관하지 않고, 사람에 대한 정확한
          전화번호를 얻고자 합니다.</p>
        <p>하스켈에서 연관리스트를 나타내는데 있어, 깔끔한 방법으로는 쌍(pair)의 리스트를 갖는 것입니다. 쌍의
          첫번째 구성물은 키이며, 두번째 구성물은 값입니다. 여기 전화번호에 대한 연관리스트 예제가 있습니다:</p>
        <pre name="code" class="haskell:hs">phoneBook = 
    [("betty","555-2938")
    ,("bonnie","452-2928")
    ,("patsy","493-2928")
    ,("lucille","205-2928")
    ,("wendy","939-8282")
    ,("penny","853-2492")
    ]
</pre>
        <p>보기 이상한 들여쓰기를 무시한다면, 이것은 단순히 문자열 쌍의 리스트입니다. 연관리스트를 다룰때 가장 일반적인
          작업은 키로 어떠한 값을 살펴보는 것입니다. 주어진 키로 값을 찾는 함수를 만들어 봅시다.</p>
        <pre name="code" class="haskell:hs">findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; v
findKey key xs = snd . head . filter (\(k,v) -&gt; key == k) $ xs
</pre>
        <p>매우 간단합니다. 함수는 키와 리스트를 취해, 일치하는 키만 남기고 걸러(filter)내어, 처음으로 일치하는
          키-값을 얻어, 값을 반환합니다. 하지만 연관리스트에 존재하지 않는 키를 찾고자 한다면 어떻게 될까요? 흠.
          여기에선, 연관리스트에 키가 없다면, 비어있는 리스트의 head를 얻고자 할 것이며, 런타임 에러를 발생시킬
          것입니다. 하지만, 저희는 프로그램이 쉽게 멈추지 않도록 막아야하므로, <span class="fixed">Maybe</span>
          자료구조를 이용해 봅시다. 키를 찾지 못하면, <span class="fixed">Nothing</span>을
          반환할 것입니다. 키를 찾고 키에 대응하는 값을 something이라 하면, <span class="fixed">Just











            something</span>을 반환할 것입니다.</p>
        <pre name="code" class="haskell:hs">findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v
findKey key [] = Nothing
findKey key ((k,v):xs) = if key == k
                            then Just v
                            else findKey key xs
</pre>
        <p>타입선언을 살펴보시기 바랍니다. 이는 키와 연관리스트를 받아, 아마(maybe) 값을 생산할 것입니다. 얼추
          말이 되는것 같습니다.</p>
        <p>이는 리스트에 대한 재귀 함수 교본입니다. 주변 조건, 리스트를 head와 tail로 나누는것, 재귀호출 모두
          다 있습니다. 이는 전형적인 fold패턴이므로, fold로 구현한걸 살펴봅시다.</p>
        <pre name="code" class="haskell:hs">findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v
findKey key = foldr (\(k,v) acc -&gt; if key == k then Just v else acc) Nothing
</pre>
        <div class="hintbox"><em>Note:</em> 이러한 표준 리스트 재귀 패턴은 보통, 명시적으로
          재귀를 작성하는 것보다, 읽기 쉽고 구분하기 쉬운 fold를 이용하는게 좋습니다. <span class="fixed">foldr</span>을
          호출되는 것을 보면 누구나 fold라는 것을 알지만, 명시적인 재귀는 많은 생각을 요구합니다.</div>
        <pre name="code" class="haskell:ghci">ghci&gt; findKey "penny" phoneBook
Just "853-2492"
ghci&gt; findKey "betty" phoneBook
Just "555-2938"
ghci&gt; findKey "wilma" phoneBook
Nothing
</pre> <img src="http://s3.amazonaws.com/lyah/legomap.png" alt="legomap"
          class="left" height="240" width="214">
        <p>짜잔~! 전화번호를 갖고 있다면, 번호를 얻게 될 것이며(<span class="fixed">Just</span>),









          아니라면 아무것도 얻지 못할 것입니다(<span class="fixed">Nothing</span>).</p>
        <p>저희는 지금&nbsp; <span class="fixed">Data.List</span>의 <span class="fixed">lookup</span>함
          수를 구현하였습니다. 키에 대응되는 값을 찾고자 한다면, 원소 리스트를 찾을 때 까지 뒤질 것입니다. <span
            class="fixed">Data.Map</span>모듈은 (내부적으로 트리로 구현되어있어) 더욱 빠른
          연관리스트와 많은 유틸리티 함수를 제공합니다. 지금부터, 연관리스트 대신, 맵을 가지고 작업하도록 하겠습니다.</p>
        <p><span class="fixed">Data.Map</span>이 제공하는 함수는, <span class="fixed">Prelude</span>와
          <span class="fixed">Data.List</span>에 충돌하므로, qualified import를
          하도록 하겠습니다. </p>
        <pre name="code" class="haskell:hs">import qualified Data.Map as Map
</pre>
        <p>이 import문을 스크립트에 넣은후 GHCI에서 불러옵니다.</p>
        <p>이제, <span class="fixed">Data.Map</span>이 지닌 것이 무엇인지 살펴보도록
          하겠습니다! 여기 함수에 대한 간략한 설명이 있습니다.</p>
        <p><span class="label function">fromList</span>함수는 연관리스트를 받아 동일한
          연관(associations)맵을 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]
fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]
ghci&gt; Map.fromList [(1,2),(3,4),(3,2),(5,5)]
fromList [(1,2),(3,2),(5,5)]
</pre>
        <p>키가 중복된다면, 그 중복된 키를 버립니다. 다음은 <span class="fixed">fromList</span>의
          타입서명입니다.<br>
        </p>
        <pre name="code" class="haskell:hs">Map.fromList :: (Ord k) =&gt; [(k, v)] -&gt; Map.Map k v
</pre>
        <p>이는 <span class="fixed">k</span>와&nbsp; <span class="fixed">v</span>의
          쌍에 대한 리스트를 취하고, <span class="fixed">k</span>타입의 키와&nbsp; <span
            class="fixed">v</span>타입의 값에 대한 맵을 반환한다는 것을 보여주고 있습니다. 키가 연관
          리스트와 평범한 리스트에선 평등하였지만(equatable)(타입은 <span class="fixed">Eq</span>타
          입클래스에 속합니다) , 지금은 순서를(orderable) 지닌다는 것을 주목하시기 바랍니다. 이는 <span
            class="fixed">Data.Map</span>모듈에서 필수적인 제약입니다. 키가 순서를 가질 수
          있으므로, 트리로 나열할 수 있습니다.</p>
        <p><span class="fixed">Ord</span>타입클래스의 키를 갖지 않는한, 키-값
          연관(association)에는 <span class="fixed">Data.Map</span>을 사용하시기
          바랍니다.</p>
        <p><span class="label function">empty</span>는 비어있는 맵을 나타냅니다. 인자를
          받지 않으며, 단지 비어있는 맵을 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.empty
fromList []
</pre>
        <p><span class="label function">insert</span>는 키, 값, 맵을 취해, 기존
          맵에 키와 값이 추가된 새로운 맵을 반환합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.empty
fromList []
ghci&gt; Map.insert 3 100 Map.empty
fromList [(3,100)]
ghci&gt; Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty))
fromList [(3,100),(4,200),(5,600)]
ghci&gt; Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty
fromList [(3,100),(4,200),(5,600)]
</pre>
        <p>비어있는 맵과 <span class="fixed">insert</span>, fold를 이용하여 저희만의 <span
            class="fixed">fromList</span>을 구현할 수 있습니다. 보시죠:</p>
        <pre name="code" class="haskell:ghci">fromList' :: (Ord k) =&gt; [(k,v)] -&gt; Map.Map k v
fromList' = foldr (\(k,v) acc -&gt; Map.insert k v acc) Map.empty
</pre>
        <p>이는 매우 간단한 fold입니다. 비어있는 맵에서 시작하여, 오른쪽에서 키 값 쌍을
          누적기(accumulator)에 삽입하면서 fold합니다.</p>
        <p><span class="label function">null</span>은 맵이 비어있는지 확인합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.null Map.empty
True
ghci&gt; Map.null $ Map.fromList [(2,3),(5,5)]
False
</pre>
        <p><span class="label function">size</span>는 맵의 크기를 알려줍니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.size Map.empty
0
ghci&gt; Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]
5
</pre>
        <p><span class="label function">singleton</span>은 키와 값을 받아 오직
          하나의 사상(寫像, mapping)을 지닌 맵을 만듭니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.singleton 3 9
fromList [(3,9)]
ghci&gt; Map.insert 5 9 $ Map.singleton 3 9
fromList [(3,9),(5,9)]
</pre>
        <p><span class="label function">lookup</span>은 맵에만 동작하며, <span
            class="fixed">Data.List</span>의 <span class="fixed">lookup</span>과
          같습니다. 키에 해당하는 something(무언가)를 찾으면 <span class="fixed">Just
            something</span>을 반환하며, 그렇지 않으면 <span class="fixed">Nothing</span>을
          반환합니다.</p>
        <p><span class="label function">member</span>는 키와 map을 취하여 키가
          map에 있는지를 알려줍니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)]
True
ghci&gt; Map.member 3 $ Map.fromList [(2,5),(4,5)]
False
</pre>
        <p><span class="label function">map</span>과 <span class="label function">filter</span>는
          리스트에 해당하는 것과 동일하게 동작합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.map (*100) $ Map.fromList [(1,1),(2,4),(3,9)]
fromList [(1,100),(2,400),(3,900)]
ghci&gt; Map.filter isUpper $ Map.fromList [(1,'a'),(2,'A'),(3,'b'),(4,'B')]
fromList [(2,'A'),(4,'B')]
</pre>
        <p><span class="label function">toList</span>는 <span class="fixed">fromList</span>의
          반대입니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.toList . Map.insert 9 2 $ Map.singleton 4 3
[(4,3),(9,2)]
</pre>
        <p><span class="label function">keys</span>와 <span class="label function">elems</span>은
          각각 키와 값의 리스트를 반환합니다. <span class="fixed">keys</span>는 <span
            class="fixed">map fst . Map.toList</span>와 동일하며, <span class="fixed">elems</span>은
          <span class="fixed">map snd . Map.toList</span>과 동일합니다.</p>
        <p><span class="label function">fromListWith</span>은 작고 멋진
          함수입니다. 이는 <span class="fixed">fromList</span>처럼 행동하지만, 중복된 키를
          버리지 않고, 주어진 함수를 이용하여 무엇을 할지 결정합니다. 여자들이 여러 번호를 가질 수 있다고 가정한다면,
          다음과 같은 연관 리스트를 얻게 될 것입니다.</p>
        <pre name="code" class="haskell:hs">phoneBook = 
    [("betty","555-2938")
    ,("betty","342-2492")
    ,("bonnie","452-2928")
    ,("patsy","493-2928")
    ,("patsy","943-2929")
    ,("patsy","827-9162")
    ,("lucille","205-2928")
    ,("wendy","939-8282")
    ,("penny","853-2492")
    ,("penny","555-2111")
    ]
</pre>
        <p>여기서 맵에 <span class="fixed">fromList</span>을 사용한다면, 몇몇 번호를
          잃게될 것입니다! 따라서 다음과 같이 해야합니다:</p>
        <pre name="code" class="haskell:hs">phoneBookToMap :: (Ord k) =&gt; [(k, String)] -&gt; Map.Map k String
phoneBookToMap xs = Map.fromListWith (\number1 number2 -&gt; number1 ++ ", " ++ number2) xs
</pre>
        <pre name="code" class="haskell:hs">ghci&gt; Map.lookup "patsy" $ phoneBookToMap phoneBook
"827-9162, 943-2929, 493-2928"
ghci&gt; Map.lookup "wendy" $ phoneBookToMap phoneBook
"939-8282"
ghci&gt; Map.lookup "betty" $ phoneBookToMap phoneBook
"342-2492, 555-2938"
</pre>
        <p>중복된 키를 발견하면, 그 키에 해당하는 값들을 합치기 위해 저희가 넘긴 함수가 사용됩니다. 또한 연관리스트에
          있는 모든 값을 싱글톤 리스트로 만든다음, <span class="fixed">++</span>를 이용하여
          수를 합칠 수 있습니다.</p>
        <pre name="code" class="haskell:hs">phoneBookToMap :: (Ord k) =&gt; [(k, a)] -&gt; Map.Map k [a]
phoneBookToMap xs = Map.fromListWith (++) $ map (\(k,v) -&gt; (k,[v])) xs
</pre>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.lookup "patsy" $ phoneBookToMap phoneBook
["827-9162","943-2929","493-2928"]
</pre>
        <p>매우 깔끔합니다! 또 다른 예로, 수의 연관 리스트에서 맵을 만들시, 중복된 키를 찾는다면 키에 해당하는 값중
          가장 큰 값을 유지하는 것이 있습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,100),(3,29),(4,22)]
</pre>
        <p>혹은 동일한 키에 해당하는 값들을 서로 더할 수 도 있습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,108),(3,62),(4,37)]
</pre>
        <p><span class="fixed">fromListWith</span>가 <span class="fixed">fromList</span>를
          위한 것처럼 <span class="label function">insertWith</span>는 <span
            class="fixed">insert</span>를 위한 것입니다. 이는 키-값 쌍을 맵에 삽입하며, 맵이
          동일한 키를 포함하고 있다면, 넘겨진 함수를 이용하여 무엇을 행할지 결정합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)]
fromList [(3,104),(5,103),(6,339)]
</pre>
        <p><span class="fixed">Data.Map</span>에는 많은 함수들이 있습니다. 함수 전체 목록은
          <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3Aassocs">이
            문서</a>에서 확인하실 수 있습니다.<br>
        </p>
        <a name="data-set"></a>
        <h2>Data.Set</h2>
        <img src="http://s3.amazonaws.com/lyah/legosets.png" alt="legosets"
          class="right" height="236" width="150">
        <p><span class="fixed">Data.Set</span>모듈은 집합에 관한걸 제공해 줍니다. 수학에서의
          집합과 같습니다. 집합은 리스트와 맵의 변종입니다. 집합의 모든 원소들은 고유합니다. 그리고 <span class="fixed">Data.Map</span>의
          맵처럼 내부적으로 트리로 구현되었기에, 순서가 있습니다. 관계를 확인하는 것, 삽입, 삭제 등등은 리스트에
          행한것 보다 빠릅니다. 집합을 다루는 가장 흔한 작업으로는, 삽입, 관계 확인, 집합을 리스트로 변환하기가
          있습니다.</p>
        <p><span class="fixed">Data.Set</span>에 이름이 <span class="fixed">Prelude</span>과
          <span class="fixed">Data.List</span>에 있는 이름과 많이 충돌하기에,
          qualified import를 해야 합니다.</p>
        <p> 스크립트에 다음 import문을 넣습니다:</p>
        <pre name="code" class="haskell:ghci">import qualified Data.Set as Set
</pre>
        <p>그런 다음, GHCI에서 스크립트를 불러옵니다.</p>
        <p>2개의 문장이 있다고 가정해 봅시다. 이 둘 간에 공통적으로 사용되는 문자를 찾고자 합니다.</p>
        <pre name="code" class="haskell:ghci">text1 = "I just had an anime dream. Anime... Reality... Are they so different?"
text2 = "The old man left his garbage can out and now his trash is all over my lawn!"
</pre>
        <p> <span class="label function">fromList</span>함수는 저희가 예상했던
          것처럼 동작합니다. 리스트를 받아 이를 집합으로 변환시킵니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let set1 = Set.fromList text1
ghci&gt; let set2 = Set.fromList text2
ghci&gt; set1
fromList " .?AIRadefhijlmnorstuy"
ghci&gt; set2
fromList " !Tabcdefghilmnorstuvwy"
</pre>
        <p>보시다시피, 각 항목들은 순서를 지니며, 고유합니다. 둘 간에 어떠한 원소들이 공유되고 있는지 <span class="label function">intersection</span>함
          수를 이용하여 확인해 봅시다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.intersection set1 set2
fromList " adefhilmnorstuy"
</pre>
        <p><span class="label function">difference</span>함수를 이용하여 첫번째
          집합에는 있지만, 두번째 집합에는 없는 문자를 확인할 수 있습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.difference set1 set2
fromList ".?AIRj"
ghci&gt; Set.difference set2 set1
fromList "!Tbcgvw"
</pre>
        <p>혹은 <span class="label function">union</span>을 이용하여 두 문장간에
          고유한 문자를 모두 확인할 수 있습니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.union set1 set2
fromList " !.?AIRTabcdefghijlmnorstuvwy"
</pre>
        <p><span class="label function">null</span>, <span class="label function">size</span>,
          <span class="label function">member</span>, <span class="label function">empty</span>,
          <span class="label function">singleton</span>, <span class="label function">insert</span>,
          <span class="label function">delete</span> 함수 모두 저희가 예상한 바처럼
          동작합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.null Set.empty
True
ghci&gt; Set.null $ Set.fromList [3,4,5,5,4,3]
False
ghci&gt; Set.size $ Set.fromList [3,4,5,3,4,5]
3
ghci&gt; Set.singleton 9
fromList [9]
ghci&gt; Set.insert 4 $ Set.fromList [9,3,8,1]
fromList [1,3,4,8,9]
ghci&gt; Set.insert 8 $ Set.fromList [5..10]
fromList [5,6,7,8,9,10]
ghci&gt; Set.delete 4 $ Set.fromList [3,4,5,4,3,4,5]
fromList [3,5]
</pre>
        <p>또한 부분집합과 진부분집합을 확인할 수 있습니다. 집합B가 집합A가 지닌 모든 원소를 지녔다면, 집합 A는
          집합B의 부분집합(subset)입니다. B가 A가 지닌 모든 원소를 포함하면서, 보다 더 많은 원소를 가졌다면,
          집합 A는 집합 B의 진부분집합(proper subset)입니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.fromList [2,3,4] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
True
ghci&gt; Set.fromList [1,2,3,4,5] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
True
ghci&gt; Set.fromList [1,2,3,4,5] `Set.isProperSubsetOf` Set.fromList [1,2,3,4,5]
False
ghci&gt; Set.fromList [2,3,4,8] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]
False
</pre>
        <p>또한 집합에 <span class="label function">map</span>을 하여 <span class="label function">filter</span>를
          적용할 수 도 있습니다.<br>
        </p>
        <pre name="code" class="haskell:ghci">ghci&gt; Set.filter odd $ Set.fromList [3,4,5,6,7,2,3,4]
fromList [3,5,7]
ghci&gt; Set.map (+1) $ Set.fromList [3,4,5,6,7,2,3,4]
fromList [3,4,5,6,7,8]
</pre>
        <p>집합은 보통, <span class="fixed">fromList</span>로 집합을 만들고,
          이를&nbsp; <span class="label function">toList</span>로 다시 리스트로
          돌려놓음으로써, 리스트에서 중복된 것들을 제거하는데 사용됩니다. <span class="fixed">Data.List</span>의
          함수 <span class="fixed">nub</span> 역시 중복된 것을 제거하지만, 큰 리스트에서
          중복된 것을 제거하는 작업은 <span class="fixed">nub</span>을 이용한 것보다, 이를
          집합으로 집어놓고, 다시 리스트로 변환시키는 것이 더 빠릅니다. 그리고 <span class="fixed">nub</span>을
          사용하려면 리스트의 원소의 타입이 <span class="fixed">Eq</span>타입클래스의 일부분이면
          되는 반면, 이를 집합으로 집어넣고자 한다면, 리스트의 타입은 <span class="fixed">Ord</span>에
          속해야 합니다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; let setNub xs = Set.toList $ Set.fromList xs
ghci&gt; setNub "HEY WHATS CRACKALACKIN"
" ACEHIKLNRSTWY"
ghci&gt; nub "HEY WHATS CRACKALACKIN"
"HEY WATSCRKLIN"
</pre>
        <p><span class="fixed">setNub</span>은 보통 <span class="fixed">nub</span>보
          다 빠르지만, 보시다시피 <span class="fixed">nub</span>는 리스트 원소의 순서를
          유지하는 반면 <span class="fixed">setNub</span>은 그렇지 않습니다.</p>
        <a name="making-our-own-modules"></a>
        <h2>나만의 모듈 만들기</h2>
        <img src="http://s3.amazonaws.com/lyah/making_modules.png" alt="making modules"
          class="right" height="224" width="345">
        <p>지금까지 저희는 멋진 모듈들을 살펴보았습니다. 하지만 어떻게 저희만의 모듈을 만들까요? 대부분의 프로그래밍
          언어에서 코드를 여러 파일로 나눈 것처럼 하스켈도 그러합니다. 프로그램을 만들 시, 유사한 목적을 지니는 함수와
          타입을 하나의 모듈로 모아 넣는 것이 좋은 습관입니다. 이러한 방법으로, 다른 프로그램에서 모듈을
          import함으로써 쉽게 함수들을 재사용할 수 있습니다.</p>
        <p>모듈이 기하학적 물체의 면적과 부피를 계산하는 함수를 제공하도록 만들어 봄으로써, 어떻게 모듈을 만드는지 살펴
          봅시다. 우선 <span class="fixed">Geometry.hs</span>파일을 만듭니다.</p>
        <p>모듈은 함수를 제공한다고 하였습니다. 이는 모듈을 import하면, 모듈이 제공하는 함수를 사용할 수 있다는
          것을 의미합니다. 이는 내무적으로 호출할 함수들을 정의할수 있으며, 사용자는 export된 것만 사용할 수
          있습니다.<br>
        </p>
        <p>모듈의 시작부분에는, 모듈 이름을 명시합니다. <span class="fixed">Geometry.hs</span>파
          일을 가졌다면, 모듈 이름은 <span class="fixed">Geometry</span>여야 합니다. 그런
          다음, export할 함수들을 명시하고 나서, 함수를 작성할 수 있습니다. 다음을 가지고 작업을 시작해 봅시다.</p>
        <pre name="code" class="haskell:ghci">module Geometry
( sphereVolume
, sphereArea
, cubeVolume
, cubeArea
, cuboidArea
, cuboidVolume
) where
</pre>
        <p>보시다시피, 구(sphere), 정육면체(cube), 직육면체(cuboid)의 부피와 면적을 구할 것입니다.
          이제 함수를 정의해 봅시다:</p>
        <pre name="code" class="haskell:ghci">module Geometry
( sphereVolume
, sphereArea
, cubeVolume
, cubeArea
, cuboidArea
, cuboidVolume
) where

sphereVolume :: Float -&gt; Float
sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)

sphereArea :: Float -&gt; Float
sphereArea radius = 4 * pi * (radius ^ 2)

cubeVolume :: Float -&gt; Float
cubeVolume side = cuboidVolume side side side

cubeArea :: Float -&gt; Float
cubeArea side = cuboidArea side side side

cuboidVolume :: Float -&gt; Float -&gt; Float -&gt; Float
cuboidVolume a b c = rectangleArea a b * c

cuboidArea :: Float -&gt; Float -&gt; Float -&gt; Float
cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

rectangleArea :: Float -&gt; Float -&gt; Float
rectangleArea a b = a * b
</pre>
        <p>아름다운 표준 기하학이 여기 있습니다.&nbsp;주목할것이 몇가지 있습니다. 정육면체(cube)는
          직육면체(cuboid)의 특수한 경우이기에, 모든 변의 길이가 동일한 길이를 가진 직육면체로 취급함으로써 이의
          넓이와 높이를 정의하였습니다. 저희는 또한 변의 길이로 사각형의 넓이를 계산하는 <span class="fixed">rectangleArea</span>라
          불리는 도움 함수를 정의하였습니다. 이는 다른 것보다 사소한 것으로, 단순한 곱셈입니다. 이를 모듈안에서
          (다시말해 <span class="fixed">cuboidArea</span>와 <span class="fixed">cuboidVolume</span>에
          서)이용하지만 , export 하지 않는 것을 주목하시기 바랍니다! 3차원 객체를 다루는 함수만 나타내기 원하기
          때문에, <span class="fixed">rectangleArea</span>을 이용하긴 하지만
          export하진 않았습니다.</p>
        <p>모듈을 만들 때에는 보통 모듈과 중계자 역활을 하는 함수만을 export하기에 구현물은 감추어집니다. 누군가가
          <span class="fixed">Geometry</span>모듈을 이용한다면, export하지 않은 함수에는
          신경쓰지 않을 것입니다. export하지 않았으므로, 새로운 버전에서 이러한 함수들을 완전히 바꿀지 삭제할지를
          정할 수 있으며 (<span class="fixed">rectangleArea</span>를 지워 <span
            class="fixed">*</span>을 사용할 수 도 있습니다) , 어느 누구도 신경쓰지 않을 것입니다.</p>
        <p>모듈을 사용하려면, 다음과 같이 해야합니다:</p>
        <pre name="code" class="haskell:ghci">import Geometry
</pre>
        <p><span class="fixed">Geometry.hs</span>는 import하는 프로그램과 동일한
          폴더에 있어야 합니다.</p>
        <p> 또한 모듈은 상속 구조를 지닙니다. 각 모듈은 수많은 하위 모듈을 가질 수 있으며, 하위 모듈은 또 다른
          하위모듈을 가질 수 있습니다. 이 함수들을 각 객체의 타입마다 나누어, <span class="fixed">Geometry</span>모
          듈이 3개의 하위 모듈을 지니도록 만들어 봅시다.</p>
        <p>우선, 저희는 <span class="fixed">Geometry</span>폴더를 만들 것입니다. 대문자
          G를 주의하시기 바랍니다. 이 속에 세개의 파일을 넣을 것입니다: <span class="fixed">Sphere.hs</span>,
          <span class="fixed">Cuboid.hs</span>, <span class="fixed">Cube.hs</span>.
          여기 파일이 담아야 할 것이 나와 있습니다:</p>
        <p><span class="fixed">Sphere.hs</span></p>
        <pre name="code" class="haskell:ghci">module Geometry.Sphere
( volume
, area
) where

volume :: Float -&gt; Float
volume radius = (4.0 / 3.0) * pi * (radius ^ 3)

area :: Float -&gt; Float
area radius = 4 * pi * (radius ^ 2)
</pre>
        <p><span class="fixed">Cuboid.hs</span></p>
        <pre name="code" class="haskell:ghci">module Geometry.Cuboid
( volume
, area
) where

volume :: Float -&gt; Float -&gt; Float -&gt; Float
volume a b c = rectangleArea a b * c

area :: Float -&gt; Float -&gt; Float -&gt; Float
area a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

rectangleArea :: Float -&gt; Float -&gt; Float
rectangleArea a b = a * b
</pre>
        <p><span class="fixed">Cube.hs</span></p>
        <pre name="code" class="haskell:ghci">module Geometry.Cube
( volume
, area
) where

import qualified Geometry.Cuboid as Cuboid

volume :: Float -&gt; Float
volume side = Cuboid.volume side side side

area :: Float -&gt; Float
area side = Cuboid.area side side side
</pre>
        <p>좋습니다! 첫번째는 <span class="fixed">Geometry.Sphere</span>입니다. 이를
          <span class="fixed">Geometry</span>폴더에 이를 넣고, 모듈의 이름을 <span class="fixed">Geometry.Sphere</span>라
          정의한 것에 주목하시기 바랍니다. cuboid도 동일하게 처리합니다. 또한 3개의 하위 모듈에 동일한 이름의
          함수를 정의할 것을 주목하시기 바랍니다. 분리된 모듈이기에 이렇게 할 수 있습니다. <span class="fixed">Geometry.Cube</span>와
          동일한 이름의 함수를 export하기에, <span class="fixed">Geometry.Cube</span>에
          서 <span class="fixed">Geometry.Cuboid</span>의 함수를 사용하기 위해,
          곧바로 <span class="fixed">import Geometry.Cuboid</span>라 할 수
          없습니다. 이것이 바로 qualified import를 해야하는 이유이며, 다른 것들도 마찬가지 입니다.</p>
        <p>그러먼 이제, 파일이 <span class="fixed">Geometry</span>폴더와 동일한 레벨에
          있다면, 다음과 같이 할 수 있습니다:</p>
        <pre name="code" class="haskell:ghci">import Geometry.Sphere
</pre>
        <p>그리고 나면 <span class="fixed">area</span>와 <span class="fixed">volume</span>을
          호출하여, 구의 면적과 부피를 알 수 있습니다. 그리고 2개 이상의 모듈을 사용하려면, 동일한 이름의 함수를
          export하기 qualified import를 해야합니다. 따라서 다음과 같이 해야합니다:</p>
        <pre name="code" class="haskell:ghci">import qualified Geometry.Sphere as Sphere
import qualified Geometry.Cuboid as Cuboid
import qualified Geometry.Cube as Cube
</pre>
        <p>그런 다음 <span class="fixed">Sphere.area</span>, <span class="fixed">Sphere.volume</span>,
          <span class="fixed">Cuboid.area</span> 등등으로 호출하고 그에 해당하는 면적과
          부피를 계산 할 수 있습니다.</p>
        <p>다음으로 저희는 어떤 함수가 공익성을 제공하는지, 모듈안에 집어넣을 수 있는지 확인하기 위해, 많은 함수를
          지닌 매우 큰 파일을 작성할 것입니다. 앞으로 여러분들은 모듈을 import하여 동일한 기능을 요구하는
          프로그램을 작성할 수 있을 것입니다.</p>
        <div class="footdiv">
          <ul>
            <li style="text-align: left;"> <a href="higher-order-functions"
                class="prevlink">Higher Order Functions</a> </li>
            <li style="text-align: center;"> <a href="chapters">목 차</a><br>
            </li>
            <li style="text-align: right;"> <a href="making-our-own-types-and-typeclasses"
                class="nxtlink">Making Our Own Types and Typeclasses</a>
            </li>
          </ul>
        </div>
      </div>
      <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
      <script type="text/javascript" src="shBrushHaskell.js"></script>
      <script type="text/javascript" src="shBrushPlain.js"></script>
      <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script> </div>
    <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script> </body>
</html>

2 타입을 믿으십시요
[pic]

 하스켈의 강력함 중 하나는 강력한 타입시스템입니다.
 하스켈에선, 모든 표현식의 타입은 컴파일 타임에 결정되며, 이는 안전한 코드로 이끌어 줍니다. 부울대수를 숫자로 나누려는 프로그램을 작성한다면, 컴파일이 되지 않을 것입니다. 이는 좋은 방법인데, 나중에 프로그램이 망처지는 것보다 컴파일 타임에 이러한 종류의 에러를 잡는 것이 낫기때문입니다. 하스켈에서 모든것은 타입을 지녔으므로, 컴파일 하기전에 컴파일러는 프로그램에 대해 상당수를 판단할 수 있습니다.
 Java와 Pascal과는 달리, 하스켈은 타입추론(type inference)을 지녔습니다. 예를들어, 숫자를 작성하였다면 하스켈에게 숫자라고 말해줄 필요가 없습니다. 
 지금까지, 하스켈의 타입에 관해 몇몇 기본적이며 매우 피상적인것을 다루었으며, 타입 시스템을 이해하는 것은 하스켈을 배우는 단계에서 가장 중요합니다.


명시적 타입 선언
 몇몇 표현식의 타입을 실험해 보기 위해 GHCi를 이용할 수 있습니다. :t 명령어와 유효한 표현식을 이용하여 타입을 알 수 있습니다. 한번 돌려봅니다:
[console]
[pic]

 여기서 ::연산자는 "타입을 지녔다"라고 읽습니다. 명시적 타입은 항상 첫번째 문자를 대문자로 표시합니다. 'a'는 문자를 대표하는 Char 타입을 지녔습니다. True는 Bool 혹은 Boolean 타입입니다. 문자열 "HELLO!"의 타입은 [Char]입니다. 사각 괄호는 리스트늘 나타내므로, 문자 리스트라고 읽을 수 있습니다. 리스트와는 달리, 각 튜플의 길이는 자신만의 타입을 지녔습니다. 따라서, 튜플 (True, 'a')는 타입 (Bool, Char)를, ('a','b','c')는 타입 (Char, Char, Char)를 지녔습니다.  4 == 5는 항상 False를 반환하므로, 이의 타입은 Bool입니다.
 함수 또한 타입을 지닙니다. 함수를 작성할 때, 명시적 타입 선언을 할 수 있습니다. (매우 짧은 함수를 작성할 때를 제외하면) 이는 일반적으로 좋은 행동이라 여겨집니다. 여기에선, 모든 함수에 타입 선언을 할것입니다.
 1장에서 작성한 문자열에서 소문자로된 것을 걸러내는 list comprehension가 기억나십니까? 여기 타입 선언을 어떻게 하는지 나와있습니다:
[code]

 removeNonUppercase함수는 문자열을 인자로 받아 결과로 리턴하는 것을 의미하는 [Char] -> [Char]타입을 지녔습니다.
 그러나 여러 인자를 취하는 함수의 타입을 명시하려면 어떻게 할까요? 여기 정수 3개를 받아 이를 더하는 간단한 함수가 있습니다:
[code]

 인자와 반환 타입은 ->로 분리되며, 반환 타입은 항상 선언의 마지막에 오게 됩니다. (5장에서, 이것들을 다른 구분자 대신, 왜 다 ->로 분리하는지를 살펴 볼 것입니다.)
 함수에 타입선언을 하고자 하지만, 함수가 무엇을 하는지 확신할 수 없다면, 타입선언이 없는 함수를 작성한 다음 :t로 이를 확인할 수 있습니다. 함수는 표현식이므로, :t는 이번 단란의 시작에서 여러분이 보았던 것과 동일한 방식으로 동작합니다.


일반 하스켈 타입
 숫자, 문자, 부울값과 같은 것들을 표현하는데 사용되는 일반적인 하스켈 타입을 살펴봅시다. 여기 간략하게 나와 있습니다:
? Int는 정수를 대표홉니다. 숫자 전반에 걸처 사용됩니다. 7은 Int가 될수 있지만, 7.2는 아닙니다. Int는 제한되어 있으며, 이는 최소값과 최대값을 가졌다는 것을 의미합니다.

NOTE 저희는 여러분의 컴퓨터의 word의 크기에 의해 Int의 범위가 설정되는 GHC 컴파일러를 이용할 것입니다. 따라서, 64비트 CPU를 가졌다면, 최소 Int는-2^63, 최대는 2^63이 될 것입니다.

? Integer 또한 정수를 저장하는데 이용하며 제한되지는 않으므로, 매우 큰 숫자를 표현하는데 사용할 수 있습니다. 그러나, Int가 더욱 효율적입니다. 예로, 다음 함수를 파일에 넣어봅시다:
[code]

 그런 다음 이를 GHCi에서 :l로 로드한후 테스트 해봅시다:
[console]

? Float은 단일 정밀도를 지닌 부동 소숫점 실수입니다. 작업하고 있는 파일에 다음 함수를 넣읍니다:
[code]

 다음 이를 불러와서 테스트 합시다:
[code]

? Double은 2배 정밀도를 지닌 부동 소숫점 실수 입니다. 2배 정밀도 숫자는 숫자를 표시하는것 보다 2배나 많은 비트를 사용합니다. 추가 비트들은 많은 메모리를 끌이는 비용으로 정밀도를 높입니다. 여기 저희 파일에 추가시킬 또 다른 함수가 있습니다:

[code]
 이를 불러오고 테스트 해봅시다. 특히 circumference와 circumference'간의 정밀도 차이에 주의를 기울이시기 바랍니다.
[console]

? Bool은 부울타입입니다. 이는 2개의 값만을 가집니다: True와 False.

? Char는 유니코드 문자를 표현합니다. 이는 따옴표로 나타냅니다. 문자 리스트는 문자열입니다.

? 튜플은 타입이지만, 정의는 길이뿐만 아니라 구성물의 타입에도 영향을 받습니다. 따라서, 이론적으론 튜플의 타입은 무수히 많습니다. (사실, 튜플은 최대 (여러분이 필요하게 될 것보다 훨씬 많은)62개의 원소를 지닐 수 있습니다.) 비어있는 튜플 ()은 a만을 값으로 갖는 a 타입입니다: ().


타입 변수
 몇몇 함수들은 다양한 타입에 동작할 수 있어야 합니다. 예를들어, head 함수는 리스트를 취해 리스트의 머릿 원소를 반환합니다. 리스트가 숫자, 문자, 혹은 더 많은 리스트를 포함하는지는 문제가 되지 않습니다! 함수는 리스트가 어떠한 것을 포함하더라도 동작할 것입니다.
 head함수의 타입은 무엇일까요? :t 함수로 확인해 봅시다:
[console]

 이 a는 무엇일까요? 타입 이름이 대문자로 시작한다는 것을 고려한다면, 이는 타입이 아닙니다. 이는 실제로 어떠한 타입이 될 수 있는 타입 변수의 예제입니다.
[pic]

 타입 변수는 함수가 다양한 타입에도 안전하게 동작하게 합니다. 이는 다른 프로그래밍 언어에서의 제네릭(generic)과 무척 닮았습니다. 하스켈 버전은 더욱 강력하기에, 일반적인 함수를 쉽게 작성할 수 있게 만들어 줍니다.
 타입 변수를 이용하는 함수를 다형(polymorphic)함수라 부릅니다. head의 타입 변수는 어떤 타입의 리스트를 받아 그 타입의 한 원소를 반환한다는 것을 나타냅니다.

NOTE 타입 변수가 하나의 문자보다 더 긴 이름을 지닐 수 있지만, a, b, c,d 등등 과 같은 이름을 붙이겠습니다.

 pair에서 첫번째 항목을 반환하는 fst를 기억하십니까? 이의 타입을 실험해 봅시다:
[console]

 fst가 튜플을 받아 첫번째 항목과 동일한 타입의 원소를 반환하는 것을 확인 할 수 있습니다. 이것이 2개의 타입을 지닌 pair에 fst를 사용할 수 있는지에 대한 이유입니다. a와 b가 다른 타입 변수라도, 다른 타입이 될 필요는 없다는 것을 주목하시기 바랍니다. 이는 바로 첫번째 항목의 타입과 반환되 값의 타입이 동일할 것이라는 것을 의미합니다.


타입 클래스 101
[pic]
 타입 클래스는 몇몇 행동을 정의하는 인터페이스입니다. 타입이 타입 클래스의 인스턴스이면, 타입은 그 타입 클래스가 기술하는 행동을 지원하며 구현합니다.
 더 자세하게는, 타입 클래스는 함수의 분기를 명시하며, 타입을 타입 클래스의 인스턴스로 만들시 타입에 대해 함수가 의미하는게 무엇인지를 정의해야 합니다.
 같음을 정의하는 타입 클래스는 훌륭한 예제입니다. == 연산자를 이용하여 많은 타입의 값의 같음을 비교할 수 있습니다. 이 연산자의 타입 서명을 확인해 봅시다:
[console]

 연산자 (==)가 실제론 함수라는 것을 주목하시기 바랍니다. +, *, -, /, 그리고 많은 다른 연산자들도 그러합니다. 만약 함수가 특별한 문자로만 구성되었다면, 기본적으로 중위함수로 여겨집니다. 타입을 실험하기 위해 이를 다른 함수로 넘겨주길 원하거나 전위함수로 호출하려면, 이전 예제에서 나온 것 처럼 괄호로 둘러싸야 합니다.
 이 예제는 새로운 무언가를 보여줍니다: => 심볼. 이 심볼 이전의 것들을 클래스 제약(class constraint)이라 부릅니다. 이 타입 이와 같이 선언을 읽을 수 있습니다: 같음 함수는 동일한 타입의 두 값을 취해 Bool을 반환한다. 두 값의 타입은 Eq클래스의 인스턴스여야 합니다.
 Eq 타입 클래스는 같음을 확인할 인터페이스를 제공합니다. 특정 타입의 두 항목이 같음을 비교할 수 있으면, 그 타입은 Eq 타입 클래스의 인스턴스가 될 수 있습니다. (input/output 타입과 함수를 제외하면) 표준 하스켈의 모든 타입들은 Eq의 인스턴스입니다.

NOTE 타입 클래스는 객체 지향 프로그래밍 언어에서의 클래스와 같은것이 아니라는 것을 깨닫는 것이 중요합니다.

 같음, 순서, 문자열로 출력된 것 등등을 쉽게 비교할 수 있는 하스켈 타입 클래스를 살펴봅시다


Eq 타입 클래스
 전에 다루었듯이, Eq는 같음을 확인하기 위한 타입에 사용됩니다. 이 인스턴스의 구현체인 함수는 == 와 /= 입니다. 이는 함수에 타입 변수에 관한 Eq 클래스제약이 있다면, 내부에서 ==나 /=을 이용한다는 것을 의미합니다. 타입이 함수를 충족(implement)시킨다는 것은, 특정 타입에 대해 함수가 무엇을 하며 언제 사용되는지를 정의하는 것을 의미합니다. 여기 Eq의 다양한 인스턴스에 대해 이러한 연산을 수행하는 몇몇 예제가 있습니다:
[console]


Ord 타입 클래스
 Ord는 어떠한 순서로 놓여질수 있는 타입의 타입 클래스 입니다. 예를들기 위해, > 연산자의 타입을 살펴봅시다:
[console]

 >의 타입은 ==의 타입과 유사합니다. 두 항목을 인자로 받고 두개가 서로 같은지 혹은 아닌지를 말해주는 Bool을 반환합니다.
 지금까지 저희가 다룬 타입들은 함수를 제외하여 모두 Ord의 인스턴스입니다. Ord는 >, <, >=, <=와 같은 표준 비교 함수를 모두 포괄합니다.
 비교 함수는 Ord 인스턴스인 두 값을 받아 Ordering을 반환합니다. Ordering은 각각 보다 큰(greater than), 보다 작은(lesser than), 같음(equal)을 나타내는 GT, LT, EQ가 될 수 있는 타입입니다
[console]


Show 타입 클래스
 Show 타입 클래스의 인스턴스인, 모든 타입의 값들은 문자열로 표시할 수 있습니다. (함수를 제외하면) 지금까지 저희가 다룬 모든 타입들은 Show의 인스턴스입니다 이 타입 클래스의 인스턴스에 주로 사용되는 함수는 주어진 값을 문자열로 출력하는 show입니다:
[console]


Read 타입 클래스
 Read는 Show와 반대되는 타입 클래스라 여길 수 있습니다. 지금까지 다룬 모든 타입들은 이 타입 클래스의 인스턴스 입니다. read 함수는 문자열을 받아 Read의 인스턴스인 타입 값을 반환합니다:
[console]

 머 괜찮게 나왔습니다. 그러면 read "4"라 입력하면 어떻게 될까요?
[console]

 GHCi는 저희가 반환받고자 하는것을 모른다고 할 것입니다. GHCi가 저희가 원하는 결과를 추론하는 read를 주목하시기 바랍니다. 예를들어, 저희가 부울대수를 이용하였다면, Bool을 반환해야 한다는 것을 알 것입니다. 그러나 지금은 Read 클래스의 어떠한 타입을 원하지만, 그 어떠한 것이 무엇인지를 모릅니다. read의 타입 서명을 살펴봅시다:
[console]


NOTE String(문자열)은 [Char]의 또 다른 이름입니다. String과 [Char]는 교대하여 사용할 수 있지만, 저희는 쓰기도 편하고 가독성도 좋은 String을 고수하도록 하겠습니다.

 read함수가 Read 인스턴스의 타입 값을 반환하는 것을 확인할 수 있지만, 만약 저희가 다른 방법을 사용한다면, 어떤 타입인지 알 수 없습니다. 이 문제를 풀기 위해, 타입 어노테이션(type annotations)을 이용할 수 있습니다.
 타입 어노테이션은 표현식이 나타내는 타입이 무엇인지 하스켈에게 명시적으로 알려주는 방법입니다. 표현식 끝에 ::를 추가하고 타입을 명시함으로써 이를 행할 수 있습니다.
[console]

 컴파일러는 표현식의 타입 대부분을 스스로 추론할 수 있습니다. 그러나, 때때로 컴파일러는 read "5"와 같은 표현식의 반환값의 타입이 Int 인지 Float인지를 알지 못합니다. 타입을 확인하기 위해, 하스켈은 실제로 read "5"를 평가해야만 합니다. 그러나 하스켈은 정적 타입 언어이기에, 코드가 컴파일 되기 전에 (혹은 GHCi인 경우, 평가하여)모든 타입을 알아야만 합니다. 따라서 저희는 "이 표현식은 이러한 타입을 갖는다고!"라고 하스켈에게 알려줘야 합니다
 저희는 하스켈에게 read가 반환하는 타입을 밝히는데 필요한 최소한의 정보만을 줄 수 있습니다. 예를들어, 저희가 read를 이용하여 결과를 리스트에 넣으려 한다면, 하스켈은 저희가 원하는 타입이 무엇인지 밝혀내기 위해 리스트의 다른 원소들을 살펴봄으로써 리스트를 이용할 수 있습니다:
[console]

 "True"를 Bool 값의 리스트의 원소로 읽으므로, 하스켈은 read "True"의 타입 또한 Bool이라는 것을 알아봅니다


Enum 타입 클래스
 Enum 인스턴스는 연속적인 순서를 지닌 타입입니다 - 열거할 수 있습니다. Enum 타입 클래스의 주요한 이점은 리스트 범위에 이 값들을 사용할 수 있다는 것입니다. 또한 이는 succ와 pred 함수로 얻을 수 있는 계승자(successor)와 선구자(predecessor)를 지닙니다. 이 타입클래스의 예로는 (), Bool, Char, Ordering, Int, Integer, Float, Double이 있습니다.
[console]


Bounded 타입 클래스
 Bounded 타입 클래스의 인스턴스는 minBound와 maxBound 함수를 이용하여 확인할 수 있는 상한와 하한을 지닙니다:
[console]

 (Bounded a) => a란 타입을 갖는 minBound와 maxBound함수는 흥미롭습니다. 이러한 경우, 이는 다형 상수(polymorphic constants)입니다.
 구성물들이 모두 Bounded 인스턴스인 튜플 또한 그 스스로 Bounded 인스턴스로 여겨진다는 것을 주목하시기 바랍니다:
[console]


Num 타입 클래스
 Num은 숫자 타입 클래스 입니다. 이의 인스턴스는 숫자처럼 행동 합니다. 숫자 타입을 실험해봅시다:
[console]

 모든 숫자는 또한 다형 상수로 여겨집니다. 이는 Num 타입 클래스의 인스턴스의 어떠한 타입(Int, Integer, Float, Double)처럼 행동할 수 있습니다:
[console]

 예를들어, * 연산자의 타입을 실험해 봅시다:
[console]

 이는 *는 두 수를 받고 동일한 타입의 숫자를 반환하는 것을 보여줍니다. 이 타입 제약으로 인해, (5 :: Int) * (6 :: Integer)는 타입 에러를 내지만, 5 * (6 :: Integer)는 제대로 동작 할 것입니다. 5는 Integer나 Int처럼 행동할 수 있지만, 동시에 할 수는 없습니다.
 Num의 인스턴스가 되기 위해선, 먼저 Show와 Eq의 타입이 되야 합니다.


Floating 타입 클래스
 Floating 타입 클래스는 부동 소수를 저장하는데 사용되는 Float과 Double 타입을 포함하고 있습니다
 Floating 타입 클래스의 인스턴스를 받고 반환하는 함수들은 중요한 계산을 수행하기 위해 결과를 부동 소수로 표현할 수 있어야 합니다. sin, cos, sqrt를 예로 들 수 있겠습니다. 


Integral 타입 클래스
 또 다른 숫자 타입 클래스는 Integral입니다. Num가 실수를 포함하여 모든 숫자를 포괄하는 반면, Integral 클래스는 오직 (모든)정수만을 포함합니다. 이 타입 클래스는 Int와 Integer 타입을 포함합니다.
 숫자를 다루는데 있어 특히 유용한 함수는 fromIntegral입니다. 이는 다음과 같은 타입 선언을 지니고 있습니다:
[source]

NOTE 이 타입 서명에서 fromIntegral은 다수의 클래스 제약을 가지고 있습니다. 이는 여전히 유효합니다. (다수의 클래스 제약들은 괄호 안에서 쉼표로 분리합니다)

 타입 서명으로, fromIntegral은 정수를 받아 더욱 일반적인(general) 숫자로 바꾸는 것을 확인 할 수 있습니다. 이는 정수와 부동 소수의 타입을 동시에 만족하는 작업을 수행할때 매우 유용합니다. 예를들어, length 함수는 다음 타입 선언을 지녔습니다:
[source]

 리스트의 길이를 얻어 3.2를 더하기 원한다면, (Int에 부동 소수를 더하려 했기에) 에러를 맞게될 것입니다. 이를 피하기 위해, 다음과 같이 fromIntegral을 사용할 수 있습니다:
[console]


타입 클래스에 대한 마지막 노트
 타입 클래스는 추상 인터페이스를 정의하기에, 하나의 타입 클래스는 많은 타입 클래스의 인스턴스가 될 수 있으며, 인스턴스로 많은 타입을 가질 수 있습니다. 예를들어, Char 타입은 많은 타입 클래스의 인스턴스이며, 두 문자가 동일한지, 알파벳 순서가 맞는지를 확인 할 수 있기에 그 중 둘은 Eq와 Ord입니다.
 종종 타입이 어떤 타입 클래스의 인스턴스가 되기 위해, 우선 다른 타입 클래스의 인스턴스가 되어야 할 때도 있습니다. 예를들어, 타입이 Ord의 인스턴스가 되기 위해선, 먼저 Eq의 인스턴스가 되어야 합니다. 다시말해, Eq의 인스턴스가 되는 것은 Ord의 인스턴스가 되기 위한 필수 조건입니다. 두개의 순서를 비교할 수 있으면, 두개가 동일한지를 판별할 수 있다라는 것을 생각하시면 이해하기 쉬우실 것입니다.
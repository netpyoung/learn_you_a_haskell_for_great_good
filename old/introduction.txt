소갯말
 하스켈은 재미 그 자체입니다!
 이 책은 C++, Java, Python과 같은 imperative 언어에 대한 프로그래밍 경험이 있으며, 하스켈에 도전하고자 하는 사람들을 겨냥하여 쓰여졌습니다. 특별한 프로그래밍 경험이 없더라도, 당신처럼 똑똑한 사람이라면 잘 따라와서 하스켈을 배울수 있으리라 장담합니다.
 하스켈에 대한 저의 첫번째 느낌은 단지 너무 기괴한 언어였다라는 것이였습니다. 그러나 처음 난관을 넘어선 후에는, 평탄하게 흘러갔습니다. 하스켈이 처음 보기에는 이상하게 생길지 모를지라도, 포기하지 마십시요. 하스켈을 배우는 것은 흡사 다시 처음부터 프로그램하는 법을 배우는 것과 같습니다. 이는 재미있으며, 여러분의 생각을 다르게 전환시켜줍니다.

NOTE
정말로 곤경한 일이 생기시면, freenode network의 IRC 채널 #haskell이 질문하기에 최적의 장소가 될 것입니다. 그곳에 있는 사람들은 훌륭하고, 인내심있으며, 이해심이 많습니다. 그곳은 하스켈 입문자들에게는 좋은 양식이 될 것입니다.


그러면, 하스켈이란 무엇인가?
 하스켈은 순수한 함수형 프로그래밍 언어입니다.
 imperative 프로그래밍 언어에선 컴퓨터에게 작업 순서를 주어 실행해야 합니다. 이를 실행하는 동안, 컴퓨터의 상태가 변화할 수 있습니다. 예를들어, 변수 a를 5로 설정한후 a의 값을 변화시키는 일을 하게될 것입니다. for나 while 루프와 같이 여러번 명령을 실행하기 위한 순차-제어 구조가 있습니다.
 순수한 함수형 언어는 다릅니다. 컴퓨터에게 무엇을 해아하는지를 알리는 것이 아니라, 이게 무엇인지를 알려야합니다. 예를들어 컴퓨터에게 어떠한 숫자의 팩토리얼은 1부터 그 숫자까지 곱해야 한다거나, 목록에 있는 숫자들의 합은 첫번째 숫자 더하기 나머지 숫자들의 합이라고 말할 수 있습니다. 이러한 연산을 함수로 표현할 수 있습니다.
[pic]
 
 함수형 프로그래밍에서, 여러분은 어떠한 값으로 설정된 변수를 나중에 무언가로 설정할 수 없습니다. 만일 여러분이 a를 5라 하였다면, 마음이 바뀌어 이를 다른 거라 해서는 안됩니다. (여러분이 거짓말쟁이십니까?)
 순수한 함수형 언어에서는, 함수는 부수효과(side effect)를 지녀서는 안됩니다. 함수가 수행할 수 있는 유일한 일은, 무언가를 계산하여 결과를 반환하는 것입니다. 처음에는 제한적인것처럼 보일 수 있지만, 실제로는 어떤 훌륭한 결과를 가져다 줍니다.
 만일 함수가 동일한 인자로 두번 호출되었다면, 두번다 동일한 결과를 반환한다는 것을 보장해야 합니다. 이러한 특성을 참조 투명성(referential transparency)이라 부릅니다. 프로그래머가 함수가 정확한지에 대해 쉽게 추론(심지어 증명까지)할 수 있게 합니다. 그런다음 이러한 단순한 함수들을 서로 묶어 더욱 복잡한 함수를 만들 수 있습니다.
 하스켈은 lazy합니다. 이는 특별하게 언급하지 않는다면, 하스켈은 결과를 여러분에게 보여주어야 하기 전까지는 함수를 실행하지 않는다는것을 의미합니다. 이는 참조 투명성을 가능하게 만듭니다. 함수의 결과가 함수에 주어진 인자에 달렸다는 것을 안다면, 함수의 결과를 실제로 계산하는 시점은 중요치 않습니다. lazy 언어인 하스켈은 이러한 이점을 취하여 실제 결과를 계산을 가능한 미뤄둡니다. 결과가 출력되어지기를 원한다면, 하스켈은 그것을 보여주기 위해 필요한 가장 기초적이며 최소한의 계산만을 수행할 것입니다. Laziness는 또한 보기에 무한한 데이터 구조를 만들 수 있게 하는데, 출력을 위해 선택한 데이터 구조의 부분만이 실제로 계산되기 때문입니다.
[pic]

 하스켈의 laziness의 예제를 살펴봅시다. 여러분이 숫자 목록(list)들 xs = [1,2,3,4,5,6,7,8]을 가졌고 모든 원소들을 2배시켜 결과로 새로운 목록을 반환하는 doubleMe라는 함수를 가졌다고 가정해봅시다. 목록을 8배시키고자 한다면, 여러분의 코드는 다음과 같을 것입니다:
[source]

 imperative 언어에선 아마 list을 받은 후, 복사하여 이를 반환할 것입니다. 후에 나머지 두개에도 list를 넣을 것이며, 매번 복사가 일어날 것이며 결과로 반환 할 것입니다.
 lazy 언어에선, 결과로 보여주라는 강제조건 없이 list에 대해 doubleMe를 호출하는 것은 단지 프로그램이 "아싸, 나중에 해야지!"라 말하게 허용하는 것일 뿐입니다. 결과를 보고자 한다면, 첫번째 doubleMe는 두번째를 호출하고 즉시 결과를 원한다고 말할 것입니다. 그런다음 두번째는 동일하게 세번째에 말할 것이며, 세번째는 마지못해 1의 두배인 2를 돌려주게 됩니다. 두번째 doubleMe는 이를 받고 4를 첫번째에 반환합니다. 그런다음 첫번째 doubleMe는 이 결과를 두배하여 여러분에게
마지막 결과 list에 있는 첫번째 요소는 8이라는 것을 알려줍니다. Haskell의 laziness로 인해, doubleMe는 list를 한번만 받아 호출하며, 여러분이 진짜로 필요할때에 비로써 수행됩니다.
 하스켈은 정적 타입입니다. 이는 여러분의 프로그램을 컴파일할때, 컴파일러는 코드 조각이 숫자인지 문자열인지 아니면 다른 것인지 안다는 것을 의미합니다. 정적 타입은 에러 가능성 있는 것들을 컴파일 타임에 잡을 수 있다는 것을 의미합니다. 예를 들어 숫자와 문자열을 더하고자 한다면, 컴파일러는 징징댈 것입니다.
[pic]

 하스켈은 타입 추론(type inference)을 지닌 매우 훌륭한 타입 시스템을 이용합니다. 이는 모든 코드 조각에 대해 명시적으로 타입을 지정할 필요가 없다는 것을 의미하는데, 하스켈의 타입 시스템은 똑똑하게 이를 판단할 수 있기 때문입니다. 예를들어, a = 5 + 4라 하였다면, 하스켈에게 a가 숫자라고 알릴 필요가 없습니다 - 스스로 이를 판별할 수 있습니다. 타입 추론은 더욱 일반화된 코드를 작성하는 것을 쉽게 만들어 줍니다. 두 인자를 받고 이를 더하는 함수를 작성하였고 명시적으로 타입을 서술하지 않았다면, 함수는 두 인자에대해 숫자에 대한 것처럼 행동할 것입니다.
 하스켈은 우아하고 간결합니다. 이는 많은 high-level 개념을 이용하기에, 하스켈 프로그램은 보통 imperative 한것 보다 짧습니다. 짧은 프로그램은 유지하기 더 쉽고 더 적은 버그만을 가지게 됩니다.
 하스켈은 몇몇 실로 굉장한 이들에 의해 만들어졌습니다(with Phds). 하스켈에 대한 작업은 강력한(kick-ass) 언어를 설계하고자 연구 위원회가 모인 1987년에 시작되었습니다. 언어의 안정된 버전을 정의하는 하스켈 리포트는 1999년에 발간되었습니다.


시작하기 앞서 필요한 것은
 하스켈을 시작하기 위해선, 우선 문서 편집기와 하스켈 컴파일러가 필요합니다. 아마 여러분이 선호하는 문서 편집기가 이미 설치되어있을 것이므로, 이에 시간을 소비하진 않을 것입니다. 가장 인기있는 하스켈 컴파일러는 이 책에서 사용할 Glasgow Haskell Compiler(GHC)입니다.
 여러분이 필요한 것을 얻기 위한 최선의 방법은 Haskell Platform을 다운로드 하는 것입니다. Haskell Platform은 GHC 컴파일러 뿐만아니라, 유용한 하스켈 라이브러리를 포함하고 있습니다! 여러분의 시스템에 맞는 Haskell Platform 을 얻기 위해선, http://hackage.haskell.org/platform/로 가서 여러분의 운영체제에 맞게 지시사항을 따르면 됩니다.
 GHC는 (보통 .hs 확장자로된) 하스켈 스크립트를 컴파일할 수 있으며, 또한 interactive 모드를 지니고 있습니다. 여기서, 스크립트에서 함수를 로드할 수 도 있으며, 즉시 결과를 확인하기 위해 직접 호출 할 수 도 있습니다. 특히 여러분이 배울 때에는, interactive 모드를 이용하는 것이 수정사항이 있을 때마다 여러분의 코드를 컴파일 하여 돌려보는 것보다 쉬울 것입니다.
 Haskell Platform을 설치하였고, 리눅스나 맥OS X시스템이면 새로운 터미널 윈도우를 엽니다. 윈도우즈를 선택하였다면, 명령 프롬프트를 엽니다. 거기서, interactive 모드를 시작하기 위해 ghci를 입력후 ENTER키를 누릅니다. (GHCi 프로그램을 찾는데 실패하였다면, 컴퓨터를 재부팅 시켜 보시기 바랍니다)
 예를들어, myfunctions.hs란 스크립트에 몇몇 함수를 정의하였다면 :l myfunctions라 입력함으로써 GHCI로 이 함수를 불러올 수 있습니다. (myfunctions.hs가 GHCi를 구동한 폴더와 동일한 폴더에 있다 가정합니다)
 .hs 스크립트를 바꾸었다면,  다시 파일을 읽어들이기 위해 :l myfunctions을 실행하거나 현재 스크립트를 다시 로드하는 :r을 실행합니다. 보통 저의 작업 순서는 몇몇 함수를 .hs파일에 정의후, GHCi에 로드하고, 만지작거리다가, 파일을 바꾸고, 반복합니다. 이것이 이 책에서 저희가 할 일 입니다.


감사의 말
 정정과 제안, 격려말을 전해주신 모든 이들께 감사합니다. 또한 실제 작가처럼 보이도록 만든 Keith, Sam, Marilyn에게 감사합니다.
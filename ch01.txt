시작하기
 소갯말을 읽지 않는 무서운 사람이라면, 뒤로가서 마지막 단락을 읽어보시기 바랍니다 - 이 책을 어떻게 사용하는지 설명할 뿐만 아니라, GHC에서 함수를 어떻게 로드하는지를 다루고 있습니다.
 우선, GHC의 interactive 모드를 시작하여 몇몇 함수를 호출함으로써, 하스켈에 대해 맛볼 수 있습니다. 터미널을 연다음 ghci를 입력합니다. 이와 같은 환영 메시지를 볼 수 있을 것입니다:
[console]

NOTE
 GHCi의 기본 프롬프트는 Prelude>이지만, 저희는 이 책의 예제로 ghci>를 사용할 것입니다. 여러분의 프롬프트를 책과 동일하게 맞추기 위해, GHCi에 :set prompt "ghci> "를 입력합니다. GHCi를 실행할 때마다 이 작업을 하지 않으려면, 홈 폴더에 .ghci 파일을 만든다음 :set prompt "ghci> "를 넣습니다.

 축하합니다, GHCi에 들어왔습니다! 이제 간단한 산술 연산을 해봅시다:
[console]

[pic]
 하나의 표현식에서 여러 연산자를 이용한다면, 하스켈은 연산자 우선순위대로 이를 실행할 것입니다. 예를들어, *는 - 보다 높은 우선순위를 가졌으므로, 50 * 100 - 4999는 (50 * 100) - 4999로 취급됩니다. 또한 이처럼 명시적으로 연산 순서를 지정하기 위해 괄호를 사용할 수 도 있습니다:
[console]

 정말 멋지지 않습니까?(예, 저도 그렇지 않다는 것을 알고 있지만, 좀만 참아 주세요.)
 주의해애할 함정은 음의 정수입니다. 이러한 경우의 산술 표현식에서는 이를 항상 괄호로 감싸시기 바랍니다. 예를들어, 5 * -3을 입력하면 GHCi는 여러분에게 항의할 것이지만, 5 * (-3)을 입력하면 올바르게 동작할 것입니다.
 부울대수도 또한 하스켈에서는 간단합니다. 다른 프로그래밍 언어와 같이, 하스켈은 불린 값 True와 False를 지니며, 논리곱에 해당하는 && 연산자(부울 and), 논리합에 해당하는 || 연산자(부울 or), True나 False의 반대 값을 얻기 위한 not 연산자가 있습니다:
[console]

 이처럼, 두 값이 동일한지 아닌지에 대해 ==와 /= 연산자로 확인해볼 수 있습니다:
[console]

 그래도, 값들을 섞어서 맞출때에는 조심하시기 바랍니다! 5 + "llama"와 같은 것을 입력한다면, 다음과 같은 에러 메시지가 나올것입니다:
[console]

 GHCi가 여기서 말하는 것은 "llama"가 숫자가 아니며, 따라서 어떻게 이것을 5에 더할지를 모르겠다는 것입니다. + 연산자는 두 입력이 숫자라고 가정합니다.
 다른 경우에는, == 연산자는 비교될 수 있는 두 항목에 대해 동작합니다 : 동일한 타입이여야만 합니다. 예를들어, True == 5 라고 입력하면 GHCi는 불만을 토로할것입니다.

NOTE
 5 + 4.0은 유효한 표현식인데, 비록 4.0은 정수가 아니지만, 5는 교활해서 정수나 소수처럼 행동할 수 있기 때문입니다. 이번 경우, 5는 소수 형태인 4.0에 맞추게 됩니다. 조금있다가 타입에 대해 더 살펴보기로 하겠습니다.


함수호출
 여러분이 깨닫지 못할 것이지만, 저희는 실제로 함수를 항상 사용하고 있습니다. 예를들어, *는 두 숫자를 취해 곱하는 함수입니다. 봐왔다싶이, 이를 곱할 두 숫자 사이에 껴넣어서 적용하였습니다. 이를 중위(이항, infix)함수라 부릅니다.
 그러나 대부분의 함수는 전위함수입니다. 하스켈에서 전위함수를 호출할때는, 함수 이름이 첫번째에 오고 다음으로 공백이 오고, (공백으로 분리된)인자가 오게됩니다.
[pic]

 예제에서, 저희는 하스켈에서 가장 지루한 함수중 하나인 succ를 호출할 것입니다:
[console]

 succ 함수는 잘 정의된 계승자(successor)지닐 수 있는 하나의 인자를 취하여, 그 값을 반환합니다. 정수의 계승자 값은 단순히 바로 다음 숫자입니다.
 이제 다수의 인자를 취하는 두 전위 함수 min과 max를 호출 해 봅시다:
[console]

 min과 max 함수는 각각 (숫자와 같이) 순서대로 놓일 수 있는 두개의 인자를 취하여, 작거나 큰 값을 반환합니다.
 함수 어플리케이션은 모든 하스켈 연산자중 가장 높은 우선권을 지닙니다. 다시 말해, 다음 두 줄은 동일합니다.
[console]

 이는 9 * 10의 계승자를 얻고자 한다면, 단순히 이렇게 작성할 수 없다는 것을 의미합니다.
[console]

 연산자 우선에 인해, 이는 9의 계승자(10)에 대해 10을 곱한 것으로 평가하여, 100을 생산합니다. 저희가 원하는 결과를 얻기 위해선, 대신 이렇게 입력해아 합니다.
[console]

 이는 91을 반환합니다.

 함수가 두 인자를 취한다면, 이를 역 따옴표(`)로 감쌈으로써 중위함수로 호출 할 수 있습니다. 예를들어, div함수는 두 정수를 취한다음, 정수의 나눗샘을 실행합니다:
[console]

 그러나, 이처럼 호출한다면, 어떤 숫자가 나누어지는 것인지와 같은 혼란이 생길 수 도 있습니다. 역따옴표를 이용하여, 중위 함수처럼 이를 호출 할 수 있으며, 이는 돌연히 더욱 깔끔하게 보이게 됩니다:
[console]

 imperative 언어를 이용하는 많은 프로그래머들은 괄호는 함수 어플리케이션을 나타낸다는 관념을 고수하는 경향이 있으며, 하스켈의 일을 처리하는 방식에 적응하는데 곤란함을 격게됩니다. 기억할 것은, bar (bar 3)에서 이는 우선 3을 인자로 같는 bar 함수를 우선 호출하고나서, 다시 결과를 bar 함수로 넘겨준다는 것이라는 것입니다. C에서 동일한 표현법은 bar(bar(3))과 같습니다.


걸음마 함수
[pic]
 함수 정의 문법은 함수 호출과 유사합니다: 함수 이름 다음에 공백으로 분리된 인자가 옵니다. 그리고 인자 목록 다음에 = 연산자가 오게되며, 함수 본체를 구성하게 되는 코드가 오게됩니다.
 예를들기 위해, 수를 받아 2배를 하는 단순한 함수를 작성해 봅시다. 여러분이 선호하는 편집기를 열고 다음을 입력하시기 바랍니다:
[console]

 +가 정수뿐만아니라 소수에도 (사실, 숫자로 취급될 수 있는 모든것에)동작하기에, 저희 함수도 이러한 타입에 동작합니다.
 이제 두 숫자를 취하고, 각각 두 배를 한다음 서로 더하는 함수를 만들어 봅시다. 다음 코드를 baby.hs에 추가합니다:
[code]


NOTE 하스켈에서 특정한 순서로 함수가 정의되지 않으므로, baby.hs 파일에서 어떤 함수가 우선적으로 오는지는 중요치 않습니다.

 이제 파일을 저장하고, 새로운 함수를 불러오기 위해 GHCi에서 :l baby를 입력합니다. 이 함수를 테스트하면 예상했던 결과가 나옵니다:
[console]

 여러분의 정의한 함수는 또한 각각 호출될 수 있습니다. 이러한 점을 염두에 두면, 다음과 같은 방식으로 doubleUs를 재정의 할 수 있습니다:
[code]

 이는 하스켈을 이용하면서 보게될 평범한 패턴의 매우 단순한 예제입니다: 기본적이며 명확하게 정확한 함수들은 더욱 복잡한 함수를 구성하도록 결합될 수 있습니다. 이는 코드 중복을 피하는 바람직한 방법입니다. 예를들어, 어느날 수학자가 2와 3이 실제로 동일하다는 것을 밝혀내면, 여러분의 프로그램을 바꾸어야할까요? 단지 doubleMe를 x + x + x로 재정의하므로써, doubleUs는 doubleMe를 호출하기에, 자동적으로 2와 3이 동일한 이상한 세계에서도 정확하게 동작하게 됩니다
 이제 (100보다 큰 수는 이미 충분하기 때문에)100과 같거나 적은 숫자인경우에만 수를 2배하는 함수를 작성해 봅시다.
[code]

 이 예제는 하스켈의 if 문을 소개하고 있습니다. 여러분은 아마 다른 언어에서 if 문에 친숙하겠지만, 하스켈에서는 else 부분이 의무적입니다.
 프로그램이 동작할때 imperative 언어의 프로그램은 컴퓨터가 실행하는 몇몇 단계가 필수적입니다. if에 else가 없고 조건을 만족하지 않는다면, if문 아랫단계들은 실행되지 않을 것입니다. 그러므로, imperative언어의 if문은 어떠한 일도 하지 않습니다.
 반면, 하스켈 프로그램은 함수의 집합입니다. 함수는 데이터 값을 결과 값으로 변형하는데 이용되며, 모든 함수는 다른 함수가 사용할 수 있는 값을 반환해야 합니다. 모든 함수는 무언가를 반환하기에, 모든 if문은 else을 가져야 한다는 것을 암시합니다. 그렇지않으면, 특정 상황을 만족하면 함수를 작성할 순 있지만, 그 상황을 만족하지 않는 경우를 다룰 수 없습니다. 요약하자면: 하스켈의 if는 값을 반환하는 표현식이지 문(statement)이 아닙니다.
 이전 doubleSmallNumber함수가 했던것에 숫자에 1을 더하는 함수를 원한다고 해 봅시다. 이 새로운 함수의 본체는 이와 같을 것입니다:
[code]

 괄호의 위치를 주목하시기 바랍니다. 이를 생략한다면, 함수는 x가 100 과 같거나 적을 경우에만 1을 더할 것입니다. 함수의 이름 끝에 따옴표(')가 있는 것 또한 주목하시기 바랍니다. 이 따옴표는 하스켈 문법에서 어떠한 특별한 의미를 지니지는 않으며, 이는 함수 이름에 적법한 문자입니다. 보통 (즉, lazy가 아닌) 엄격한(strict) 버전의 함수나 비슷한 이름을 지니면서 약간의 수정된 버전의 함수나 변수에 '를 사용합니다.
 '이 함수 이름에 유효한 문자이기에, 이 처럼 함수를 작성할 수 있습니다:
[code]

 여기서 주목할만한 두가지 있습니다. 첫번째는 함수의 이름 중 Conan을 대문자로 시작하지 않았습니다. 하스켈에서, 함수는 대문자로 시작할 수 없습니다. (왜 그런지 나중에 살펴볼 것입니다.) 두번째로 주목할 것은 이 함수는 어떠한 인자도 받지 않는다는 것입니다. 함수가 어떠한 인자도 받지않을때, 보통 이를 정의(definition)나 이름(name)이라 부릅니다. 일단 이를 정의한 후에 이름(혹은 함수)의 의미를 변경시킬 수 없기에, 함수 conanO'Brein과 문자열 "It's a me, Conan O'Brien!"은 교대하여 사용할 수 있습니다.


리스트 소개
 하스켈에서 리스트는 동종(homogeneous) 데이터 구조이며, 이는 동일한 타입의 요소들을 저장한다는 것을 의미합니다. 예를들어, 정수 리스트나 문자 리스트를 가질 수 있지만, 정수와 문자로 구성된 리스트를 가질 순 없습니다.
 리스트는 사각괄호로 둘러싸이며, 값들은 쉼표로 구분됩니다:
[pic]
[console]

NOTE
 GHCi에서 이름을 정의하기 위해선 let 키워드를 이용합니다. GHCi에서 let a = 1 를 입력하는 것은, 스크립트에서 a = 1 이라 입력하여 :l로 불러오는 것과 동일합니다.


연결(concatenation)
 리스트를 가지고 작업하는 가장 일반적인 연산중 하나는 연결입니다. 하스켈에선, 이러한 일을 ++ 연산자를 이용하여 처리합니다:
[console]

NOTE 하스켈에선, 문자열은 실제로 문자 리스트입니다. 예를들어, 문자열 "hello"는 사실 리스트 ['h','e','l','l','o']와 동일합니다. 이러한 성질로 인해, 문자열에 대해 아주 간편하게 리스트 함수를 사용할 수 있습니다.

 긴 문자열에 대해 ++ 연산자를 반복하여 사용할 때에는 주의하시기 바랍니다. 두 리스트를 서로 합칠때, 하스켈은 (++ 의 왼편에 있는) 첫번째 리스트를 훝어봅니다. 작은 리스트에 대해서는 문제가 될께 없지만, 오천만이나 되는 항목을 지닌 리스트끝에 무언가를 붙이는 것에는 시간이 한참 걸립니다.
 반면, 리스트의 시작부분에 무언가를 더하는 작업은 거의 순식간에 일어납니다. 이러한 일을 : 연산자 (혹은 cons 연산자)로 처리합니다:
[console]

 첫번째 예제에서, :는 하나의 문자와 문자 리스트(문자열)를 인자로 받는다는 것을 알려드립니다. 유사하게, 두번째 예제에선, :는 하나의 숫자와 숫자 리스트를 받습니다. :연산자의 첫번째 인자는 항상 추가할 리스트에 대한 동일한 타입의 단일 항목이 되어야만 합니다.

 반면, ++ 연산자는 항상 두개의 리스트를 인자로 받습니다. 리스트 끝에 ++로 단일 항목을 넣고자 한여 사각괄호로 항목을 둘러싸면, 하스켈은 이것을 리스트로 처리할 것입니다:
[console]

 [1,2,3,4] ++ 5 라 작성하는 것은 잘못된 것인데, ++의 두 인자는 리스트여야 하는데, 5는 리스트가 아니기 때문입니다; 이것은 숫자입니다.
 흥미롭게도, 하스켈에서 [1,2,3]은 단순히 1:2:3:[]에 대한 달콤한 문법(syntax suger)입니다. []는 비어있는 리스트입니다. 3을 이 앞에 넣으면, 이는 [3]이 됩니다. 그리고 그 앞에 2를 넣으면 [2,3]이 됩니다.

NOTE [], [[]] 그리고 [[],[],[]] 는 모두 다른 것입니다. 첫번째는 비어있는 리스트이며, 두번째는 비어있는 하나의 리스트를 포함하는 리스트이며, 세번째는 비어있는 리스트 3개를 포함하는 리스트입니다.


리스트 원소에 접근하기
 색인(index)으로 리스트의 함목을 얻고자 한다면, !!연산자를 이용합니다. 대부분의 프로그래밍 언어에서, 색인은 0부터 시작합니다:
[console]

 그러나, 만일 4개의 항목만을 가진 리스트에서 6번째 항목을 얻고자 한다면, 오류가 발생하니 주의하시기 바랍니다.


리스트 속 리스트
 리스트는 리스트를 항목으로 받을 수 있으며, 리스트를 포함하는 리스트를 포함할 수 있습니다.
[console]

 리스트 속 리스트들은 길이가 서로 다를 순 있지만, 타입 달라선 안됩니다. 문자와 숫자를 항목으로 지닌 리스트를 가질수 없는 것처럼, 문자 리스트와 숫자 리스트를 지닌 리스트를 가질 수 억습니다.


리스트 비교하기
 포함하고 있는 것들이 비교할 수 있는 거라면 리스트는 비교할 수 있습니다. 두 리스트를 비교하기 위해 <, <=, >=, >를 사용하면, 사전순서(lexicographical order)로 비교합니다. 이는 처음 두 리스트의 머릿부분을 비교하여, 같다면, 두번째 항목을 비교한다는 것을 의미합니다. 두번째 항목 역시 같다면, 세번째 항목을 비교하며 다른 항목을 찾을때까지 계속됩니다. 두 리스트의 순서는 다른 항목의 첫번째 쌍의 순서에 의해 결정됩니다.
 예를들어, [3,4,2] < [3,4,3]을 평가한다면, 하스켈은 3과 3이 동일하므로, 4와 4를 비교할 것입니다. 이 둘 또한 동일하므로, 2와 3을 비교할 것입니다. 2가 3보다 작으므로, 첫번째 리스트가 두번째 것보다 작다고 결론을 내리게 됩니다. <=, >=, >도 마찬가지 입니다.
[console]

 또한, 비어있지 않은 리스트는 항상 비어있는 것 보다 크다고 여겨집니다. 
** This makes the ordering of two lists well defined in all cases, including when one is a proper initial segment of the other. **


다른 리스트 연산자들
 여기, 몇몇 기본적인 리스트 함수 및 그 사용에 관한 예제가 나와있습니다.
 head함수는 리스트를 취하여 이의 머리부분이나 첫번째 항목을 반환니다:
[console]

 tail함수는 리스트를 취해 꼬리부분을 반환합니다. 다시말해, 이는 list의 머리부분을 잘라냅니다:
[console]

 last 함수는 리스트의 마지막 항목을 반환합니다:
[console]

 init 함수는 리스트를 취해, 마지막 항목을 빼서 반환합니다:
[console]

 이해를 돕기 위해 이러한 함수들을 시각적으로 나타내면, list를 이와 같은 몬스터(monster)라 생각할 수 있습니다:
[pic]

 그러면 비어있는 list의 head를 얻고자 하면 어떤일이 발생할까요?
[console]

 이럴수가? 당황스럽군요! 몬스터가 없다면, head도 없습니다. head, tail, last, init을 사용할 때에는, 비어있는 리스트에 사용하지 않도록 주의하시기 바랍니다. 이러한 오류는 컴파일 타임에 잡을 수 없으므로, 잘못하여 비어있는 리스트의 원소를 가져오려 하는 하스켈에게 주의를 주는게 좋습니다.
 length 함수는 리스트를 취해, 길이를 반환합니다:
[console]

 null 함수는 리스트가 비어있는지를 확인합니다. 만일 맞다면, True를 반환하며, 아닐시 False를 반환합니다.
[console]

 reverse 함수는 리스트를 뒤집습니다:
[console]

 take 함수는 숫자와 리스트를 취합니다. 이는 이처럼 리스트의 시작부분에서 명시된 숫자만큼 요소를 취합니다:
[console]

 리스트에 있는 것보다 더 많은 항목을 취하고자 한다면, 하스켈은 리스트 전체를 반환합니다. 0개의 항목을 취하고자 한다면, 비어있는 리스트를 얻게됩니다.

 drop 함수는 유사한 방식으로 동작하지만, 리스트의 시작부분에서 지정한 숫자만큼 요소를 떨궈버립니다:
[console]

 maximum 함수는 순서를 매길수 있는 항목들이 있는 리스트를 취하여 가장 큰 요소를 반환합니다. minimum 함수도 비슷하지만, 이는 가장 작은 요소를 반환합니다:
[console]

 sum 함수는 숫자 리스트를 취해 그 합을 반환합니다. prudoct 함수는 숫자 리스트를 취해 그 곱을 반환합니다:
[console]

 elem 함수는 항목과 항목 리스트를 취해, 그 항목이 리스트에 있는지를 말해줍니다. 이는 보통 중위 함수로 호출되는데, 이와 갈은 방식이 읽기 쉽기 때문입니다.
[console]


Texas Ranges
 만약 1부터 20사이의 숫자로 구성된 리스트가 필요하다면 어떨까요? 물론, 일일이 쳐넣을 수 있지만, 프로그래밍 언어가 해줬으면 하는 바램이 있는 분들에게는 그다지 만족할만한 해결책이 아닙니다. 저희는 대신 range를 이용할 것입니다. range는 순서대로 놓일 수 있는 요소들로 구성된 리스트를 만드는데 이용됩니다.
 예를들어, 숫자는 열거될 수 있습니다: 1, 2, 3, 4, ... 문자 또한 열거될 수 있습니다: 알파벳은 A부터 Z까지의 문자 목록입니다. 그러나, 이름은 열거될 수 없습니다. ("John?"다음에 무엇이 올지는 저도 모릅니다!) 
 1부터 20까지 모든 정수를 포함하는 리스트를 만들기 위해선, [1..20]이라 입력하면됩니다. 하스켈에서 이는 [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]이라 친것과 동일합니다. 둘 사이의 유일한 차이점은 긴 순서 목록을 수작업으로 써넣는것은 어리석다는 것입니다.
[pic]

 여기 몇몇 예제가 있습니다:
[console]

 항목 범위 간격 또한 지정할 수 있습니다. 1과 20사이의 짝수 리스트를 얻고자한다면 어떻게 해야 할까요? 혹은 1에서 20사이의 3의 배수를 얻고자한다면 어떻게 해야 할까요? 쉼표로 처음 두 원소를 나눈뒤 상한을 지정하면 간단합니다:
[console]

 범위 간격은 매우 편리하지만, 사람이 생각하는 것만큼 항상 영리한것은 아닙니다. 예를들어, [1,2,4,8,16..100] 을 입력하여 100보다 크지 않는 2의 제곱승을 얻을 수 없습니다. 우선, 오직 하나의 간격크기만을 지정할 수 있습니다. 또한, 적은 조건으로는 산술이 아닌 몇몇 시퀀스를 명확하게 명시할 수 없습니다.


NOTE 20에서 1까지의 숫자 리스트를 만들기 위해선, [20..1]이라 입력해서는 안되며, [20,19..1]이라 입력해야합니다. ([20..1]과 같이) 범위간격을 이용하지 않으면, 하스켈은 비어있는 리스트에서 첫번째 원소에서 마지막 원소에 도달하거나 초과할 때까지 1씩 증가할것입니다. 20이 이미 1보다 크기에, 결과는 비어있는 리스트가 될 것입니다.

 또한 상한이 지정되지 않은 무한한 리스트를 만들기 위해 범위를 이용할 수 있습니다. 예를들어, 13의 배수에서 처음 24개를 포함하는 리스트를 만들어 봅시다. 여기 이를 행하는 하나의 방식이 있습니다:
[console]

 그러나, 무한 리스트를 이용하는 것이 사실 보다 낫은 방식입니다:
[console]

 하스켈은 lazy이기에, 이는 전체 무한 리스트를 즉시 평가하려 하지 않습니다. (이는 괜찮은 방식인데, 만일 그렇지 않다면 영원히 끝나지 않기 때문입니다) 대신, 이는 무한 리스트에서 얻고자 하는 요소를 확인하기 위해 기다릴 것입니다. 위 예제에서, 처음 24 요소만을 얻고자 하는 것을 확인하여 처리해 줍니다.
 여기 길거나 무한한 리스트를 곱할 때 사용할 수 있는 몇몇 함수가 있습니다:

* cycle은 리스트를 받아 이의 원소를 무한대로 똑같이 반복합니다.
결과를 출력하려고 한다면, 무한히 갈것이므로, 어딘가에 잘라내기 바랍니다:
[console]

* repeat은 원소를 받아 그 원소만으로 이루어진 무한한 리스트를 생성합니다. 이는 하나의 원소만을 지닌 리스트를 cycle하는 것과 같습니다:
[console]

* replicate는 단일 항목으로 구성된 리스트를 만들기 위한 간편한 방법입니다. 이는 list의 길이와 항목을 받아 다음처럼 자기 복제를 합니다:
[console]

 범위에 관해 마지막으로 한가지 주목할 점: 부동 소수점(소수, floating point)를 사용할 시에는 주의하시기 바랍니다! 부동 소수점은 태생적으로 제약점을 지니고 있기에, 범위에서 이를 이용할시에는 여기서 보이는 것처럼 매우 이상한 결과가 나타날 수 있습니다:
[console]


I’m a List Comprehension
[pic]
 list comprehensions은 수정, 변형, 결합하는 방법입니다.

 이는 수학적 개념 set comprehension과 매우 유사합니다. set comprehension은 보통 어떤 set에서 다른 set을 만들기 위해 사용됩니다. 간단한 set comprehension의 예 입니다 : {2*x | x C N, x <= 10}. 여기서 사용된 정확한 문법은 중요치 않습니다 - 중요한 것은 이 문장이 말하는, "10보다 작거나 같은 모든 자연수들을 취해서, 각각에 2를 곱하여 새로운 set을 만들어라" 입니다.

 하스켈에서 이와 동일한 것을 작성하고자 한다면, 리스트 연산자로 이와 비슷한 일을 할 수 있습니다: take 10 [2,4..]. 그리고, 또한 이처럼, list comprehension을 이용하여 동일한 일을 할 수 있습니다:

[console]
 list comprehension 문법을 보다 잘 이해하기 위해, 이 예제의 list comprehension을 자세히 살펴보겠습니다.

 [x*2 | x <- [1..10]]은, list [1..10]에서 항목들을 꺼내오는 것입니다. [x <- [1..10]] 는 [1..10]에서 꺼내온 각 항목의 값을 x로 받는다는 것을 의미합니다. 다시 말해, [1..10]의 각 항목들을 x로 묶었습니다. 세로줄(|)의 앞 부분은 list comprehension의 출력부입니다. 출력부는 꺼내온 항목들이 결과 리스트에 어떻게 반영되는지에 대해 명시한 부분입니다. 이 예제는, 리스트 [1..10]의 각 항목이 2배가 되기를 원하고 있습니다.

 처음 예제보다 이것이 더 길고 복잡하다고 느낄 수 있지만, 만일 단순히 숫자를 2배하는 일보다 복잡한 일을 하려면 어떻게 할까요? list comprehension이 실로 유용한 도구가 될 것입니다.

 예를 들어보기 위해, 조건(또는 술부)을 추가해봅시다. 술부는 lisp comprehension뒤에 오며, 쉼표로 구분되어 있습니다. 2를 곱한 후 12보다 크거나 같은 요소들만 원한다고 가정해봅시다:
[console]

 50부터 100까지 7로 나눈 나머지가 3인 숫자 원한다면 어떻게 할까요? 간단 합니다:
[console]

NOTE 술부를 사용하여 제거하는 방법을 여과(filtering)라 합니다

 이제 다른 예제를 들어봅시다. 홀수중에 10보다 크거나 같으면 "BANG", 10보다 작으면 "BOOM!"으로 바꾸는 comprehension을 원한다 가정해봅시다. 숫자가 홀수가 아니면, 리스트에서 빼 버립니다.
 편의상, 저희는 comprehension안에  함수를 넣을 것이며, 따라서 이를 쉽게 재사용할 수 있게 되었습니다:
[console]

NOTE 이 함수를 GHCi에서 정의하려 한다면, 함수 이름 전에 let을 넣어야 한다는 것을 명심하시기 바랍니다. 반면, 스크립트에서 이 함수를 정의하고 GHCi에서 불러들이려 한다면, let을 가지고 장난쳐서는 안됩니다.

 odd 함수는 홀수인 경우 True를, 그렇지 않은 경우에는 False를 반환합니다. 리스트에는 술부에 있는 모든 것들이 참(True)으로 평가된 요소만이 포함됩니다.

[console]

 쉼표로 나눔으로써 술부를 원하는 만큼 포함시킬 수 있습니다. 예를들어, 10부터 20까지 숫자중에 13, 15, 19가 아닌것을 원한다고 가정해 봅시다:
[console]

 list comprehension에선, 다수의 술부를 가질수 있을 뿐만 아니라 다수의 리스트에서 값들을 끌어올 수 있습니다. 다수의 리스트에서 값들을 끌어올때, 리스트간의 원소조합이 결과로 반영됩니다:
[console]

 여기서, x는 [1,2,3]에서 나온것이며 y는 [10,100,100]에서 나온 것입니다. 이 두 list는 다음과 같은방식으로 결합됩니다. 우선, x가 1이 되며, y는 [10, 100, 1000]을 취합니다. list comprehension의 출력부가 x+y이므로, 값 11, 101, 1001이 결과 리스트에 추가됩니다(1에 10, 100, 1000을 더함). 그런 다음, x는 2가되며 똑같은 일이 발생한 결과 12, 102, 1002가 결과 리스트에 추가됩니다. x가 3을 꺼내올때도 마찬가지 입니다.
 이와 같은 방식으로, [1,2,3]에서의 원소 x는 [10,100,100]에서의 원소 y에 모든 가능한 방식으로 각각 결합되게 되며, x+y는 이러한 조합에서 결과 리스트를 만들기 위해 사용됩니다.
 여기 또다른 예제가 있습니다: [2,5,10]과 [8,10,11] 두 리스트를 가지고 있고, 이 리스트의 모든 가능한 곱들을 원한다면, 다음 comprehension을 이용할 수 있습니다:
[console]

 예상대로, 새로운 리스트의 길이는 9입니다. 이제, 50보다 큰 곱을 원한다면 어떻게 할까요? 또 다른 술부를 추가하기만 하면 됩니다:
[console]

 막간을 이용해, 형용사 리스트와 명사 리스트를 조합하는 list comprehension을 만들어 봅시다.
[console]

 저희는 심지어 list comprehension을 이용하여 저희만의 length 함수를 작성할 수 있습니다! 이를 lenght'라 하겠습니다. 이 함수는 list에 있는 모든 원소를 1로 바꾼 다음, 이를 모두 더해 list의 길이가 나오도록 합니다.
[source]

 여기에선 값이 무엇인지 상관할 필요가 없으니, 입력 리스트에서 끌어온 항목들을 저장하기 위해 임시 변수로 밑줄(_)을 이용하였습니다.
 문자열 역시 리스트이므로, 문자열을 처리하고 생성하기 위해 list comprehension을 이용할 수 있다는 것을 명심하시기 바랍니다. 여기 문자열을 받아 소문자를 모두 제거하는 예제 함수가 있습니다:
[source]

 여기서 술부는 제대로 동작합니다. 문자가 리스트 ['A'..'Z']의 원소라면 새로운 리스트에 포함됩니다. 이 함수를 GHCi에서 로드하여 테스트해볼 수 있습니다.
[console]

 리스트를 담은 리스트에 대해 작업한다면 중첩된 list comprehension을 만들 수 있습니다. 예를들어, 숫자 리스트를 담는 리스트에서 중첩을 풀지 않고 모든 홀수를 없에 봅시다:
[console]

 여기서 list comprehension의 출력부는 또 다른 list comprehension입니다. list comprehension는 항상 어떠한 리스트가 되므로, 여기서 결과는 숫자 리스트의 리스트가 될 거라는 것을 알 수 있습니다.

NOTE 가독성을 향상시키기 위해 list comprehensions를 몇몇 라인으로 나눌 수 있습니다. GHCi가 아니라면, 특히 중첩된 comprehension을 다룰때 상당히 도움 될 것입니다.


튜플(Tuples)
 튜플은 여러개의 원소를 하나의 값으로 저장하는데 사용됩니다.
 여러면에서, 튜플은 리스트와 많이 닮아 있습니다. 그러나, 이들은 근본적으로 다릅니다. 우선, 앞서 언급했듯이, 튜플은 형태가 자유롭습니다. 이는 하나의 튜플에 다양한 타입의 원소들을 저장할 수 있다는 것을 의미합니다. 다음으로, 튜플은 고정된 크기를 갖습니다 - 저장하기 앞서 원소들이 몇개인지 알아야 합니다.
[pic]

 튜플은 괄호로 감싸져있으며, 각 구성원들은 쉼표로 분리되었습니다:
[console]


튜플의 사용
 튜플이 유용한 경우가 언제인지, 하스켈에서 2차원 벡터를 나타낼 수 있는지 생각해 봅시다. [x, y] 형태인 2개의 항목을 지닌 리스트를 이용하는 것이 한 방법이 될 수 있을 것입니다. 평면 좌표계에서 2차원 도형의 꼭지점을 표시하기 위해 벡터 리스트를 만들고자 한다고 가정해봅시다. 이처럼 리스트의 리스트를 만들어야 할 것입니다: [[1,2],[8,11],[4,5]].
 그러나 이 방법의 문제는, [[1,2],[8,11,5],[4,5]]와 같은 리스트를 만들 수 있어야 하며, 벡터 리스트에서 이를 사용할 수 있어야 한다는 것입니다. 벡터 리스트에 맞진 않지만, 동일한 타입의 숫자 리스트의 리스트이기에 이전 리스트에는 문제가 없습니다. 이는 더욱 복잡한 벡터와 도형을 다루는 함수를 작성하기 위해 사용될 수 있습니다.
 대조적으로, 크기가 2인 튜플(pair)과 크기가 3인 튜플(triple)은 서로 다른 타입으로 취급되며, 이는 리스트는 pair와 triple로 구성되지 못한다는 것을 의미합니다. 이는 튜플이 벡터를 표현하기에 더욱 유용하게 만들어 줍니다.
 이처럼, 사각 괄호대신 괄호로 감싸므로써 벡터를 튜플로 바꿀수 있습니다: [(1,2),(8,11),(4,5)]. 지금, pair와 triple를 섞고자 한다면 이처럼 에러가 발생할 것입니다:
[console]

 하스켈은 또한 튜플이 동일한 길이를 가졌지만, 다양한 타입의 데이터를 포함한다고 가정합니다. 예를들어 [(1,2),("One",2)]와 같은 튜플 리스트는, 첫번째는 숫자 쌍이고 두번째는 문자열과 숫자를 담기에 만들 수 없습니다
 튜플은 다양한 데이터를 쉽게 표현하는데 사용할 수 있습니다. 예를들어, 누군가의 이름과 나이를 하스켈에서 표현하는데 튜플을 사용할 수 있습니다: ("Christopher", "Walken", 55).
 기억해야할 것은, 튜플이 고정된 크기라는 것입니다. - 여러분이 필요할 요소가 얼마나 있는지를 이미 알고 있는 경우에만 사용하시기 바랍니다. 언급했듯이 튜플의 크기는 타입의 일부분으로 취급된다는 것은 매우 엄격합니다. 이것이 의미하는 것은 불행히도 튜플에 원소를 추가하는 general 함수를 작성할 수 없다는 것을 의미합니다. triple을 생성하기 위해 pair에 더하는 함수를, triple에 더하는 다른 함수를, 4-tuple에 더하는 또 다른 함수 등등을 작성해야만 합니다.
 리스트처럼, 튜플은 구성원들이 비교될 수 있다면 서로를 비교할 수 있습니다. 그러나, 리스트와는 다르게, 다른 크기의 튜플을 비교할 순 없습니다.
 싱글톤 리스트는 있지만, 싱글톤 튜플같은건 없습니다. 이를 생각해보면 이치에 맞을 것입니다: 싱글톤 튜플의 속성은 단순히 이것이 포함하고 있는 값이 되는 것이므로, 새로운 타입을 구분하는 것은 아무런 이점이 없습니다.


Pairs 사용하기
 하스켈에서 데이터를 pair에 저장하는 것은 매우 일반적이며, 이를 다루는 몇몇 유용한 함수들이 있습니다. 여기 pair를 다루는 두 함수가 있습니다:
? fst 는 pair를 받아 첫번째 구성물을 반환합니다:
[console]

? snd는 pair를 받아 두번째 구성물을 반환합니다:
[console]

NOTE 이 함수들은 pair에만 동작합니다. triple, 4-tuples, 5-tuples, 등등에는 동작하지 않습니다. 저희는 조금 뒤에 튜플로부터 데이터를 다양한 방식으로 추출할 것입니다

 zip함수는 pair 리스트를 만들기 위한 신선한 방법입니다. 이는 두 리스트를 취해, 마주하는 원소들을 pair로 묶음으로써 하나의 리스트로 만듭니다. 이는 매우 단순한 함수이지만, 특별한 방식으로 두 리스트 조합하거나 두 리스트를 동시에 다룰때 유용합니다. 여기 예가 있습니다: 
[console]

 pair는 다른 타입을 지닐 수 있으므로, zip은 다른 타입을 요소로 포함하는 두 리스트를 취할 수 있습니다. 그러나 리스트의 길이가 서로 맞지 않는다면 어떤일이 발생할 까요?
[console]

 위 예제에서 보시는 것과 같이, 필요한 만큼 사용되었고 나머지는 무시되었습니다. 그리고 하스켈은 lazy 평가를 이용하기에, 심지어 zip을 유한한 리스트와 무한한 리스트에 사용할 수 도 있습니다:
[console]
[pic]


직각 삼각형 찾기
 튜플과 list comprehension을 섞는 문제를 풀어봅시다. 아래 조건들을 만족하는 직각 삼각형을 찾기위해 하스켈을 이용할 것입니다:
 
? 세변은 모두 integer이다.
? 각 변의 길이는 10보다 작거나 같다.
? 삼각형의 둘레는 24이다.

 직각 삼각형은 한 각이 90도인 삼각형입니다. 직각 삼각형은 직각을 낀 각 변의 제곱의 합과 빗변의 길이를 제곱이 같다는 속성을 지니고 있습니다. 그림에서, 직각을 낀 변은 a, b로 빗변은 c로 이름이 붙여있습니다.
 우선, 10보다 같거나 작은 삼각형의 요소로 가능한 모든 것들을 생성해 봅시다:
[console]

 저희는 comprehension의 우측에 있는 3개의 리스트를 끌어올 것이며, 좌측의 출력 표현식은 이를 삼각형 리스트로 만듭니다. GHCi에서 triples를 평가한다면, 1000개의 항목을 지닌 리스트를 얻게되므로, 이를 여기서 보지 않겠습니다.
 다음으로, 피타고라스의 정리 (a^2 + b^2 == c^2)를 만족하는지 확인하기 위한 술부를 추가함으로써, 직각 삼각형이 아닌 삼각형들을 걸러낼 것입니다.
[console]

 계속해서, 저희는 변 a가 빗변 c보다 작으며, 변 b가 변 a보다 작은 것을 보장하도록 함수를 수정할 것입니다:
[console]

 끌어온 값들로부터 리스트의 범위를 어떻게 변화시켰는지 주목하시기 바랍니다. 이는, 변 b가 빗변보다 큰다거나 하는, 불필요한 삼각형들을 검사하지 않는다는 것을 보증합니다(직각 삼각형에선 빗변은 항상 가장 긴 변입니다). 변 b가 변 a보다 절대로 크지 않다고 가정할 수 있습니다.
 삼각형 (a,b,c)에서 a^2 + b^2 == c^2 과 b > a 는 삼각형 (b,a,c)의 포함을 고려대상에서 제외하기에 문제될게 없습니다 - 변이 뒤집혔을 뿐 동일한 삼각형입니다. (그렇지 않으면, 결과 리스트는 결과적으로 동일한 삼각형의 쌍을 포함하게될 것입니다.)

NOTE GHCi에선 다수의 라인에 걸처 정의와 표현식을 쪼갤 수 없습니다. 그러나, 이 책에서는 페이지에 맞추기 위해 경우에 따라서 라인을 쪼갤 것입니다. (그렇지 않으면, 책은 넓이가 매우 길어져서, 평범한 책장에는 넣을 수 없을 것이며, 여러분은 더 큰 책장을 사야할 것입니다!)

 거의 다 끝났습니다. 이제 둘래가 24인 삼각형을 출력하록 함수를 수정만 하면됩니다:
[console]

 이것이 바로 정답입니다! 이는 함수형 프로그래밍에 있어 일반적인 패턴입니다: 특정 집합에서 시작하여, 계속하여 변화를 적용하고 해결책에 가까워질때까지 개선하였습니다.
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>Learn You a Haskell for Great Good! - Recursion</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <base href="http://learnyouahaskell.com/"> <style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style><link rel="shortcut icon" href="favicon.png" type="image/png">
    <link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
    <link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
  </head>
  <body class="introcontent">
    <div class="bgwrapper">
      <div id="content">
        <div class="footdiv" style="margin-bottom: 25px;">
          <ul>
            <li style="text-align: left;"> <a href="syntax-in-functions"
                class="prevlink">Syntax in Functions</a> </li>
            <li style="text-align: center;"> <a href="chapters">목 차</a>
            </li>
            <li style="text-align: right;"> <a href="higher-order-functions"
                class="nxtlink">Higher Order Functions</a> </li>
          </ul>
        </div>
        <h1 style="margin-left: -2px;">재귀</h1>
        <a name="hello-recursion"></a>
        <h2>안녕 재귀!</h2>
        <img src="http://s3.amazonaws.com/lyah/recursion.png" alt="SOVIET RUSSIA"
          class="left" height="179" width="250">
        <p>이전 장에서 재귀에 대해 간략히 언급하였습니다. 이번 장에선, 하스켈에서 재귀가 왜 중요하며,&nbsp;
          재귀적으로 생각함으로써 어떻게 간결하고 우아한 해결책을 내놓을 수 있는지, 재귀에 대해 좀더 자세히 살펴볼
          것입니다. </p>
        <p>여러분이 아직 재귀가 무엇인지 알지 못했다면, 이 문장을 다시 읽어보시기 바랍니다. 하하! 농담입니다! 재귀는
          사실 함수 내부에서 자기 자신을 호출하도록 정의하는 하나의 방법입니다. 수학에서의 정의는 보통 재귀적으로
          주어집니다. 예를들어, 피보나치 수열이 재귀적으로 정의되었습니다. 우리는 먼저 두 피보나치 수를 재귀적이지 않게
          정의해야 합니다. 0번째와 1번째의 피보나치 수 각각이 0과 1이라는 것을 의미하는 <i>F(0) = 0</i>과
          <i>F(1) = 1</i><span style="font-style: italic;"></span>라 합시다.
          그런 다음 다른 자연수의 피보나치 숫자는 이전 두 피보나치 수의 합이라고 합니다. 따라서 <i>F(n) =
            F(n-1) + F(n-2)</i> 입니다. 이 공식에선, <i>F(3)</i>은 <i>(F(1) +
            F(0)) + F(1)</i>인 <i>F(2) + F(1)</i>가 됩니다. 이제 재귀적으로 정의되지 않은
          피보나치 수가 되었으니, <i>F(3)</i>이 2라고 확실히 말 할 수 있습니다. 여기서 <i>F(0)</i>와
          <i>F(1)</i>처럼, 재귀의 정의에 있어 재귀적으로 정의되지 않은 하나 혹은 두 원소를 지니는 것을 <em>주
            변조건(edge condition)</em>라 부르며, 이는 재귀 함수를 종료할때 중요합니다. <i>F(0)</i>과
          <i>F(1)</i>이 재귀적으로 정의되었으면, 0에 도달해도, 음수로 가게되므로 답을 얻지 못할 것입니다.
          불현듯, 여러분이 "<i>F(-2000)</i>은 <i>F(-2001) + F(-2002)</i>이다" 라
          해도,&nbsp; 결코 끝을 보지 못할 것입니다!</p>
        <p>&nbsp;명령형(imperative) 언어와는 달리, 하스켈에선 <span style="font-style: italic;">어
            떻게</span>&nbsp; 얻을까 대신 <span style="font-style: italic;">무엇</span>
          일까라고 선언함으로써 계산을 수행할 수 있기에, 하스켈에서의 재귀는 중요합니다. 이것이 하스켈에는 while
          루프나 for 루프가 없는 대신 무엇인가를 정의하기 위해 재귀를 많이 사용하는 이유입니다.</p>
        <a name="maximum-awesome"></a>
        <h2>끝내주는 maximum</h2>
        <p>&nbsp;<span class="fixed">maximum</span>함수는 순서를 매길수 있는 리스트를
          받아 그 중 가장 큰 것을 반환합니다 (예. <span class="fixed">Ord</span>타입
          클래스의 인스턴스). imperative 한 방법으로 이걸 어떻게 구현할지 생각 해 봅시다. 아마 여러분은
          나중에 최대값을 받을 변수를 설정한 다음 리스트의 원소를 돌면서 현재 최대값보다 크면, 그 원소를 최대값으로
          교체할 것입니다. 최종적으로 남아있는 최대값이 결과가 됩니다. 휴! 이와 같은 단순한 알고리즘을 기술하는데 너무
          많은 단어를 썼습니다!</p>
        <p>이제 이를 어떻게 재귀적으로 정의하는지 살펴봅시다. 우선 싱글톤 리스트의 최대값은 그 안에 있는 단 하나의
          원소라고 주변조건을 설정합니다. 그런 다음 리스트의 head가 tail의 최대값보다 크면 최대값은 head라 할
          수 있습니다. tail의 최대값이 크면, 최대값은 tail의 최대값입니다. 끝났습니다! 이제 하스켈로 구현해
          봅시다.</p>
        <pre name="code" class="haskell:hs">maximum' :: (Ord a) =&gt; [a] -&gt; a
maximum' [] = error "maximum of empty list"
maximum' [x] = x
maximum' (x:xs) 
    | x &gt; maxTail = x
    | otherwise = maxTail
    where maxTail = maximum' xs
</pre>
        <p>보시다시피, 패턴 매칭은 커다란 재귀를 돌고 있습니다! 대부분의 imperative 언어들은 패턴매칭을 갖지
          않으므로, 주변조건을 검사하기 위해 많은 if else 구문을 만들어야만 했습니다. 여기선, 패턴으로
          표현해냈습니다. 첫번째 주변조건은, "리스트가 비어있으면, 오류가 발생한다!"를 의미합니다. 리스트가 비어있으면
          최대값을 알 수 없기에 이치에 맞습니다. 두번째 패턴도 하나의 주변조건을 제시합니다. "싱글톤 리스트라면, 그
          하나만 있는 원소를 반환한다".</p>
        <p>이제 문제의 세번째 패턴입니다. head와 tail을 나누기 위해 패턴 매칭을 사용하였습니다. 이는 리스트에
          재귀를 적용할때 매우 흔한 idiom입니다. 리스트의 나머지의 최대값으로써 <span class="fixed">maxTail</span>을
          정의하기 위해 <i>where</i> 바인딩을 사용하였습니다. 그런 다음, head가 나머지 리스트의
          최대값보다 큰지 확인합니다. 그러하다면, head를 반환합니다. 그렇지 않다면, 나머지 리스트의 최대값을
          반환합니다.</p>
        <p>예제 리스트로 어떻게 동작하는지 살펴봅시다: <span class="fixed">[2,5,1]</span>.
          <span class="fixed">maximum'</span>을 호출하면, 처음 두 패턴은 매치되지 않습니다.
          세번째에 매치할 것이며, 리스트는 <span class="fixed">2</span>와 <span class="fixed">[5,1]</span>로
          분리됩니다. <i>where</i>절이 <span class="fixed">[5,1]</span>의 최대값을
          알고자 하므로, 다음으로 넘어갑니다. <span class="fixed">[5,1]</span>는 또 다시
          세번째 패턴과 매치되어, <span class="fixed">5</span>와 <span class="fixed">[1]</span>로
          분리됩니다. 다시 한번, <span class="fixed">where</span>절은 <span class="fixed">[1]</span>의
          최대값을 알고자 합니다. 이것은 주변조건이므로, <span class="fixed">1</span>을 반환하게
          됩니다. 이제 끝났습니다! 한단계 올라가서, <span class="fixed">5</span>와 <span
            class="fixed">[1]</span>의 최대값( <span class="fixed">1</span>)
          을 비교하면, <span class="fixed">5</span>를 얻게 됩니다. 따라서 <span class="fixed">[5,1]</span>의
          최대값은 <span class="fixed">5</span>입니다. 다시 <span class="fixed">2</span>와
          <span class="fixed">[5,1]</span>가 있는 단계로 올라갑니다. <span class="fixed">2</span>와
          <span class="fixed">[5,1]</span>의 최대값을 비교하면, <span class="fixed">5</span>를
          얻게됩니다.</p>
        <p>더 깔끔한 방법은 <span class="fixed">max</span>를 사용하는 것입니다. 기억이
          맞다면, <span class="fixed">max</span>는 두 숫자를 받아 그 중 큰 값을 반환합니다.
          여기 <span class="fixed">max</span>를 이용하여 <span class="fixed">maximum'</span>을
          재작성하는 법이 나와있습니다.:</p>
        <pre name="code" class="haskell:hs">maximum' :: (Ord a) =&gt; [a] -&gt; a
maximum' [] = error "maximum of empty list"
maximum' [x] = x
maximum' (x:xs) = max x (maximum' xs)
</pre>
        <p>얼마나 우아합니까! 요컨대, 리스트의 최대값은 첫번째 원소와 tail의 최대값의 max입니다.</p>
        <img src="http://s3.amazonaws.com/lyah/maxs.png" alt="max" class="center"
          height="267" width="651"> <a name="a-few-more-recursive-functions"></a>
        <h2>재귀 함수에 대해 좀 더</h2>
        <p>이제 저희는 재귀적으로 생각하는 법을 대략 알게 됬으므로, 재귀를 이용해서 함수를 몇개 만들어 봅니다. 우선,
          저희는 <span class="fixed">replicate</span>을 구현할 것입니다. <span class="fixed">replicate</span>는
          <span class="fixed">Int</span>하나와 원소하나를 받아 반복되는 원소를 지닌 리스트를
          반환합니다. 예를들어, <span class="fixed">replicate 3 5</span>는 <span
            class="fixed">[5,5,5]</span>를 반환합니다. 주변 조건에 대해 생각해봅시다. 제 생각엔
          주변 조건은 0이하일때 입니다. 무언가를 0번 반복한다면, 비어있는 리스트를 반환하도록 할 것입니다. 또한
          음수일때도 마찬가지입니다.</p>
        <pre name="code" class="haskell:hs">replicate' :: (Num i, Ord i) =&gt; i -&gt; a -&gt; [a]
replicate' n x
    | n &lt;= 0    = []
    | otherwise = x:replicate' (n-1) x
</pre>
        <p>여기서 저희는 부울조건을 검사하기 위해 패턴대신 가드를 사용하였습니다. <span class="fixed">n</span>이
          0보다 작거나 같으면, 비어있는 리스트를 반환합니다. 그렇지 않으면, <span class="fixed">x</span>를
          첫번째 원소로하고 <span class="fixed">x</span>가 n-1번 반복되는 리스트를 반환합니다.
          결과적으로, <span class="fixed">(n-1)</span>부분이 함수를 주변조건으로 이끌어 줄
          것입니다.</p>
        <div class="hintbox"><em>Note:</em> <span class="fixed">Num</span>은
          <span class="fixed">Ord</span>의 하위클래스가 아닙니다. 이는 숫자를 구성하는데 있어
          순서를 고수할 필요가 없다는 것을 의미합니다. 이것이 바로 덧셈, 뺄셈, 비교를 할때, <span class="fixed">Num</span>와
          <span class="fixed">Ord</span> 클래스 제약을 명시해야 되는 이유입니다.</div>
        <p>다음으로, <span class="fixed">take</span>를 구현할 것입니다. 이것은 리스트로부터
          특정 갯숫만큼 리스트를 받아옵니다. 예를들어, <span class="fixed">take 3
            [5,4,3,2,1]</span>는 <span class="fixed">[5,4,3]</span>을
          반환합니다. 리스트에서 0보다 적게 얻고자 한다면, 빈 리스트를 얻게 될 것입니다. 또한, 비어있는 리스트에서
          무언가를 얻어올려고 해도, 빈 리스트를 얻게 될 것입니다. 바로 여기에 2개의 주변조건이 있다는 것을 주목하시기
          바랍니다. 그럼 이제 작성해 봅시다:</p>
        <pre name="code" class="haskell:hs">take' :: (Num i, Ord i) =&gt; i -&gt; [a] -&gt; [a]
take' n _
    | n &lt;= 0   = []
take' _ []     = []
take' n (x:xs) = x : take' (n-1) xs
</pre> <img src="http://s3.amazonaws.com/lyah/painter.png" alt="painter"
          class="right" height="276" width="350">
        <p>첫번째 패턴은 0이하의 원소를 얻고자 한다면, 비어있는 리스트를 얻게 된다고 명시되었습니다. 이번 경우
          신경쓰고자 하지 않은 리스트를 매치하고자 <span class="fixed">_</span>를 사용한 것을
          주목하시기 바랍니다. 또한 <span class="fixed">otherwise</span>부분 없이 가드를
          이용한 것을 주목하시기 바랍니다. 이는 <span class="fixed">n</span>이 0보다 크다면,
          다음 패턴으로 넘어간 다는 것을 의미합니다. 두번째 패턴은 비어있는 리스트에서 무언가를 얻어오고자 한다면, 빈
          리스트를 얻게 된다는 것을 알려주고 있습니다. 세번째 패턴은 리스트를 head와 tail로 나눕니다. 그리고
          나서 리스트로부터 <span class="fixed">n</span>개의 원소를 취하는 것은, <span class="fixed">x</span>
          와 tail로부터 <span class="fixed">n-1</span>개 의 원소를 취하는 리스트를,
          head와 tail로 갖는 것과 같다고 나와있습니다. 종이를 갖고, <span class="fixed">[4,3,2,1]</span>에
          서 3개를 취한다고 했을때 어떻게 평가되는지 한번 써봅시다.</p>
        <p><span class="fixed">reverse</span>는 단순히 리스트를 뒤집습니다. 주변 조건에 대해
          생각해 봅시다 무엇일까요? 어서요 ... 빈 리스트입니다! 빈 리스트를 뒤집어도 빈 리스트 그 자체입니다.
          좋습니다. 나머진 무엇일까요? 음, 리스트를 head와 tail로 나눈다면, 뒤집힌 리스트는 뒤집힌 tail에
          head가 오는 것과 같다고 말할 수 있을 것입니다.</p>
        <pre name="code" class="haskell:hs">reverse' :: [a] -&gt; [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]
</pre>
        <p>다음으로 넘어가 봅시다!</p>
        <p>하스켈은 무한 리스트를 지원하므로, 저희 재귀는 실제로 주변조건에 도달할 수 없습니다. 하지만, 도달할 수
          없으면, 뭔가를 무한히 뒤지거나, 무한한 자료구조를 생성할 것입니다. 무한 리스트에서 좋은 점은, 원하는 만큼
          자를 수 있다는 것입니다. <span class="fixed">repeat</span> 은 원소를 받아 그
          원소를 갖는 무한 리스트를 반환합니다. 보시는 바와 같이, 이것의 재귀 구현은 매우 쉽습니다.</p>
        <pre name="code" class="haskell:hs">repeat' :: a -&gt; [a]
repeat' x = x:repeat' x
</pre>
        <p>&nbsp;<span class="fixed">repeat 3</span>를 호출하면, 3으로 시작하고
          tail로 무한한 3을 갖는 리스트를 얻을 것입니다. 그러므로 <span class="fixed">repeat
            3</span>을 호출하는 것은 <span class="fixed">3:repeat 3</span>, <span
            class="fixed">3:(3:repeat 3)</span>, <span class="fixed">3:(3:(3:repeat




            3))</span> 등등을 평가한 것과 같습니다. <span class="fixed">repeat 3</span>은
          평가를 멈추지 않지만, <span class="fixed">take 5 (repeat 3)</span>은 3이
          5개가 들어있는 리스트를 돌려 줄 것입니다. 따라서 이것은 본질적으로 <span class="fixed">replicate




            5 3</span>이 하는 일과 같습니다.</p>
        <p><span class="fixed">zip</span>은 리스트 2개를 받아, 서로 엮어줍니다. <span
            class="fixed">zip [1,2,3] [2,3]</span>은 <span class="fixed">[(1,2),(2,3)]</span>을
          반환하는데, 길이를 짧은 것에 맞추기 위해 긴 리스트를 자르기 때문입니다. 어떠한 것과 빈 리스트를 zip하면
          어떻게 될까요? 음, 저희는 빈 리스트를 되받을 것입니다. 따라서 이건 주변조건입니다. 하지만, <span class="fixed">zip</span>은
          인자로 2개의 리스트를 받으므로, 2개의 주변조건이 있습니다.<br>
        </p>
        <pre name="code" class="haskell:hs">zip' :: [a] -&gt; [b] -&gt; [(a,b)]
zip' _ [] = []
zip' [] _ = []
zip' (x:xs) (y:ys) = (x,y):zip' xs ys
</pre>
        <p>처음 두 패턴은, 첫번째 리스트나 두번째 리스트가 비어있으면, 빈 리스트를 얻을 것입니다. 세번째는 두
          리스트를 엮는것은, head를 pair한 것에 뒤에 tail을 zip한게 따라온 것과 동일하다고 되어있습니다.
          <span class="fixed">[1,2,3]</span>와 <span class="fixed">['a','b']</span>를
          엮는 것은, 마지막에 가서 <span class="fixed">[3]</span>과 <span class="fixed">[]</span>을
          엮으려 할 것입니다. 주변 조건 패턴은 이를 넘겨버릴 것이므로, 결과는 <span class="fixed">(1,'a'):(2,'b'):[]</span>가
          되며, 이는<span class="fixed">[(1,'a'),(2,'b')]</span>와 같습니다.</p>
        <p>표준 라이브러리 함수를 하나 더 구현해 봅시다 — <span class="fixed">elem</span>.
          이는 원소를 받아 그 원소가 리스트에 있는지 확인합니다. 주변 조건으로는 리스트에 빠질 수 없는 빈
          리스트입니다. 빈 리스트는 원소가 없으므로, 이를 뒤져볼 필요가 없습니다.</p>
        <pre name="code" class="haskell:hs">elem' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
elem' a [] = False
elem' a (x:xs)
    | a == x    = True
    | otherwise = a `elem'` xs 
</pre>
        <p>매우 간단하며, 알아보기 쉽습니다. head가 그 원소가 아니면, tail을 검사합니다. 만약 리스트가
          비어있다면, 결과는 <span class="fixed">False</span>입니다.</p>
        <a name="quick-sort"></a>
        <h2>정렬을 빠르게!</h2>
        <p>저희가 정렬할 수 있는 리스트를 지녔다고 가정해봅시다. 그 타입은 <span class="fixed">Ord</span>
          타입클래스의 인스턴스입니다. 그리고, 저희는 그걸 정렬하고자 합니다! quicksort라 불리는 매우 멋진
          알고리즘이 있습니다. 이는 항목을 정렬하는데 있어 매우 산듯한 방법입니다. imperative 언어에서
          quicksort을 구현하려면 10줄을 넘어가는데 반해, 하스켈에서는 더 간결하고 우아하게 구현할 수 있습니다.
          quicksort는 하스켈의 표지모델이 되었습니다. 그러므로, 여기서 한번 구현해 봅시다.</p>
        <img src="http://s3.amazonaws.com/lyah/quickman.png" alt="quickman"
          class="left" height="235" width="180">
        <p>자, 타입 서명은 <span class="fixed">quicksort :: (Ord a) =&gt; [a]
            -&gt; [a]</span>가 될 것입니다. 여기서 놀랄만한건 없습니다. 그러면 주변 조건은 어떨까요?
          예상대로, 비어있는 리스트입니다. 비어있는 리스트를 정렬하면 빈 리스트가 됩니다. 다음으로 주 알고리즘이
          나옵니다: <em>정렬된 리스트는, head보다 작거나 같은 값들로 구성된 </em>'<em>정렬된</em>'<em>리
            스트가 head앞에오고, head뒤로는 head보다 큰 값들로 구성된 </em>'<em>정렬된</em>'<em>리
            스트가 오는 리스트이다.</em> 정의에서 '정렬된' 이라고 두번 언급한 것을 주목하셨다면, 재귀 호출을
          두번 해야만 한다는 것을 알 것입니다! 또한 알고리즘 정의에 있어 '~하고, ~한다'라고 말하는 대신 '~는
          ~이다' 라고 한 것에 주목하시기 바랍니다. 이게 바로 함수형 프로그래밍의 아름다움입니다! 그러면 어떻게
          head보다 크거나 작은 요소들을 걸러낼까요? 바로 리스트 이해(List comprehensions)입니다.
          그럼, 한번 이 함수에 몰아넣어 정의해 봅시다.</p>
        <pre name="code" class="haskell:hs">quicksort :: (Ord a) =&gt; [a] -&gt; [a]
quicksort [] = []
quicksort (x:xs) = 
    let smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]
        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]
    in  smallerSorted ++ [x] ++ biggerSorted
</pre>
        <p>간단한 테스트를 돌려봐서 올바르게 동작하는지 살펴봅시다.</p>
        <pre name="code" class="haskell:ghci">ghci&gt; quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9]
[1,2,2,3,3,4,4,5,6,7,8,9,10]
ghci&gt; quicksort "the quick brown fox jumps over the lazy dog"
"        abcdeeefghhijklmnoooopqrrsttuuvwxyz"
</pre>
        <p>예! 이게 바로 제가 말한 것입니다!&nbsp; <span class="fixed">[5,1,9,4,6,7,3]</span>
          를 정렬하기 원한다면, 이 알고리즘은 <span class="fixed">5</span>인 head를 취해
          이보다 큰 리스트와 작은 리스트 중간에 껴놓을 것입니다. 어느 지점에서, 여러분은 <span class="fixed">[1,4,3]

            ++ [5] ++ [9,6,7]</span>를 얻게 될 것입니다. 일단 리스트가 정렬이 되면,&nbsp;
          3개의 숫자가 이보다 작고, 3개의 숫자가 이보다 크므로 <span class="fixed">5</span>
          는 4번째 위치에 머무를 것입니다. 이제, 저희는&nbsp; <span class="fixed">[1,4,3]</span>
          와 <span class="fixed">[9,6,7]</span> 를 정렬할 것입니다! 이 두 리스트를 동일한
          함수를 이용하여 정렬할 것입니다. 결국, 비어있는 리스트에 도달해서야 멈출 것입니다. 여기 도해가 나와
          있습니다:</p>
        <img src="http://s3.amazonaws.com/lyah/quicksort.png" alt="quicksort"
          class="center" height="332" width="799">
        <p><span style="color: rgb(255, 102, 0); font-weight: bold;">orange</span>
          색으로 표시된 것은 움직이지 않습니다. 표시된 것을 왼쪽에서 오른쪽으로 읽으면, 정렬된 리스트를 확인할 수
          있습니다. 요소들과 비교하기 위해 head를 선택했지만, 다른 것을 사용할 수 도 있습니다.
          quicksort에선, 비교되는 원소를 피봇(중심점, pivot)이라 부릅니다. 여기서 <span style="color: rgb(0, 153, 0); font-weight: bold;">green</span>
          색으로 된 것입니다. head를 선택한 이유는 패턴 매칭으로 얻기 쉽기 때문입니다. pivot 보다 작은 원소는
          <span style="color: rgb(0, 255, 0); font-weight: bold;">light
            green</span> 색이며, piviot보다 큰 것은 <span style="color: rgb(0, 51, 0); font-weight: bold;">dark








            green</span> 색입니다. 누런색으로 표시된 것은 quicksort가 작동하는 것을 나타냅니다.</p>
        <a name="thinking-recursively"></a>
        <h2>재귀적으로 생각하기</h2>
        <p>상당히 많은 수의 재귀를 하면서, 여러분이 느끼셨다시피 여기엔 패턴이 존재합니다. 보통 주변상황을 정의하고
          어떤 원소와 나머지에 함수를 적용하는 무언가를 하는 함수를 정의합니다. 리스트, 트리, 다른 자료구조들이건
          상관치 않습니다. sum은 리스트의 첫번째 원소에 나머지들의 합(sum)을 더합니다. product은 리스트의
          첫번째 원소에 나머지들의 곱(product)을 곱합니다. length는 1더하기 tail의 length를 더한
          것입니다. 블라 블라 ...</p>
        <p> <img src="http://s3.amazonaws.com/lyah/brain.png" alt="brain"
            class="left" height="219" width="250"> </p>
        <p>물론, 이것들도 주변 조건을 지닙니다. 주변 조건은 보통 재귀를 만족하지 못하는 상황을 나타냅니다. 리스트를
          다룰때, 주변 조건은 주로 빈 리스트입니다. 트리를 다룬다면, 주변 조건은 보통 자식을 지니지 않는 노드일
          것입니다.</p>
        <p>숫자를 재귀적으로 다룰때도 마찬가지 입니다. Usually it has to do with some
          number and the function applied to that number modified. We
          did the factorial function earlier and it's the product of a
          number and the factorial of that number minus one. 이와 같은 재귀과정은
          양수에 대해서만 계승(factorial)이 정의되었기에, 0일때는 맞지 않습니다. 주변 조건은 종종 항등원이
          되기도 합니다. 무언가에 1을 곱하면 그대로 돌려받기에 곱셈의 항등원은 1입니다. 또한 리스트를 합할때,
          비더있는 리스트를 0으로 정의했으므로, 0이 덧셈의 항등윈입니다. quicksort에선, 주변 조건은 비어있는
          리스트이며, 어떠한 리스트에 빈 리스트를 더한다면, 원래 리스트를 얻기에 항등원 또한 빈 리스트 입니다.</p>
        <p>따라서 문제를 해결하기 위해 재귀적인 방법을 생각할 시에는, 재귀적인 해결책이 적용되지 않는 경우와 try
          to think of when a recursive solution doesn't apply and see if
          you can use that as an edge case, think about identities and
          think about whether you'll break apart the parameters of the
          function (예를들어, 리스트는 보통 패턴매칭을 통해 head와 tail로 나누어 집니다.) and on
          which part you'll use the recursive call.</p>
        <div class="footdiv">
          <ul>
            <li style="text-align: left;"> <a href="syntax-in-functions"
                class="prevlink">Syntax in Functions</a> </li>
            <li style="text-align: center;"> <a href="chapters">목 차</a>
            </li>
            <li style="text-align: right;"> <a href="higher-order-functions"
                class="nxtlink">Higher Order Functions</a> </li>
          </ul>
        </div>
      </div>
      <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
      <script type="text/javascript" src="shBrushHaskell.js"></script>
      <script type="text/javascript" src="shBrushPlain.js"></script>
      <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script> </div>
    <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script> </body>
</html>
